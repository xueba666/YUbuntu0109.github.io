{"meta":{"title":"欢迎参观小灰灰的网站哟 ヾ(◍°∇°◍)ﾉﾞ ~","subtitle":"My Personal blog website —— be founded on March 9, 2019 and the open source address for blog notes https://github.com/YUbuntu0109/YUbuntu0109.github.io","description":"My personal website ~","author":"黄宇辉","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-03-09T13:21:39.000Z","updated":"2019-08-25T06:31:01.225Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-09T13:12:14.000Z","updated":"2019-08-25T06:31:01.225Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java设计模式之Observer Pattern","slug":"Java设计模式之Observer-Pattern","date":"2019-09-28T05:39:33.000Z","updated":"2019-09-29T05:48:21.471Z","comments":true,"path":"2019/09/28/Java设计模式之Observer-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/28/Java设计模式之Observer-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Observer Pattern定义观察者设计模式 : 定义对象之间的一种一对多的依赖关系,使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新. ( Observer Pattern : Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically ) 概述观察者模式的别名有发布-订阅( Publish-Subscribe )模式,模型-视图( Model-View )模式,源-监听器( Source-Listener )模式,从属者( Dependents )模式. 观察者模式是一种对象行为模式. 其用于描述对象之间的依赖关系,为实现多个对象之间的联动提供了一种解决方案,是一种对象行为型模式. 角色分析 Subject( 目标 ) : 目标又称为主题,它是指被观察的对象. 在目标中定义了一个观察者集合,一个观察者目标可以接收任意数量的观察者来观察,它提供了一系列方法来增加和删除观察者对象,同时它定义了通知方法 notify(). 目标类可以是接口,也可以是抽象类或具体类. ConcreteSubject( 具体目标 ) : 具体目标是目标类的子类,它通常包含有经常方法改变的数据,当它的状态发生改变时将向它的各个观察者发出通知,同时还可以实现了在目标类中定义的抽象业务逻辑方法. 如果无需扩展目标类,则具体目标类可以省略. Observer( 观察者 ) : 观察者将对观察目标的改变做出反应,观察者一般定义为接口,该接口声明了更新数据的 update() 方法,因此又称为抽象观察者. ConcreteObserver( 具体观察者 ) : 在具体观察者中维护了一个指向具体目标对象的引用,它存储具体观察者的有关状态,这些状态需要和目标的状态保持一致. 它实现了在抽象观察者 Observer 中定义的 update() 方法. 通常在实现时可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除. 示例程序下面是一个使用观察者设计模式的简单示例程序,模拟功能 : 在某多人联机对战游戏中,多个玩家可以加入同一战队组成联盟,当战队中的某一成员被敌人攻击时,其可以向其它队友发送求救通知,队友接收通知后作出相应的反应,既而来实现战队成员之间的联动~ AllyControllerCenter抽象类 : 指挥部(战队控制中心)类, 充当抽象目标类 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.observer_pattern.observer_pattern_1;import java.util.ArrayList;/** * @project: design-patterns * @description: 指挥部(战队控制中心)类, 充当抽象目标类 * @author: 黄宇辉 * @date: 9/29/2019-12:02 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class AllyControllerCenter &#123; protected String allyName; //定义一个集合用于存储战队成员 protected ArrayList&lt;Observer&gt; players = new ArrayList&lt;&gt;(); public void setAllyName(String allyName) &#123; this.allyName = allyName; &#125; public String getAllyName(String allyName) &#123; return allyName; &#125; //注册方法 public void join(Observer observer) &#123; System.out.println(\"玩家: [ \" + observer.getName() + \" ]加入战队\"); players.add(observer); &#125; //注销方法 public void quit(Observer observer) &#123; System.out.println(\"玩家: [ \" + observer.getName() + \" ]退出战队\"); players.remove(observer); &#125; //声明抽象通知方法 public abstract void noifyObserver(String name);&#125; ConcreteAllyControlCenter类 : 具体指挥部类, 充当具体目标类 1234567891011121314151617181920212223242526272829package pers.huangyuhui.observer_pattern.observer_pattern_1;/** * @project: design-patterns * @description: 具体指挥部类, 充当具体目标类 * @author: 黄宇辉 * @date: 9/29/2019-12:16 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ConcreteAllyControlCenter extends AllyControllerCenter &#123; public ConcreteAllyControlCenter(String allyName) &#123; this.allyName = allyName; System.out.println(\"------ 战队: [ \" + allyName + \" ]组建成功 ------\"); &#125; //实现通知方法 @Override public void noifyObserver(String name) &#123; System.out.println(\"战队: [ \" + this.allyName + \" ]指挥部发送的紧急通知 : 队友[ \" + name + \" ]正在遭受敌人攻击\"); //遍历观察者集合,调用每一个队友(除自己)的支援方法 for (Observer player : players) &#123; if (!(player.getName().equalsIgnoreCase(name))) &#123; player.help(); &#125; &#125; &#125;&#125; Observer接口 : 抽象观察者类 1234567891011121314151617181920package pers.huangyuhui.observer_pattern.observer_pattern_1;/** * @project: design-patterns * @description: 抽象观察者类 * @author: 黄宇辉 * @date: 9/29/2019-12:05 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Observer &#123; String getName(); void setName(String name); void help(); //声明支援盟友的方法 void beAttacked(AllyControllerCenter allyControllerCenter); //声明遭受攻击的方法&#125; Player类 : 战队成员类, 充当具体观察者类 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.observer_pattern.observer_pattern_1;/** * @project: design-patterns * @description: 战队成员类, 充当具体观察者类 * @author: 黄宇辉 * @date: 9/29/2019-12:21 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Player implements Observer &#123; private String name; public Player(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public void setName(String name) &#123; this.name = name; &#125; //支援盟友方法的实现 @Override public void help() &#123; System.out.println(\"坚持住! 队友:[ \" + this.name + \" ]前来支援你\"); &#125; //遭受攻击方法的实现,当遭受攻击时将调用战队控制中心类的通知方法noifyObserver()来通知各个盟友 @Override public void beAttacked(AllyControllerCenter allyControllerCenter) &#123; System.out.println(\"队友: [ \" + this.name + \" ]正在被敌人攻击\"); allyControllerCenter.noifyObserver(name); &#125;&#125; Client类 : 客户端测试类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.observer_pattern.observer_pattern_1;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/29/2019-12:31 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; //定义观察目标对象 AllyControllerCenter allyControllerCenter = new ConcreteAllyControlCenter(\"YU\"); //定义四个观察者对象 Observer player1, player2, player3, player4; player1 = new Player(\"player-A\"); allyControllerCenter.join(player1); player2 = new Player(\"player-B\"); allyControllerCenter.join(player2); player3 = new Player(\"player-C\"); allyControllerCenter.join(player3); player4 = new Player(\"player-D\"); allyControllerCenter.join(player4); //player-A队友遭受敌人攻击 player1.beAttacked(allyControllerCenter); &#125;&#125; 示例程序的运行结果如下所示 : 12345678910------ 战队: [ YU ]组建成功 ------玩家: [ player-A ]加入战队玩家: [ player-B ]加入战队玩家: [ player-C ]加入战队玩家: [ player-D ]加入战队队友: [ player-A ]正在被敌人攻击战队: [ YU ]指挥部发送的紧急通知 : 队友[ player-A ]正在遭受敌人攻击坚持住! 队友:[ player-B ]前来支援你坚持住! 队友:[ player-C ]前来支援你坚持住! 队友:[ player-D ]前来支援你 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Proxy Pattern","slug":"Java设计模式之Proxy-Pattern","date":"2019-09-25T04:25:51.000Z","updated":"2019-09-27T06:16:18.945Z","comments":true,"path":"2019/09/25/Java设计模式之Proxy-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/25/Java设计模式之Proxy-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Proxy Pattern定义代理模式 : 给某一个对象提供一个代理或占位符,并由代理对象来控制对原对象的访问. (Proxy Pattern : Provide a surrogate or placehodler for another object to access to it) 概述代理模式是常用的结构型设计模式之一,当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问,为了保证客户端使用的透明性,所访问的真实对象与代理对象需要实现相同的接口. 根据代理模式的使用目的不同,代理模式又可以分为多种类型,例如保护代理,远程代理,虚拟代理,缓冲代理等,它们应用于不同的场合,满足用户的不同需求. 角色分析 Subject( 抽象主题角色 ) : 它声明了真实主题与代理主题的共同接口,既任何使用真实主题的地方都可以使用代理主题,客户端通常需要针对抽象主题角色进行编程. Proxy( 代理主题角色 ) : 它包含了对真实主题的引用,既可以在任何时候操作真实主题对象. 在代理主题角色中提供了一个与真实主题角色相同的接口,以便在任何时候都可以替代真实主题. 代理主题角色还可以控制对真实主题的使用,负责在需要的时候创建和删除真实主题对象,并对真实主题对象的使用加以约束. RealSubject( 真实主题角色 ) : 它定义了代理角色所代表的真实对象,在真实主题角色中实现了真实的业务操作,客户端可以通过代理主题角色间接调用真实主题角色中定义的操作. 示例程序-静态代理下面是一个使用代理模式( 静态代理 )的简单示例程序 : 模拟实现某商务信息查询系统的部分功能 : ( 一 )在进行商务信息查询前用户需要通过身份验证,只有合法的用户才能够使用该查询系统. ( 二 )在进行商务信息查询时系统需要记录其查询日志,以便根据查询次数收取查询费用 AccessValidator类 : 身份验证类(业务类), 它提供validate()方法来实现用户身份的验证 1234567891011121314151617181920212223package pers.huangyuhui.froxy_pattern.froxy_pattern_1;/** * @project: design-patterns * @description: 身份验证类(业务类), 它提供validate()方法来实现用户身份的验证 * @author: 黄宇辉 * @date: 9/25/2019-12:53 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class AccessValidator &#123; //模拟实现登录验证 public boolean validate(String userId) &#123; if (userId.equalsIgnoreCase(\"yubuntu0109\")) &#123; System.out.println(\"ID为:[ \" + userId + \" ]的用户登录成功\"); return true; &#125; else &#123; System.out.println(\"ID为:[ \" + userId + \" ]的用户登录失败\"); return false; &#125; &#125;&#125; Logger类 : 日志记录类(业务类), 提供一个log()方法来保存日志信息 1234567891011121314151617package pers.huangyuhui.froxy_pattern.froxy_pattern_1;/** * @project: design-patterns * @description: 日志记录类(业务类), 提供一个log()方法来保存日志信息 * @author: 黄宇辉 * @date: 9/25/2019-12:57 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Logger &#123; //模拟实现日志记录 public void log(String userId) &#123; System.out.println(\"成功更新数据库信息,ID为:[ \" + userId + \"+ ]的用户查询次数+1\"); &#125;&#125; Searcher接口 : 抽象查询类, 充当抽象主题角色 12345678910111213package pers.huangyuhui.froxy_pattern.froxy_pattern_1;/** * @project: design-patterns * @description: 抽象查询类, 充当抽象主题角色 * @author: 黄宇辉 * @date: 9/25/2019-1:00 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Searcher &#123; String doSearch(String userId, String keyWord);&#125; RealSearcher类 : 具体查询类, 充当真实主题角色, 它实现了查询功能 12345678910111213141516171819package pers.huangyuhui.froxy_pattern.froxy_pattern_1;/** * @project: design-patterns * @description: 具体查询类, 充当真实主题角色, 它实现了查询功能 * @author: 黄宇辉 * @date: 9/25/2019-1:01 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class RealSearcher implements Searcher &#123; //模拟查询商务信息 @Override public String doSearch(String userId, String keyWord) &#123; System.out.println(\"ID为:[ \" + userId + \" ]的用户使用关键字:[ \" + keyWord + \" ]查询了商务信息\"); return \"[ 这是用户所查询的商务信息结果 ]\"; &#125;&#125; ProxySearcher类 : 代理查询类, 充当代码主题角色, 它是查询代理, 维持了对RealSearcher, AccessValidator, 及Logger对象的引用 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.froxy_pattern.froxy_pattern_1;/** * @project: design-patterns * @description: 代理查询类, 充当代码主题角色, 它是查询代理, 维持了对RealSearcher, AccessValidator, 及Logger对象的引用 * @author: 黄宇辉 * @date: 9/25/2019-1:05 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ProxySearcher implements Searcher &#123; private RealSearcher realSearcher = new RealSearcher(); //维持一个对真实主题的引用 private AccessValidator accessValidator; private Logger logger; @Override public String doSearch(String userId, String keyWord) &#123; //如果身份验证成功,则执行查询操作 if (this.validate(userId)) &#123; String result = realSearcher.doSearch(userId, keyWord); //调用真实主题的查询方法 this.log(userId); //记录查询日志 return result; &#125; else &#123; return null; &#125; &#125; //创建访问验证对象并调用其validate()方法来实现身份验证 public boolean validate(String userId) &#123; accessValidator = new AccessValidator(); return accessValidator.validate(userId); &#125; //创建日志记录对象并调用其log()方法来实现日志记录 public void log(String userId) &#123; logger = new Logger(); logger.log(userId); &#125;&#125; Client类 : 客户端测试类 1234567891011121314151617package pers.huangyuhui.froxy_pattern.froxy_pattern_1;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/25/2019-1:13 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; Searcher searcher = new ProxySearcher(); System.out.println(searcher.doSearch(\"yubuntu0109\", \"design-patterns-in-java\")); &#125;&#125; 示例程序的运行结果如下所示 : 1234ID为:[ yubuntu0109 ]的用户登录成功ID为:[ yubuntu0109 ]的用户使用关键字:[ design-patterns-in-java ]查询了商务信息成功更新数据库信息,ID为:[ yubuntu0109+ ]的用户查询次数+1[ 这是用户所查询的商务信息结果 ] 示例程序的类图 示例程序-动态代理下面是一个使用代理模式( 动态代理 )的示例程序 : 模拟为某 OA 系统数据访问层( DAO )增加方法调用日志,既记录每一个方法被调用的开始及结束时间 AbstractUserDao接口 : 抽象用户DAO类, 充当抽象主题角色 12345678910111213package pers.huangyuhui.froxy_pattern.froxy_pattern_2;/** * @project: design-patterns * @description: 抽象用户DAO类, 充当抽象主题角色 * @author: 黄宇辉 * @date: 9/25/2019-1:16 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface AbstractUserDao &#123; boolean findUserById(String userId);&#125; AbstractDocumentDao接口 : 抽象文档DAO类, 充当抽象主题角色 12345678910111213package pers.huangyuhui.froxy_pattern.froxy_pattern_2;/** * @project: design-patterns * @description: 抽象文档DAO类, 充当抽象主题角色 * @author: 黄宇辉 * @date: 9/25/2019-1:17 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface AbstractDocumentDao &#123; boolean deleteDocumentById(String documentId);&#125; DocumentDao类 : 文档DAO类, 充当具体主题角色 1234567891011121314151617181920212223package pers.huangyuhui.froxy_pattern.froxy_pattern_2;/** * @project: design-patterns * @description: 文档DAO类, 充当具体主题角色 * @author: 黄宇辉 * @date: 9/25/2019-1:21 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DocumentDao implements AbstractDocumentDao &#123; @Override public boolean deleteDocumentById(String documentId) &#123; if (documentId.equalsIgnoreCase(\"Y001\")) &#123; System.out.println(\"成功删除ID为:[ \" + documentId + \" ]的文档信息\"); return true; &#125; else &#123; System.out.println(\"并未找到ID为:[ \" + documentId + \" ]的文档信息\"); return false; &#125; &#125;&#125; UserDao类 : 用户DAO类, 充当具体主题角色 1234567891011121314151617181920212223package pers.huangyuhui.froxy_pattern.froxy_pattern_2;/** * @project: design-patterns * @description: 用户DAO类, 充当具体主题角色 * @author: 黄宇辉 * @date: 9/25/2019-1:18 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class UserDao implements AbstractUserDao &#123; @Override public boolean findUserById(String userId) &#123; if (userId.equalsIgnoreCase(\"yubuntu0109\")) &#123; System.out.println(\"成功查询ID为:[ \" + userId + \" ]的用户信息\"); return true; &#125; else &#123; System.out.println(\"并未查询ID为:[\" + userId + \" ]的用户信息\"); return false; &#125; &#125;&#125; DAOLogHandler类 : 自定义请求处理程序类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.froxy_pattern.froxy_pattern_2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Date;import java.util.Timer;/** * @project: design-patterns * @description: 自定义请求处理程序类 * @author: 黄宇辉 * @date: 9/25/2019-1:24 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DAOLogHandler implements InvocationHandler &#123; private Object object; public DAOLogHandler() &#123; &#125; //注入一个需要提供代理的真实主题对象 public DAOLogHandler(Object object) &#123; this.object = object; &#125; public void beforeInvoke() &#123; System.out.println(\"------&gt; invoke before: \" + new Date().toString()); &#125; public void afterInvoke() &#123; System.out.println(\"------&gt; invoke after: \" + new Date().toString()); &#125; //实现invoke()方法,调用在真实主题类中定义的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; beforeInvoke(); Object result = method.invoke(object, args); //转发调用 afterInvoke(); return result; &#125;&#125; Client类 : 客户端测试类 123456789101112131415161718192021222324252627package pers.huangyuhui.froxy_pattern.froxy_pattern_2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/25/2019-1:29 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; InvocationHandler handler = new DAOLogHandler(new UserDao()); AbstractUserDao proxy = (AbstractUserDao) Proxy.newProxyInstance(AbstractUserDao.class.getClassLoader(), new Class[]&#123;AbstractUserDao.class&#125;, handler); proxy.findUserById(\"yubuntu0109\"); System.out.println(\"------------------------------\"); InvocationHandler handler2 = new DAOLogHandler(new DocumentDao()); AbstractDocumentDao proxy2 = (AbstractDocumentDao) Proxy.newProxyInstance(AbstractDocumentDao.class.getClassLoader(), new Class[]&#123;AbstractDocumentDao.class&#125;, handler2); proxy2.deleteDocumentById(\"Y001\"); &#125;&#125; 示例程序运行的结果如下所示 : 123456789------&gt; invoke before: Fri Sep 27 14:05:06 CST 2019成功查询ID为:[ yubuntu0109 ]的用户信息------&gt; invoke after: Fri Sep 27 14:05:06 CST 2019------------------------------------&gt; invoke before: Fri Sep 27 14:05:06 CST 2019成功删除ID为:[ Y001 ]的文档信息------&gt; invoke after: Fri Sep 27 14:05:06 CST 2019 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Command Pattern","slug":"Java设计模式之Command-Pattern","date":"2019-09-20T08:56:53.000Z","updated":"2019-09-25T14:04:42.944Z","comments":true,"path":"2019/09/20/Java设计模式之Command-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/20/Java设计模式之Command-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Command Pattern定义命令模式 : 将一个请求封装为一个对象,从而可用不同的请求对客户进行参数化,对请求排队或者记录请求日志,以及支持可撤销的操作. ( Command Pattern : Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and undoable operations ) 扩 : 命令模式是一种对象行为型模式,其别名为动作( Action )模式或事物( Transaction )模式. 命令模式是常用的行为型模式之一,它将请求发送者与请求接收者解耦,请求发送者通过命令对象来间接引用接受者,使得系统具有更好的灵活性,可以在不修改现有系统源码代码的情况下让相同的发送者对应不同的接受者. 角色分析 Command( 抽象命令类 ) : 抽象命令类一般是一个抽象接类或接口,在其中声明了用于执行请求的 execute() 等方法,通过这些方法可以调用请求接收者的相关操作. ConcreteCommand( 具体命令类 ) : 具体命令类是抽象命令类的子类,实现了在抽象命令类中声明的方法,它对应具体的接收者对象,将接收者对象的动作绑定其中. 具体命令类在实现 execute() 方法时将调用接收者对象的相关操作. Invoker( 调用者 ) : 调用者既请求发送者,它通过命令对象来执行请求. 一个调用者并不需要在设计时确定其接收者,因此它只与抽象命令类之间存在关联关系. 在程序运行时可以将一个具体命令对象注入其中,再调用具体命令对象的 execute() 方法,从而实现间接调用请求接收者的相关操作. Receiver( 接收者 ) : 接收者执行与请求相关的操作,具体实现对请求业务的处理. 示例程序-1下面是一个使用命令设计模式的简单程序案例,案例说明 : 某系统提供了一系列功能键,用户可以自定义功能键( FunctionButton )的功能,例如登录键( LoginInCommand )用于登录系统,退出键( LoginOutCommand )用于注销系统 · · · FunctionButton类 : 功能键类, 充当请求调用者(请求发送者) 12345678910111213141516171819202122232425package pers.huangyuhui.command_pattern.command_pattern_1;/** * @project: design-patterns * @description: 功能键类, 充当请求调用者(请求发送者) * @author: 黄宇辉 * @date: 9/20/2019-8:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FunctionButton &#123; private Command command; //为功能键注入命令 public void setCommand(Command command) &#123; this.command = command; &#125; //发送请求的方法 public void click() &#123; command.execute(); &#125;&#125; Command抽象类 : 抽象命令类 12345678910111213package pers.huangyuhui.command_pattern.command_pattern_1;/** * @project: design-patterns * @description: 抽象命令类 * @author: 黄宇辉 * @date: 9/20/2019-9:01 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class Command &#123; public abstract void execute();&#125; LoginInCommand类 : 登录命令类, 充当具体命令类 123456789101112131415161718192021222324package pers.huangyuhui.command_pattern.command_pattern_1;/** * @project: design-patterns * @description: 登录命令类, 充当具体命令类 * @author: 黄宇辉 * @date: 9/20/2019-9:07 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LoginInCommand extends Command &#123; private LoginInSystem enterSystem; public LoginInCommand() &#123; this.enterSystem = new LoginInSystem(); &#125; //命令执行方法,将调用请求接收者的业务方法 @Override public void execute() &#123; enterSystem.login(); &#125;&#125; LoginOutCommand类 : 退出命令类, 充当具体命令类 123456789101112131415161718192021222324package pers.huangyuhui.command_pattern.command_pattern_1;/** * @project: design-patterns * @description: 退出命令类, 充当具体命令类 * @author: 黄宇辉 * @date: 9/20/2019-9:05 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LoginOutCommand extends Command &#123; private LoginOutSystem exitSystem; public LoginOutCommand() &#123; this.exitSystem = new LoginOutSystem(); &#125; //命令执行方法,将调用请求接受者的业务方法 @Override public void execute() &#123; exitSystem.exit(); &#125;&#125; LoginInSystem类 : 登录系统的模拟实现类, 充当请求接收者 12345678910111213141516package pers.huangyuhui.command_pattern.command_pattern_1;/** * @project: design-patterns * @description: 登录系统的模拟实现类, 充当请求接收者 * @author: 黄宇辉 * @date: 9/20/2019-9:10 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LoginInSystem &#123; public void login() &#123; System.out.println(\"login in\"); &#125;&#125; LoginOutSystem类 : 退出系统的模拟实现类, 充当请求接收者 12345678910111213141516package pers.huangyuhui.command_pattern.command_pattern_1;/** * @project: design-patterns * @description: 退出系统的模拟实现类, 充当请求接收者 * @author: 黄宇辉 * @date: 9/20/2019-9:08 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LoginOutSystem &#123; public void exit() &#123; System.out.println(\"login out\"); &#125;&#125; Client类 : 客户端测试类 12345678910111213141516171819202122232425package pers.huangyuhui.command_pattern.command_pattern_1;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/20/2019-9:11 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; FunctionButton functionButton = new FunctionButton(); Command login_key = new LoginInCommand(); functionButton.setCommand(login_key); functionButton.click(); System.out.println(\"--------------------\"); Command exit_key = new LoginOutCommand(); functionButton.setCommand(exit_key); functionButton.click(); &#125;&#125; 示例程序运行的结果如下所示 : 123login in--------------------login out 示例程序的类图 示例程序-2下面是一个使用命令设计模式的简单程序案例,案例说明 : 设计一个画图软件,既用户可以通过拖动鼠标在画板上画画,点击 clear 按钮时会擦除画板上的痕迹. Command接口 : 表示”命令”的接口,充当(抽象)命令 12345678910111213package pers.huangyuhui.command_pattern.command_pattern_2;/** * @project: design-patterns * @description: 表示\"命令\"的接口,充当(抽象)命令 * @author: 黄宇辉 * @date: 9/20/2019-9:25 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Command &#123; void execute();&#125; MacroCommand类 : 表示”由多条命令整合成的命令”的类,充当具体的命令 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.command_pattern.command_pattern_2;import java.util.Stack;/** * @project: design-patterns * @description: 表示\"由多条命令整合成的命令\"的类,充当具体的命令 * @author: 黄宇辉 * @date: 9/20/2019-9:27 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class MacroCommand implements Command &#123; //命令的集合 private Stack commands = new Stack(); //执行命令 @Override public void execute() &#123; for (Object command : commands) &#123; ((Command) command).execute(); &#125; &#125; //添加命令 public void append(Command command) &#123; if (command != this) &#123; commands.push(command); &#125; &#125; //清除命令 public void clear() &#123; commands.clear(); &#125;&#125; DrawCommand类 : 表示”绘制一个点的命令( 画笔 )”的类,充当具体的命令 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.command_pattern.command_pattern_2;import java.awt.*;/** * @project: design-patterns * @description: 表示\"绘制一个点的命令\"的类,充当具体的命令 * @author: 黄宇辉 * @date: 9/20/2019-9:33 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DrawCommand implements Command &#123; //绘制对象 protected Drawable drawable; //绘制位置 private Point position; //构造函数 public DrawCommand(Drawable drawable, Point position) &#123; this.drawable = drawable; this.position = position; &#125; //执行命令 @Override public void execute() &#123; drawable.draw(position.x, position.y); &#125;&#125; Drawable接口 : 表示”绘制对象”的接口 12345678910111213package pers.huangyuhui.command_pattern.command_pattern_2;/** * @project: design-patterns * @description: 表示\"绘制对象\"的接口 * @author: 黄宇辉 * @date: 9/20/2019-9:37 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Drawable &#123; void draw(int x, int y);&#125; DrawCanvas类 : 实现”绘制对象”的类,充当接收者 1234567891011121314151617181920212223242526272829303132333435363738394041package pers.huangyuhui.command_pattern.command_pattern_2;import java.awt.*;/** * @project: design-patterns * @description: 实现\"绘制对象\"的类,充当接收者 * @author: 黄宇辉 * @date: 9/20/2019-9:39 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DrawCanvas extends Canvas implements Drawable &#123; //颜色 private Color color = Color.green; //要绘制的圆点半径 private int redius = 5; //命令的历史记录 private MacroCommand history; //构造函数 public DrawCanvas(int width, int height, MacroCommand history) &#123; this.setSize(width, height); this.setBackground(Color.white); this.history = history; &#125; //重新全部绘制 public void repaint(Graphics graphics) &#123; history.execute(); &#125; //绘制 @Override public void draw(int x, int y) &#123; Graphics graphics = getGraphics(); graphics.setColor(color); graphics.fillOval(x - redius, y - redius, redius * 2, redius * 2); &#125;&#125; Client类 : 客户端测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package pers.huangyuhui.command_pattern.command_pattern_2;import javax.swing.*;import java.awt.*;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/20/2019-9:48 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client extends JFrame &#123; //绘制的历史记录 private MacroCommand history = new MacroCommand(); //绘制区域(设置画板大小) private DrawCanvas canvas = new DrawCanvas(600, 400, history); //删除按钮 private JButton clearButton = new JButton(\"clear\"); public Client(String title) &#123; super(title); /* 鼠标拖动事件 */ canvas.addMouseMotionListener(new MouseMotionAdapter() &#123; @Override public void mouseDragged(MouseEvent e) &#123; Command command = new DrawCommand(canvas, e.getPoint()); history.append(command); command.execute(); &#125; &#125;); /* 动作监听事件 */ clearButton.addActionListener(e -&gt; &#123; if (e.getSource() == clearButton) &#123; history.clear(); canvas.repaint(); &#125; &#125;); /* JFrame面板配置 */ setLayout(new BorderLayout()); add(clearButton, BorderLayout.NORTH); add(canvas, BorderLayout.SOUTH); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); pack(); setVisible(true); &#125; public static void main(String[] args) &#123; new Client(\"a simple drawing board\"); &#125;&#125; 示例程序的运行结果如下图所示 : 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Builder Pattern","slug":"Java设计模式之Builder-Pattern","date":"2019-09-17T14:00:54.000Z","updated":"2019-09-25T13:56:15.328Z","comments":true,"path":"2019/09/17/Java设计模式之Builder-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/17/Java设计模式之Builder-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Builder Pattern概述缔造者设计模式 : 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示( Builder Pattern : Separate the construction of complex object from its representation so that the same construction process can create different representations ) 扩 : 建造者模式是一种对象创建型模式,它将客户端与包含多个部件的复杂对象的创建过程分离,客户端无需知道复杂对象的内部组成部分与装配方式,只需要知道所需建造者的类型即可. 建造者设计模式中的角色 Builder( 抽象建造者 ) : 它为创建一个产品的各个部件指定抽象接口,在该接口中一般声明两类方法,一类方法是 buildPartX(),其用于创建复杂对象的各个部件. 另一类方法是 getResult(),其用于返回复杂对象. Builder 即可是抽象类,也可以是接口. ConcreteBuilder( 具体建造者 ) : 它实现了 Builder 接口,实现了各个部件的具体构造和装配方法,定义并明确所创建的复杂对象,还可以提供一个用于返回创建好的复杂产品的方法( 该方法可以由抽象构建者实现 ). Product( 产品 ) : 它是被创建的复杂对象,包含多个组成部件,具体建造者创建该产品的内部表示并定义它的装配过程. Director( 指挥者 ) : 指挥者又称为导演类,它负责安排复杂对象的建造次序,指挥者与抽象构建者之间存在关联关系,可以在其 construct() 建造方法中调用建造者对象的部件构造与装配方法,完成复杂对象的建造. 示例程序下面是一个使用了建造者设计模式的简单示例程序,其概述为 : 无论是何种游戏角色,都需要逐步创建其组成部分,再将各组成部分配装成一个完整的游戏角色. Actor类 : 游戏角色类, 充当复杂产品对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package pers.huangyuhui.builder_pattern.builder_pattern_1;/** * @project: design-patterns * @description: 游戏角色类, 充当复杂产品对象 * @author: 黄宇辉 * @date: 9/19/2019-1:30 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Actor &#123; private String type; //角色类型 private String sex; //性别 private String face; //脸型 private String costume; //服装 public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getFace() &#123; return face; &#125; public void setFace(String face) &#123; this.face = face; &#125; public String getCostume() &#123; return costume; &#125; public void setCostume(String costume) &#123; this.costume = costume; &#125; @Override public String toString() &#123; return \"Actor&#123;\" + \"type='\" + type + '\\'' + \", sex='\" + sex + '\\'' + \", face='\" + face + '\\'' + \", costume='\" + costume + '\\'' + '&#125;'; &#125;&#125; ActorBuilder抽象类 : 游戏角色建造者, 充当抽象建造者 1234567891011121314151617181920212223242526package pers.huangyuhui.builder_pattern.builder_pattern_1;/** * @project: design-patterns * @description: 游戏角色建造者, 充当抽象建造者 * @author: 黄宇辉 * @date: 9/19/2019-1:39 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class ActorBuilder &#123; protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); //工厂方法,返回一个完整的游戏角色对象 public Actor createActor() &#123; return actor; &#125;&#125; HeroBuilder类 : 英雄角色建造者, 充当具体建造者 12345678910111213141516171819202122232425262728293031package pers.huangyuhui.builder_pattern.builder_pattern_1;/** * @project: design-patterns * @description: 英雄角色建造者, 充当具体建造者 * @author: 黄宇辉 * @date: 9/19/2019-1:42 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class HeroBuilder extends ActorBuilder &#123; @Override public void buildType() &#123; actor.setType(\"英雄\"); &#125; @Override public void buildSex() &#123; actor.setSex(\"男\"); &#125; @Override public void buildFace() &#123; actor.setFace(\"英俊\"); &#125; @Override public void buildCostume() &#123; actor.setCostume(\"盔甲\"); &#125;&#125; AngelBuilder类 : 天使角色建造者, 充当具体建造类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.builder_pattern.builder_pattern_1;/** * @project: design-patterns * @description: 天使角色建造者, 充当具体建造类 * @author: 黄宇辉 * @date: 9/19/2019-1:44 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class AngelBuilder extends ActorBuilder &#123; @Override public void buildType() &#123; actor.setType(\"天使\"); &#125; @Override public void buildSex() &#123; actor.setSex(\"女\"); &#125; @Override public void buildFace() &#123; actor.setFace(\"漂亮\"); &#125; @Override public void buildCostume() &#123; actor.setCostume(\"裙子\"); &#125;&#125; ActorController类 : 角色控制器, 充当指挥者 1234567891011121314151617181920212223package pers.huangyuhui.builder_pattern.builder_pattern_1;/** * @project: design-patterns * @description: 角色控制器, 充当指挥者 * @author: 黄宇辉 * @date: 9/19/2019-1:46 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ActorController &#123; //逐步构建复杂产品对象 public Actor construct(ActorBuilder actorBuilder) &#123; Actor actor; actorBuilder.buildType(); actorBuilder.buildSex(); actorBuilder.buildFace(); actorBuilder.buildCostume(); actor = actorBuilder.createActor(); return actor; &#125;&#125; Client类 : 客户端测试类 1234567891011121314151617181920212223242526package pers.huangyuhui.builder_pattern.builder_pattern_1;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/19/2019-1:49 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; ActorController actorController = new ActorController(); ActorBuilder zero = new HeroBuilder(); Actor actor_zero = actorController.construct(zero); System.out.println(actor_zero); System.out.println(\"------------------------------\"); ActorBuilder angel = new AngelBuilder(); Actor actor_angel = actorController.construct(angel); System.out.println(actor_angel); &#125;&#125; 示例程序的运行结果如下所示 : 123Actor&#123;type=&apos;英雄&apos;, sex=&apos;男&apos;, face=&apos;英俊&apos;, costume=&apos;盔甲&apos;&#125;------------------------------Actor&#123;type=&apos;天使&apos;, sex=&apos;女&apos;, face=&apos;漂亮&apos;, costume=&apos;裙子&apos;&#125; 示例程序的类图 示例程序-简化版为了简化系统结构,可以将 Director 和抽象建造者 Builder 进行合并,在 Builder 中提供逐步构建复杂产品对象的 construct() 方法. 由于 Builder 类通常是抽象类,因此可以将 construct() 方法定义为静态方法,以便客户端能够直接调用. 除此之外还有一种更简单的处理方法,既将 construct() 方法中的参数去掉,直接在construct()方法中调用 buildPartX() 方法.( 以下示例程序是基于上述示例程序进行简化的 ) Actor类 : 游戏角色类, 充当复杂产品对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package pers.huangyuhui.builder_pattern.builder_pattern_2;/** * @project: design-patterns * @description: 游戏角色类, 充当复杂产品对象 * @author: 黄宇辉 * @date: 9/19/2019-1:30 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Actor &#123; private String type; //角色类型 private String sex; //性别 private String face; //脸型 private String costume; //服装 public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getFace() &#123; return face; &#125; public void setFace(String face) &#123; this.face = face; &#125; public String getCostume() &#123; return costume; &#125; public void setCostume(String costume) &#123; this.costume = costume; &#125; @Override public String toString() &#123; return \"Actor&#123;\" + \"type='\" + type + '\\'' + \", sex='\" + sex + '\\'' + \", face='\" + face + '\\'' + \", costume='\" + costume + '\\'' + '&#125;'; &#125;&#125; ActorBuilder抽象类 : 游戏角色建造者, 充当抽象建造者(省略Director并简化construct方法) 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.builder_pattern.builder_pattern_2;/** * @project: design-patterns * @description: 游戏角色建造者, 充当抽象建造者(省略Director并简化construct方法) * @author: 黄宇辉 * @date: 9/19/2019-1:39 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class ActorBuilder &#123; protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); //工厂方法,返回一个完整的游戏角色对象 //public Actor createActor() &#123; // return actor; //&#125; //逐步构建复杂产品对象 public Actor construct() &#123; this.buildType(); this.buildSex(); this.buildFace(); this.buildCostume(); return actor; &#125;&#125; HeroBuilder类 : 英雄角色建造者, 充当具体建造者 12345678910111213141516171819202122232425262728293031package pers.huangyuhui.builder_pattern.builder_pattern_2;/** * @project: design-patterns * @description: 英雄角色建造者, 充当具体建造者 * @author: 黄宇辉 * @date: 9/19/2019-1:42 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class HeroBuilder extends ActorBuilder &#123; @Override public void buildType() &#123; actor.setType(\"英雄\"); &#125; @Override public void buildSex() &#123; actor.setSex(\"男\"); &#125; @Override public void buildFace() &#123; actor.setFace(\"英俊\"); &#125; @Override public void buildCostume() &#123; actor.setCostume(\"盔甲\"); &#125;&#125; AngelBuilder类 : 天使角色建造者, 充当具体建造类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.builder_pattern.builder_pattern_2;/** * @project: design-patterns * @description: 天使角色建造者, 充当具体建造类 * @author: 黄宇辉 * @date: 9/19/2019-1:44 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class AngelBuilder extends ActorBuilder &#123; @Override public void buildType() &#123; actor.setType(\"天使\"); &#125; @Override public void buildSex() &#123; actor.setSex(\"女\"); &#125; @Override public void buildFace() &#123; actor.setFace(\"漂亮\"); &#125; @Override public void buildCostume() &#123; actor.setCostume(\"裙子\"); &#125;&#125; Client类 : 客户端测试类 12345678910111213141516171819202122package pers.huangyuhui.builder_pattern.builder_pattern_2;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/19/2019-1:49 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; Actor zero = new HeroBuilder().construct(); System.out.println(zero); System.out.println(\"------------------------------\"); Actor angel = new AngelBuilder().construct(); System.out.println(angel); &#125;&#125; 示例程序的运行结果如下所示 : 123Actor&#123;type=&apos;英雄&apos;, sex=&apos;男&apos;, face=&apos;英俊&apos;, costume=&apos;盔甲&apos;&#125;------------------------------Actor&#123;type=&apos;天使&apos;, sex=&apos;女&apos;, face=&apos;漂亮&apos;, costume=&apos;裙子&apos;&#125; 示例程序的类图","categories":[],"tags":[{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java设计模式之Facade Pattern","slug":"Java设计模式之Facade-Pattern","date":"2019-09-12T13:21:41.000Z","updated":"2019-09-14T14:04:36.235Z","comments":true,"path":"2019/09/12/Java设计模式之Facade-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/12/Java设计模式之Facade-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Facade Pattern概述为子系统中的一组接口提供一个统一的入口. 外观模式定义了一个高层接口,这个接口使得这一子系统更加容易使用. ( Facade Pattern : Provide a unified interface to a set of interfaces in a subsystem. Facade defines a highter-level interface that makes the subsystem easier to use. ) 扩 : 外观模式又称门面模式,它是一种对象结构型模式. 外观模式是迪米特法则的一种具体实现,通过引入一个新的外观角色来降低原有系统的复杂度,同时降低客户类与子系统的耦合度. 外观设计模式中使用的角色 Facade( 外观角色 ) : 在客户端可以调用它的方法,在外观角色中知道相关的( 一个或多个 )子系统的功能和责任. 在正常情况下,它将所有从客户端发来的请求委派到相应的子系统,传递给相应的子系统对象处理. SubSystem( 子系统角色 ) : 在软件系统中有一个或者多个子系统角色,每一个子系统可以不是一个单独的类,而是一个类的集合,它实现了子系统的功能. 每一个子系统都可以被客户端直接调用,或者被外观角色调用,它处理由外观类传递过来的请求. 子系统并不知道外观类的存在,对于子系统而言,外观角色仅仅是另外一个客户端而已. 扩 : 外观模式中所指的子系统是一个广义的概念,它可以是一个类,一个功能模块,系统的一个组成部分或者一个完整的系统. 通常所指一些业务类,实现了一些具体的,独立的业务功能. 示例程序下面是一个使用外观设计模式的简单示例程序 : 写一个用于文件加密的模块,该模块的功能为对指定文件中的数据进行加密并将加密之后的数据保存到新的文件中. 具体流程包括三个部分 : 读取源文件中的数据, 数据加密, 将加密后的数据写入到新文件 FileReader类 : 文件读取类, 充当子系统类 12345678910111213141516171819202122232425262728package pers.huangyuhui.facade_pattern.facade_pattern_1;import java.io.FileInputStream;import java.io.IOException;/** * @project: design-patterns * @description: 文件读取类, 充当子系统类 * @author: 黄宇辉 * @date: 9/12/2019-9:36 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileReader &#123; public String read(String path) &#123; var stringBuffer = new StringBuilder(); try (var fileInputStream = new FileInputStream(path)) &#123; var data = 0; while ((data = fileInputStream.read()) != -1) &#123; stringBuffer.append((char) data); //char &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return stringBuffer.toString(); &#125;&#125; CipherMachine类 : 数据加密类(求模运算), 充当子系统类 123456789101112131415161718192021package pers.huangyuhui.facade_pattern.facade_pattern_1;/** * @project: design-patterns * @description: 数据加密类(求模运算), 充当子系统类 * @author: 黄宇辉 * @date: 9/12/2019-9:42 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class CipherMachine &#123; public String encrypt(String text) &#123; var result = new StringBuilder(); for (int i = 0; i &lt; text.length(); i++) &#123; var s = String.valueOf(text.charAt(i) % 7); result.append(s); &#125; return result.toString(); &#125;&#125; FileWriter类 : 文件保存类, 充当子类系统类 1234567891011121314151617181920212223package pers.huangyuhui.facade_pattern.facade_pattern_1;import java.io.FileOutputStream;import java.io.IOException;/** * @project: design-patterns * @description: 文件保存类, 充当子类系统类 * @author: 黄宇辉 * @date: 9/12/2019-9:56 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileWriter &#123; public void write(String encryptStr, String path) &#123; try (var fileOutputStream = new FileOutputStream(path)) &#123; fileOutputStream.write(encryptStr.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; EncryptFacade类 : 加密外观类, 充当外观类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.facade_pattern.facade_pattern_1;/** * @project: design-patterns * @description: 加密外观类, 充当外观类 * @author: 黄宇辉 * @date: 9/12/2019-9:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class EncryptFacade &#123; //维持对子系统对象的引用 private FileReader fileReader; private CipherMachine cipherMachine; private FileWriter fileWriter; public EncryptFacade() &#123; fileReader = new FileReader(); cipherMachine = new CipherMachine(); fileWriter = new FileWriter(); &#125; //调用子系统对象的业务方法 public void fileEncrypt(String fromPath, String toPath) &#123; var text = fileReader.read(fromPath); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 读取文件[ \" + fromPath + \" ]中的明文数据 : \" + text); var encryptStr = cipherMachine.encrypt(text); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 明文数据加密后的结果 : \" + encryptStr); fileWriter.write(encryptStr, toPath); &#125;&#125; Client类 : 客户端测试类 1234567891011121314151617181920package pers.huangyuhui.facade_pattern.facade_pattern_1;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/14/2019-6:05 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; private static final String FROM_PATH = \"src\\\\main\\\\java\\\\pers\\\\huangyuhui\\\\facade_pattern\\\\facade_pattern_1\\\\from.txt\"; private static final String TO_PATH = \"src\\\\main\\\\java\\\\pers\\\\huangyuhui\\\\facade_pattern\\\\facade_pattern_1\\\\to.txt\"; public static void main(String[] args) &#123; EncryptFacade encryptFacade = new EncryptFacade(); encryptFacade.fileEncrypt(FROM_PATH, TO_PATH); &#125;&#125; from.txt : 源文件,用于存储待加密的数据 1YUbuntu0109 程序运行结果如下所示 : 12&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 读取文件[ src\\main\\java\\pers\\huangyuhui\\facade_pattern\\facade_pattern_1\\from.txt ]中的明文数据 : YUbuntu0109&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 明文数据加密后的结果 : 51055456061 to.txt : 目标文件,用于存储加密后的数据( 程序运行后的该文件中的内容如下所示 ) 151055456061 示例程序的类图 示例程序-抽象外观类在标准的外观模式结构中,如果需要增加,删除或更换与外观类交互的子类,必须修改外观类或客户端的代码,这将违背开闭原则,因此可以通过引入抽象外观类对系统进行改进,即客户端针对抽象外观类进行编程,在运行时再确定具体的外观类. ( 下述示例程序是在上述示例程序基础上进行改进的 ) FileReader类 : 文件读取类, 充当子系统类 12345678910111213141516171819202122232425262728package pers.huangyuhui.facade_pattern.facade_pattern_2;import java.io.FileInputStream;import java.io.IOException;/** * @project: design-patterns * @description: 文件读取类, 充当子系统类 * @author: 黄宇辉 * @date: 9/12/2019-9:36 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileReader &#123; public String read(String path) &#123; var stringBuffer = new StringBuilder(); try (var fileInputStream = new FileInputStream(path)) &#123; var data = 0; while ((data = fileInputStream.read()) != -1) &#123; stringBuffer.append((char) data); //char &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return stringBuffer.toString(); &#125;&#125; FileWriter类 : 文件保存类, 充当子类系统类 1234567891011121314151617181920212223package pers.huangyuhui.facade_pattern.facade_pattern_2;import java.io.FileOutputStream;import java.io.IOException;/** * @project: design-patterns * @description: 文件保存类, 充当子类系统类 * @author: 黄宇辉 * @date: 9/12/2019-9:56 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileWriter &#123; public void write(String encryptStr, String path) &#123; try (var fileOutputStream = new FileOutputStream(path)) &#123; fileOutputStream.write(encryptStr.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; CipherMachine类 : 数据加密类(求模运算), 充当子系统类 123456789101112131415161718192021package pers.huangyuhui.facade_pattern.facade_pattern_2;/** * @project: design-patterns * @description: 数据加密类(求模运算), 充当子系统类 * @author: 黄宇辉 * @date: 9/12/2019-9:42 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class CipherMachine &#123; public String encrypt(String text) &#123; var result = new StringBuilder(); for (int i = 0; i &lt; text.length(); i++) &#123; var s = String.valueOf(text.charAt(i) % 7); result.append(s); &#125; return result.toString(); &#125;&#125; NewCipherMachine类 : 数据加密类(移位运算), 充当子系统类 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.facade_pattern.facade_pattern_2;/** * @project: design-patterns * @description: 数据加密类(移位运算), 充当子系统类 * @author: 黄宇辉 * @date: 9/14/2019-6:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class NewCipherMachine &#123; public String encrypt(String text) &#123; var result = \"\"; var key = 10; //设置密钥,移位数为10 for (int i = 0; i &lt; text.length(); i++) &#123; var c = text.charAt(i); //小写字母移位 if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; c += key % 26; if (c &gt; 'z') &#123; c -= 26; &#125; if (c &lt; 'a') &#123; c += 26; &#125; &#125; //大写字母移位 if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &#123; c += key % 26; if (c &gt; 'Z') &#123; c -= 26; &#125; if (c &lt; 'A') &#123; c += 26; &#125; result += c; &#125; &#125; return result; &#125;&#125; AbstractEncryptFacade抽象类 : 明文加密抽象类, 充当抽象外观类 12345678910111213package pers.huangyuhui.facade_pattern.facade_pattern_2;/** * @project: design-patterns * @description: 明文加密抽象类, 充当抽象外观类 * @author: 黄宇辉 * @date: 9/14/2019-6:54 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class AbstractEncryptFacade &#123; public abstract void fileEncrypt(String fromPath, String toPath);&#125; EncryptFacade类 : 加密外观类, 充当外观类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.facade_pattern.facade_pattern_2;/** * @project: design-patterns * @description: 加密外观类, 充当外观类 * @author: 黄宇辉 * @date: 9/12/2019-9:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class EncryptFacade extends AbstractEncryptFacade &#123; //维持对子系统对象的引用 private FileReader fileReader; private CipherMachine cipherMachine; private FileWriter fileWriter; public EncryptFacade() &#123; fileReader = new FileReader(); cipherMachine = new CipherMachine(); fileWriter = new FileWriter(); &#125; //调用子系统对象的业务方法 public void fileEncrypt(String fromPath, String toPath) &#123; var text = fileReader.read(fromPath); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 读取文件[ \" + fromPath + \" ]中的明文数据 : \" + text); var encryptStr = cipherMachine.encrypt(text); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 明文数据加密后的结果 : \" + encryptStr); fileWriter.write(encryptStr, toPath); &#125;&#125; NewEncryptFacade类 : 加密外观类, 充当外观类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.facade_pattern.facade_pattern_2;/** * @project: design-patterns * @description: 加密外观类, 充当外观类 * @author: 黄宇辉 * @date: 9/14/2019-6:57 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class NewEncryptFacade extends AbstractEncryptFacade &#123; private FileReader reader; private NewCipherMachine newCipherMachine; private FileWriter writer; public NewEncryptFacade() &#123; reader = new FileReader(); newCipherMachine = new NewCipherMachine(); writer = new FileWriter(); &#125; //调用子系统对象的业务方法 @Override public void fileEncrypt(String fromPath, String toPath) &#123; String text = reader.read(fromPath); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 读取文件[ \" + fromPath + \" ]中的明文数据 : \" + text); String encryptStr = newCipherMachine.encrypt(text); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 明文数据加密后的结果 : \" + encryptStr); writer.write(encryptStr, toPath); &#125;&#125; Client类 : 客户端测试类 123456789101112131415161718192021222324package pers.huangyuhui.facade_pattern.facade_pattern_2;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/14/2019-6:05 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; private static final String FROM_PATH = \"src\\\\main\\\\java\\\\pers\\\\huangyuhui\\\\facade_pattern\\\\facade_pattern_2\\\\from.txt\"; private static final String TO_PATH = \"src\\\\main\\\\java\\\\pers\\\\huangyuhui\\\\facade_pattern\\\\facade_pattern_2\\\\to.txt\"; public static void main(String[] args) &#123; //取模运算加密 AbstractEncryptFacade encryptFacade = new EncryptFacade(); encryptFacade.fileEncrypt(FROM_PATH, TO_PATH); //移位运算加密 AbstractEncryptFacade newEncryptFacade = new NewEncryptFacade(); newEncryptFacade.fileEncrypt(FROM_PATH, TO_PATH); &#125;&#125; from.txt : 源文件,用于存储待加密的数据 1YUbuntu0109 to.txt : 目标文件,用于存储加密后的数据( 程序运行后的该文件中的内容如下所示 ) 1IE 程序运行结果如下所示 : 1234&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 读取文件[ src\\main\\java\\pers\\huangyuhui\\facade_pattern\\facade_pattern_2\\from.txt ]中的明文数据 : YUbuntu0109&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 明文数据加密后的结果 : 51055456061&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 读取文件[ src\\main\\java\\pers\\huangyuhui\\facade_pattern\\facade_pattern_2\\from.txt ]中的明文数据 : YUbuntu0109&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; : 明文数据加密后的结果 : IE 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Composite Pattern","slug":"Java设计模式之Composite-Pattern","date":"2019-09-11T04:11:29.000Z","updated":"2019-09-13T13:35:28.789Z","comments":true,"path":"2019/09/11/Java设计模式之Composite-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/11/Java设计模式之Composite-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Composite Pattern概述组合设计模式 : 组合多个对象形成树形结构以表示具有部分-整体关系的层次结构. 组合模式让客户端可以统一对待单个对象和组合对象. (Composite Pattern : Compose objects into tree structures to pepresent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uninformly.) 扩 : 组合模式又称部分-整体( Part-Whole )模式,属于对象结构型模式,它将对象组织到树形结构中,可以用来描述整体与部分的关系 组合模式中的角色 Component( 抽象构件 ) : 它可以是接口或抽象类,为叶子构件和容器构件对象声明接口,在该角色中可以包含所有子类共有行为的声明和实现. 在抽象构件中定义了访问及管理它的子构件的方法,如增加,删除,获取子构件等. Leaf( 叶子构件 ) : 它在组合结构中表示叶子结点对象,叶子节点没有子结点,它实现了在抽象构件中定义的行为. 对于那些访问及管理子构件的方法,可以通过抛出异常,提示错误等方式进行处理. Composite( 容器构件 ) : 它在组合结构中表示容器节点对象,容器结点包含子结点,其子结点可以是叶子结点,也可以是容器结点,它提供了一个集合用于存储子结点,实现了在抽象构件中定义的行为,包括哪些访问及管理子构件的方法,在其业务方法中可以递归调用其自子结点的业务方法. 扩 : 组合模式的关键在于定义了一个抽象构件类,它既可以代表叶子,又可以代表容器,客户端针对该抽象构件类进行编程,无须知道它到底表示的叶子还是容器,可以对其进行统一处理. 同时容器对象与抽象构件类之间还建立一个聚合关联关系,在容器对象中既可以包含叶子,又可以包含容器,以此实现递归组合,形成一个树形结构. 适用环境Java SE中的 AWT 和 Swing 包的设计就基于组合模式,在这些界面包中为用户提供了大量的容器构件,如 Container( 容器构件 ) 和成员构件,如 Checkbox, Button, TextComponent( 一些叶子构件 )等,其都继承自 Componet 抽象类( 抽象构件 ) 示例程序1下面是一个使用组合设计模式的简单示例程序,这段示例程序的功能为列出文件夹及其中文件的名称及大小~ Entry抽象类 : 表示目录条目的抽象类, 充当Component角色 123456789101112131415161718192021222324252627282930package pers.huangyuhui.composite_pattern.composite_pattern_1;/** * @project: design-patterns * @description: 表示目录条目的抽象类, 充当Component角色 * @author: 黄宇辉 * @date: 9/11/2019-12:16 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class Entry &#123; public abstract String getName(); public abstract int getSize(); public Entry add(Entry entry) throws FileTreatMentException &#123; throw new FileTreatMentException(); &#125; public void printList() &#123; printList(\"\"); &#125; protected abstract void printList(String prefix); public String toString() &#123; return getName() + \" (\" + getSize() + \")\"; &#125;&#125; File类 : 表示文件的类, 充当Leaf角色 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.composite_pattern.composite_pattern_1;/** * @project: design-patterns * @description: 表示文件的类, 充当Leaf角色 * @author: 黄宇辉 * @date: 9/11/2019-12:22 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class File extends Entry &#123; private String name; private int size; public File(String name, int size) &#123; this.name = name; this.size = size; &#125; @Override public String getName() &#123; return name; &#125; @Override public int getSize() &#123; return size; &#125; @Override protected void printList(String prefix) &#123; System.out.println(prefix + \"/\" + this.toString()); &#125;&#125; Directory类 : 表示文件夹的类, 充当Composite角色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pers.huangyuhui.composite_pattern.composite_pattern_1;import java.util.ArrayList;/** * @project: design-patterns * @description: 表示文件夹的类, 充当Composite角色 * @author: 黄宇辉 * @date: 9/11/2019-12:25 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Directory extends Entry &#123; private String name; private ArrayList&lt;Entry&gt; directory = new ArrayList&lt;&gt;(); public Directory(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public int getSize() &#123; var size = 0; for (Entry entry : directory) &#123; size += entry.getSize(); &#125; return size; &#125; @Override public Entry add(Entry entry) &#123; directory.add(entry); return this; &#125; @Override protected void printList(String prefix) &#123; System.out.println(prefix + \"/\" + this.toString()); for (Entry entry : directory) &#123; entry.printList(prefix + \"/\" + name); &#125; &#125;&#125; FileTreatMentException类 : 自定义异常类 1234567891011121314151617181920package pers.huangyuhui.composite_pattern.composite_pattern_1;/** * @project: design-patterns * @description: 自定义异常类 * @author: 黄宇辉 * @date: 9/11/2019-12:19 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileTreatMentException extends RuntimeException &#123; public FileTreatMentException() &#123; &#125; public FileTreatMentException(String msg) &#123; super(msg); &#125;&#125; Client类 : 客户端测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.composite_pattern.composite_pattern_1;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/11/2019-12:36 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; try &#123; System.out.println(\"------ Making Root Entries ------\"); Directory rootdir = new Directory(\"root\"); Directory bindir = new Directory(\"bin\"); Directory temdir = new Directory(\"tmp\"); Directory usrdir = new Directory(\"usr\"); rootdir.add(bindir); rootdir.add(temdir); rootdir.add(usrdir); bindir.add(new File(\"demo1.class\", 10000)); bindir.add(new File(\"demo2.class\", 20000)); rootdir.printList(); System.out.println(\"\\n\" + \"------ Making User Entries ------\"); Directory demoDir1 = new Directory(\"demoDir1\"); Directory demoDir2 = new Directory(\"demoDir2\"); Directory demoDir3 = new Directory(\"demoDir3\"); usrdir.add(demoDir1); usrdir.add(demoDir2); usrdir.add(demoDir3); demoDir1.add(new File(\"demo.html\", 100)); demoDir1.add(new File(\"demo.java\", 200)); demoDir2.add(new File(\"demo.txt\", 300)); demoDir3.add(new File(\"demo.doc\", 400)); demoDir3.add(new File(\"demo.mail\", 500)); rootdir.printList(); &#125; catch (FileTreatMentException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序运行结果如下所示 : 1234567891011121314151617181920212223------ Making Root Entries ------/root (30000)/root/bin (30000)/root/bin/demo1.class (10000)/root/bin/demo2.class (20000)/root/tmp (0)/root/usr (0)------ Making User Entries ------/root (31500)/root/bin (30000)/root/bin/demo1.class (10000)/root/bin/demo2.class (20000)/root/tmp (0)/root/usr (1500)/root/usr/demoDir1 (300)/root/usr/demoDir1/demo.html (100)/root/usr/demoDir1/demo.java (200)/root/usr/demoDir2 (300)/root/usr/demoDir2/demo.txt (300)/root/usr/demoDir3 (900)/root/usr/demoDir3/demo.doc (400)/root/usr/demoDir3/demo.mail (500) 示例程序的类图 示例程序2下面是一个使用组合设计模式的简单示例程序 : 写一个模拟杀毒( Antivirus )程序,该程序既可以对某个文件夹( Folder )杀毒,也可以对某个指定的文件( File )杀毒,而且该杀毒程序还可以根据各类文件的特点为不同类型(文本文件,图像文件,音频文件等)的文件提供不同的杀毒方式. AbstractFile抽象类 : 抽象文件类, 充当抽象构件类 123456789101112131415161718192021package pers.huangyuhui.composite_pattern.composite_pattern_2;/** * @project: design-patterns * @description: 抽象文件类, 充当抽象构件类 * @author: 黄宇辉 * @date: 9/11/2019-1:19 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class AbstractFile &#123; public abstract String getName(); public abstract void killVirus(); public void add(AbstractFile file) &#123; throw new FileTreatMentException(); &#125;&#125; TextFile类 : 文本文件类, 充当叶子构件类 12345678910111213141516171819202122232425262728package pers.huangyuhui.composite_pattern.composite_pattern_2;/** * @project: design-patterns * @description: 文本文件类, 充当叶子构件类 * @author: 黄宇辉 * @date: 9/11/2019-1:31 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class TextFile extends AbstractFile &#123; private String name; public TextFile(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public void killVirus() &#123; System.out.println(\"——————&gt; 对文本文件[ \" + name + \" ]进行杀毒\"); &#125;&#125; ImageFile类 : 图像文件类, 充当叶子构件类 12345678910111213141516171819202122232425262728package pers.huangyuhui.composite_pattern.composite_pattern_2;/** * @project: design-patterns * @description: 图像文件类, 充当叶子构件类 * @author: 黄宇辉 * @date: 9/11/2019-1:27 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ImageFile extends AbstractFile &#123; private String name; public ImageFile(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public void killVirus() &#123; System.out.println(\"——————&gt; 对图像文件[ \" + name + \" ]进行杀毒\"); &#125;&#125; Folder类 : 文件夹类, 充当容器构件类 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.composite_pattern.composite_pattern_2;import java.util.ArrayList;/** * @project: design-patterns * @description: 文件夹类, 充当容器构件类 * @author: 黄宇辉 * @date: 9/11/2019-1:38 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Folder extends AbstractFile &#123; private String name; private ArrayList&lt;AbstractFile&gt; directory = new ArrayList&lt;&gt;(); public Folder(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public void add(AbstractFile file) &#123; directory.add(file); &#125; @Override public void killVirus() &#123; System.out.println(\"======&gt; 对文件夹[ \" + name + \" ]进行杀毒\"); //递归调用成员构件的killVirus方法 for (AbstractFile abstractFile : directory) &#123; abstractFile.killVirus(); &#125; &#125;&#125; FileTreatMentException类 : 自定义异常类 1234567891011121314151617181920package pers.huangyuhui.composite_pattern.composite_pattern_2;/** * @project: design-patterns * @description: 自定义异常类 * @author: 黄宇辉 * @date: 9/11/2019-12:19 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileTreatMentException extends RuntimeException &#123; public FileTreatMentException() &#123; &#125; public FileTreatMentException(String msg) &#123; super(msg); &#125;&#125; Client类 : 客户端测试类 1234567891011121314151617181920212223242526package pers.huangyuhui.composite_pattern.composite_pattern_2;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/11/2019-1:44 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; AbstractFile folder = new Folder(\"my-folder\"); AbstractFile textFolder = new Folder(\"text-folder\"); AbstractFile imageFolder = new Folder(\"image-folder\"); AbstractFile file = new TextFile(\"demo.text\"); AbstractFile image = new ImageFile(\"demo.jpg\"); textFolder.add(file); imageFolder.add(image); folder.add(textFolder); folder.add(imageFolder); folder.killVirus(); &#125;&#125; 示例程序的运行结果如下所示 : 12345======&gt; 对文件夹[ my-folder ]进行杀毒======&gt; 对文件夹[ text-folder ]进行杀毒——————&gt; 对文本文件[ demo.text ]进行杀毒======&gt; 对文件夹[ image-folder ]进行杀毒——————&gt; 对图像文件[ demo.jpg ]进行杀毒 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java继承与委托中的一致性","slug":"Java继承与委托中的一致性","date":"2019-09-09T07:17:00.000Z","updated":"2019-09-11T13:12:23.558Z","comments":true,"path":"2019/09/09/Java继承与委托中的一致性/","link":"","permalink":"http://yoursite.com/2019/09/09/Java继承与委托中的一致性/","excerpt":"","text":"学习笔记 : Decorator Pattern的延伸阅读-继承与委托中的一致性继承-父类和子类的一致性父类和子类具有一致性,示例代码如下所示 :12345678910111213class Parent &#123; ··· void parentMethod()&#123; ··· &#125;&#125;class Child extends Parent &#123; ··· void childMethod()&#123; ··· &#125;&#125; 此时,Child类的实例可以被保存在 Parent 类型中的变量中,所以可以调用从 Parent 类中继承的方法,也就是说,可以像操作 Parent 类的实例一样操作 Child 类的实例. 如下是将子类当做父类看待的示例代码~12Parent obj = new Child();obj.parentMethod(); 相反,如果想将父类当做子类一样操作,则需要先进行类型转换哟~12Parent obj = new Child();((Child)obj).childMethod(); 委托-自己和被委托对象的一致性使用委托让接口具有透明性,自己和被委托对象具有一致性 : 如下示例程序, Rose 和 Violet 都有相同的 method 方法, Rose 将 method 方法的处理委托给了 Violet12345678910111213141516/* or interface */abstract class Flower &#123; abstract void method();&#125;class Rose extends Flower &#123; Violet obj = ··· void method() &#123; obj.method(); &#125;&#125;class Violet extends Flower &#123; void method() &#123; ··· &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Decorator Pattern","slug":"Java设计模式之Decorator-Pattern","date":"2019-09-08T13:47:30.000Z","updated":"2019-09-09T13:31:25.773Z","comments":true,"path":"2019/09/08/Java设计模式之Decorator-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/08/Java设计模式之Decorator-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Decorator Pattern概述装饰设计模式( 对象结构型模式 )是一种用于替代继承的技术,它通过一种无须定义子类的方式来给对象动态增加职责,使用对象之间的关联关系取代类之间的继承关系. 装饰设计模式的定位为 : 动态地给一个对象增加一些额外的职责. 就扩展而言,装饰模式提供了一种比使用子类更加灵活的替代方案. ( Decorator Pattern : Attach additonal responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality ) 装饰设计模式中的角色 Component ( 抽象构件 ) : 它是具体构件和抽象装饰类的共同父类,声明了在具体构件中实现的业务方法,它的引入可以使客户端以一致的方式处理未被装饰的对象及装饰之后的对象,实现客户端的透明操作. ConcreteComponent ( 具体构件 ) : 它是抽象构件类的子类,用于定义具体的构件对象,实现了在抽象构件中声明的方法,装饰类可以给它增加额外的职责( 方法 ) Decorator ( 抽象装饰类 ) : 它也是抽象构件类的子类,用于给具体构件增加职责,但是具体职责在其子类中实现. 它维护一个指向抽象构件的引用,通过该引用可以调用装饰之前构件对象的方法,并通过子类扩展该方法,继而达到装饰的目的. ConcreteDecorator ( 具体装饰类 ) : 它是抽象装饰类的子类,负责向构件添加新的职责. 每一个具体装饰类都定义了一些新的行为,它可以调用在抽象装饰类中定义的方法,并可以增加新的方法用于扩展对象的行为. 示例程序-透明装饰模式下面是一个使用了装饰设计模式的简单示例程序,其示例说明为 : 使用面向对象技术开发了一套图形界面构件库,该构件库提供了大量的基本结构,如窗体,文本框,列表框等,由于在使用时用户经常要求定制一些特殊的显示效果,如带滚动条的窗体,或带黑色边框的文本框等. 因此经常需要对该构件库进行扩展以增强其功能,既而可以使用装饰设计模式来设计该界面构件库哟~ Component接口 : 抽象界面构件类, 充当抽象构件类 1234567891011121314package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 抽象界面构件类, 充当抽象构件类 * @author: 黄宇辉 * @date: 9/9/2019-2:47 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class Component &#123; public abstract void display();&#125; Window类 : 窗体类, 充当具体构件类 1234567891011121314151617package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 窗体类, 充当具体构件类 * @author: 黄宇辉 * @date: 9/9/2019-2:48 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Window extends Component &#123; @Override public void display() &#123; System.out.println(\"显示窗体 !\"); &#125;&#125; TextBox类 : 文本框类, 充当具体构件类 12345678910111213141516package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 文本框类, 充当具体构件类 * @author: 黄宇辉 * @date: 9/9/2019-2:50 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class TextBox extends Component &#123; @Override public void display() &#123; System.out.println(\"显示文本框 !\"); &#125;&#125; ListBox类 : 列表框类, 充当具体构件类 1234567891011121314151617package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 列表框类, 充当具体构件类 * @author: 黄宇辉 * @date: 9/9/2019-2:51 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ListBox extends Component &#123; @Override public void display() &#123; System.out.println(\"显示列表框 !\"); &#125;&#125; ComponentDecorator类 : 构件装饰类, 充当抽象装饰类 12345678910111213141516171819202122232425package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 构件装饰类, 充当抽象装饰类 * @author: 黄宇辉 * @date: 9/9/2019-2:52 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ComponentDecorator extends Component &#123; //维持对抽象构件类型对象的引用 private Component component; //注入抽象构件类型的对象 public ComponentDecorator(Component component) &#123; this.component = component; &#125; @Override public void display() &#123; component.display(); &#125;&#125; ScrollBarDecorator类 : 滚动条装饰类, 充当具体装饰类 1234567891011121314151617181920212223242526package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 滚动条装饰类, 充当具体装饰类 * @author: 黄宇辉 * @date: 9/9/2019-2:54 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ScrollBarDecorator extends ComponentDecorator &#123; public ScrollBarDecorator(Component component) &#123; super(component); &#125; @Override public void display() &#123; this.setScrollBar(); super.display(); &#125; private void setScrollBar() &#123; System.out.println(\"为构件添加滚动条 !\"); &#125;&#125; BlackBorderDecorator类 : 黑色边框装饰类, 充当具体装饰类 1234567891011121314151617181920212223242526package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 黑色边框装饰类, 充当具体装饰类 * @author: 黄宇辉 * @date: 9/9/2019-2:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BlackBorderDecorator extends ComponentDecorator &#123; public BlackBorderDecorator(Component component) &#123; super(component); &#125; @Override public void display() &#123; this.setBlackBorder(); super.display(); &#125; private void setBlackBorder() &#123; System.out.println(\"为构件添加黑色边框 !\"); &#125;&#125; Client类 : 客户端测试类 12345678910111213141516171819202122package pers.huangyuhui.decorator_pattern;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/9/2019-3:03 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; Component component = new Window(); component.display(); System.out.println(\"------------------\"); Component component2 = new ScrollBarDecorator(component); component2.display(); &#125;&#125; 示例程序的类图 示例程序-半透明装饰模式暂略 · · ·","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Abstract Factory Pattern","slug":"Java设计模式之Abstract-Factory-Pattern","date":"2019-09-07T13:56:25.000Z","updated":"2019-09-24T13:55:17.164Z","comments":true,"path":"2019/09/07/Java设计模式之Abstract-Factory-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/07/Java设计模式之Abstract-Factory-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Abstract Factory Pattern概述工厂方法模式通过引入工厂等级结构解决了简单工厂模式中工厂类职责太重的问题,但由于工厂方法模式中每个具体工厂只有一个或一组重载的工厂方法,既只能生产一种产品,可能会导致系统中存在大量的工厂类,势必会增加系统的开销. 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式. 抽象工厂模式与工厂方法模式的最大区别在于 : 工厂方法模式针对的是一个产品等级结构,而抽象工厂模式需要面对多个产品等级结构,一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建. 当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时,抽象工厂模式比工厂方法模式更加简单,更有效率~ 抽象工厂模式的定义为 : 提供一个创建一系列相关或相互依赖对象的接口,而无须指定它们具体的类( Abstract Factory Pattern : Provide an interface for creating families of related or dependent objects without sprcifying their concrete classes. ) 抽象工厂模式中的角色 AbstractFactory( 抽象工厂 ) : 它声明了一组用于创建一族产品的方法,每一个方法对应一种产品. ConcreteFactory( 具体工厂 ) : 它实现了在抽象工厂中声明的创建产品的方法,生成一组具体产品,这些产品构成了一个产品族,每一个产品都位于某个产品等级结构中 AbstractProduct( 抽象产品 ) : 它为每种产品声明接口,在抽象产品中声明了产品所具有的业务方法. ConcreteProduct( 具体产品 ) : 它定义具体工厂生产的具体产品对象,实现抽象产品接口中声明的业务方法. 示例程序下面是一个使用了抽象工厂模式的简单示例程序,其程序功能( 模拟 )描述为 : 开发一套基于 Java 桌面软件的界面皮肤库,用户可以自由切换界面皮肤,例如有 Spring 与 Summer 风格等皮肤~ Button接口 : 接口按钮, 充当抽象产品 12345678910111213package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: 接口按钮, 充当抽象产品 * @author: 黄宇辉 * @date: 9/7/2019-5:18 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Button &#123; void display();&#125; SpringButton类 : Spring风格皮肤的按钮类, 充当具体产品 12345678910111213141516package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Spring风格皮肤的按钮类, 充当具体产品 * @author: 黄宇辉 * @date: 9/7/2019-5:19 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SpringButton implements Button &#123; @Override public void display() &#123; System.out.println(\"spring theme———&gt;this is button\"); &#125;&#125; SummerButton类 : Summer风格皮肤的按钮类, 充当具体产品 1234567891011121314151617package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Summer风格皮肤的按钮类, 充当具体产品 * @author: 黄宇辉 * @date: 9/7/2019-5:20 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SummerButton implements Button &#123; @Override public void display() &#123; System.out.println(\"Summer theme———&gt;button\"); &#125;&#125; TextField接口 : 文本框接口, 充当抽象产品 12345678910111213package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: 文本框接口, 充当抽象产品 * @author: 黄宇辉 * @date: 9/7/2019-5:22 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface TextField &#123; void display();&#125; SpringTextField类 : Spring风格皮肤的文本框类, 充当具体产品 1234567891011121314151617package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Spring风格皮肤的文本框类, 充当具体产品 * @author: 黄宇辉 * @date: 9/7/2019-5:22 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SpringTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"Spring theme———&gt;this is text field\"); &#125;&#125; SummerTextField类 : Summer风格皮肤的文本框类, 充当具体产品 1234567891011121314151617package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Summer风格皮肤的文本框类, 充当具体产品 * @author: 黄宇辉 * @date: 9/7/2019-5:23 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SummerTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"Summer theme———&gt;this is text field\"); &#125;&#125; ComboBob类 : 组合框接口, 充当抽象产品 12345678910111213package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: 组合框接口, 充当抽象产品 * @author: 黄宇辉 * @date: 9/7/2019-5:24 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface ComboBox &#123; void display();&#125; SpringComboBox类 : Spring风格皮肤的组合框类, 充当具体产品 12345678910111213141516package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Spring风格皮肤的组合框类, 充当具体产品 * @author: 黄宇辉 * @date: 9/7/2019-5:25 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SpringComboBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"Spring theme———&gt;this is comboxBox\"); &#125;&#125; SummerComboBox类 : Summer风格皮肤的组合框类, 充当具体产品 12345678910111213141516package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Summer风格皮肤的组合框类, 充当具体产品 * @author: 黄宇辉 * @date: 9/7/2019-5:25 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SummerComboBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"Summer theme———&gt;this is comboBox\"); &#125;&#125; SkinFactory接口 : 界面皮肤工厂接口, 充当抽象工厂 1234567891011121314151617package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: 界面皮肤工厂接口, 充当抽象工厂 * @author: 黄宇辉 * @date: 9/7/2019-5:26 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface SkinFactory &#123; Button createButton(); TextField createTextField(); ComboBox createComboBox();&#125; SpringSkinFactory类 : Spring皮肤风格的工厂类, 充当具体工厂 1234567891011121314151617181920212223242526package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Spring皮肤风格的工厂类, 充当具体工厂 * @author: 黄宇辉 * @date: 9/7/2019-5:29 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SpringSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; return new SpringButton(); &#125; @Override public TextField createTextField() &#123; return new SpringTextField(); &#125; @Override public ComboBox createComboBox() &#123; return new SpringComboBox(); &#125;&#125; SummerSkinFactory类 : Summer风格皮肤的工厂类, 充当具体工厂 1234567891011121314151617181920212223242526package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: Summer风格皮肤的工厂类, 充当具体工厂 * @author: 黄宇辉 * @date: 9/7/2019-5:33 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SummerSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; return new SummerButton(); &#125; @Override public TextField createTextField() &#123; return new SummerTextField(); &#125; @Override public ComboBox createComboBox() &#123; return new SummerComboBox(); &#125;&#125; Client类 : 客户端测试类 123456789101112131415161718192021222324252627package pers.huangyuhui.abstract_factory_pattern.abstract_factory;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/7/2019-5:30 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; SkinFactory skinFactory = new SpringSkinFactory(); skinFactory.createButton().display(); skinFactory.createTextField().display(); skinFactory.createComboBox().display(); System.out.println(\"———————————————————\"); SkinFactory skinFactory2 = new SummerSkinFactory(); skinFactory2.createButton().display(); skinFactory2.createTextField().display(); skinFactory2.createComboBox().display(); &#125;&#125; 程序运行结果如下所示 : 1234567spring theme———&gt;this is buttonSpring theme———&gt;this is text fieldSpring theme———&gt;this is comboxBox———————————————————Summer theme———&gt;buttonSummer theme———&gt;this is text fieldSummer theme———&gt;this is comboBox 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Singleton Pattern","slug":"Java设计模式之Singleton-Pattern","date":"2019-09-06T05:32:05.000Z","updated":"2019-09-06T13:40:37.893Z","comments":true,"path":"2019/09/06/Java设计模式之Singleton-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/06/Java设计模式之Singleton-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Singleton Pattern概念单例设计模式 : 确保一个类只能有一个实例,并提供一个全局访问点来访问这个实例. (Singleton Pattern : Ensure a class has only one intance,and provide a global point of access to it. ). 单例设计模式是一种对象创建型模式,其主要有三个要点 : 某个类只能有一个实例 必须自行创建这个实例 必须自行向系统提供这个实例 示例程序-饿汉式单例饿汉式单例类( Eager Singleton )是最简单的单例类,既类被加载时静态变量 instance 就会被初始化,程序示例如下所示 :12345678910111213141516171819202122package pers.huangyuhui.singleton_pattern.eager_singleton;/** * @project: design-patterns * @description: 单例模式-饿汉式单例类 * @author: 黄宇辉 * @date: 9/6/2019-10:44 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class EagerSingleton &#123; private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125;&#125; 注 : 从资源利用效率的角度来讲饿汉式单例不及懒汉式单例,而且系统加载时由于需要创建饿汉式单例对象,加载时间可能比较长. 程序示例-懒汉式单例与饿汉式单例不同的是,懒汉式单例类( Lazy Singleton )在第一次被引用时才会将自己实例化,当单例类被加载时并不会将自己实例化, 示例程序如下所示 :123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.singleton_pattern.lazy_singleton;/** * @project: design-patterns * @description: 单例模式-懒汉式单例类 * @author: 黄宇辉 * @date: 9/6/2019-10:50 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LazySingleton &#123; //被volatile修饰的成员变量可以确保多个线程都能够正确处理 private volatile static LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; //第一重判断 if (instance == null) &#123; //锁定代码块:确保任何时刻只有一个线程可执行此代码块 synchronized (LazySingleton.class) &#123; //第二重判断:防止产生多个单例对象 if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 注 : 由于volatile关键字会屏蔽Java虚拟机所做的一切代码优化,继而可能会导致系统的运行效率降低,因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方法哟~ 示例程序-内部类实现单例饿汉式单例不能实现延迟加载,不管将来用不用始终占据内存. 懒汉式单例类线程安全控制繁琐,而且性能受影响. 为了克服这些问题,在Java语言中可以通过使用 Initialization on Demand Holder( IoDH )技术来实现单例模式,示例程序如下所示 :12345678910111213141516171819202122232425package pers.huangyuhui.singleton_pattern.IoDH_singleton;/** * @project: design-patterns * @description: 单例模式-内部类实现单例类 * @author: 黄宇辉 * @date: 9/6/2019-11:11 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Singleton &#123; private Singleton() &#123; &#125; //静态内部类 public static class HolderClass &#123; private final static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return HolderClass.instance; &#125;&#125; 注 : 通过使用IoDH既可以实现延迟加载,又可以保证线程安全,不影响系统性能,既其为一种最好的Java语言单例模式实现方式,其缺点为很多面向对象语言并不支持IoDH哟~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Simple Factory Pattern","slug":"Java设计模式之Simple-Factory-Pattern","date":"2019-09-06T01:35:53.000Z","updated":"2019-09-25T14:20:43.075Z","comments":true,"path":"2019/09/06/Java设计模式之Simple-Factory-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/06/Java设计模式之Simple-Factory-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Simple Factory Pattern概述简单工厂模式( Simple Factory Pattern) : 定义一个工厂类,他可以根据参数的不同返回不同类的实例,被创建的实例通常都具有共同的父类. 其是一种创建型模式,需注意 : 简单工厂模式并不属于23种经典设计模式,但通常将它作为学习其他工厂模式的基础. 简单工厂模式中的角色 Factory( 工厂角色 ) : 工厂角色既工厂类,它是简单工厂模式的核心,负责实现创建所有产品实例的内部结构. 工厂类可以被外界访问直接调用,创建所需的产品对象. 在工厂类中提供了静态的工厂方法,其返回类型为抽象产品类型. Product( 抽象产品角色 ) : 它是工厂类创建的所有对象的父类,封装了各种对象的公有方法,它的引入提高了系统的灵活性. ConcreteProduct( 具体产品角色 ) : 它是简单工厂模式的创建目标,所有被创建的对象都充当这个角色的某个具体类的实例. 每一个具体产品角色都继承了抽象产品角色,需要实现在抽象产品中的抽象方法. 程序示例下面是一个使用简单工厂模式的简单程序示例,其功能( 模拟 )描述 : 通过设置不同的参数即可得到不同类型的图表,而且可以较为方便地对图表进行扩展,以便能够在将来增加一些新类型的图表. Chart接口 : 抽象图表接口, 充当抽象产品类 1234567891011121314package pers.huangyuhui.simple_factory_pattern;/** * @project: design-patterns * @description: 抽象图表接口, 充当抽象产品类 * @author: 黄宇辉 * @date: 9/6/2019-9:36 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Chart &#123; void display();&#125; HistogramChart类 : 柱状图类, 充当具体产品类 123456789101112131415161718192021package pers.huangyuhui.simple_factory_pattern;/** * @project: design-patterns * @description: 柱状图类, 充当具体产品类 * @author: 黄宇辉 * @date: 9/6/2019-9:37 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class HistogramChart implements Chart &#123; public HistogramChart() &#123; System.out.println(\"创建柱状图\"); &#125; @Override public void display() &#123; System.out.println(\"显示柱状图\"); &#125;&#125; PieChart类 : 饼状图类, 充当具体产品类 123456789101112131415161718192021package pers.huangyuhui.simple_factory_pattern;/** * @project: design-patterns * @description: 饼状图类, 充当具体产品类 * @author: 黄宇辉 * @date: 9/6/2019-9:38 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class PieChart implements Chart &#123; public PieChart() &#123; System.out.println(\"创建饼状图\"); &#125; @Override public void display() &#123; System.out.println(\"显示饼状图\"); &#125;&#125; ChartFactory类 : 图表工厂类, 充当工厂类 123456789101112131415161718192021222324252627package pers.huangyuhui.simple_factory_pattern;/** * @project: design-patterns * @description: 图表工厂类, 充当工厂类 * @author: 黄宇辉 * @date: 9/6/2019-9:40 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ChartFactory &#123; //静态工厂方法 public static Chart getChar(String type) &#123; Chart chart = null; if (type.equalsIgnoreCase(\"histogram\")) &#123; chart = new HistogramChart(); System.out.println(\"初始化柱状图\"); &#125; else if (type.equalsIgnoreCase(\"pie\")) &#123; chart = new PieChart(); System.out.println(\"初始化饼状图\"); &#125; else &#123; System.out.println(\"error : not found the object for the specified parameter\"); &#125; return chart; &#125;&#125; Client类 : 客户端测试类 12345678910111213141516package pers.huangyuhui.simple_factory_pattern;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/6/2019-9:47 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; Chart histogram = ChartFactory.getChar(\"histogram\"); histogram.display(); &#125;&#125; 程序运行结果如下所示 : 123创建柱状图初始化柱状图显示柱状图 示例程序类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Factory Method模式","slug":"Java设计模式之Factory-Method-Pattern","date":"2019-09-05T01:23:20.000Z","updated":"2019-09-25T03:59:37.230Z","comments":true,"path":"2019/09/05/Java设计模式之Factory-Method-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/05/Java设计模式之Factory-Method-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Factory Method模式概述工厂方法模式 : 定义一个用于创建对象的接口,但是让子类决定将哪一个类实例化. 工厂方法模式让一个类的实例化延迟到其子类. ( Factory Method Pattern : Definde an interface for creating an object,but let subclasses decides which class to instantiate. Factory Method lets a class defer instantiation to sublclasses ) 工厂方法模式是简单工厂模式的延伸,它继承了简单工厂模式的优点,同时还弥补了简单工厂模式的缺陷,使其更好地符合开闭原则的要求. 工厂方法模式简称为工厂模式( Factory Pattern ),又可称为虚拟构造器模式( Virtual Constructor Pattern )或多态工厂模式( Polymorphic Factory Pattern ). 其为一种类创建型模式哟 ~ Factory Method模式中的角色 Product (抽象产品) : 它是定义产品的接口,是工厂方法模式所创建对象的超类型,也是产品对象的公共父类. ConcreteProduct (具体产品) : 它实现了抽象产品接口,某种类型的具体产品由专门的具体工厂创建,具体工厂和具体产品间一一对象. Factory (抽象工厂) : 在抽象工厂类中声明了工厂方法( Factory Method ),用于返回一个产品. 抽象工厂是工厂方法模式的核心,所有创建对象的工厂类都必须实现该接口. ConcreteFactory (具体工厂) : 它是抽象工厂类的子类,实现了在抽象工厂中声明的工厂方法,并由客户端调用,返回一个具体产品类的实例. 程序示例-简洁版下面是一个实现了Factory Method模式的简单示例程序,该示例程序的功能( 模拟 )是为了提高多种日志记录器之间切换的灵活性. Logger接口 : 日志记录器接口, 充当抽象产品角色 12345678910111213package pers.huangyuhui.factory_method.factory_method1;/** * @project: design-patterns * @description: 日志记录器接口, 充当抽象产品角色 * @author: 黄宇辉 * @date: 9/5/2019-9:26 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Logger &#123; void writeLog();&#125; DatabaseLogger类 : 数据库日志记录器, 充当具体产品角色 1234567891011121314151617package pers.huangyuhui.factory_method.factory_method1;/** * @project: design-pattern * @description: 数据库日志记录器, 充当具体产品角色 * @author: 黄宇辉 * @date: 9/5/2019-9:27 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DatabaseLogger implements Logger &#123; @Override public void writeLog() &#123; System.out.println(\"this is some logs about database\"); &#125;&#125; FileLogger类 : 文件日志记录器, 充当具体产品角色 1234567891011121314151617package pers.huangyuhui.factory_method.factory_method1;/** * @project: design-patterns * @description: 文件日志记录器, 充当具体产品角色 * @author: 黄宇辉 * @date: 9/5/2019-9:30 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileLogger implements Logger &#123; @Override public void writeLog() &#123; System.out.println(\"this is some logs about file\"); &#125;&#125; LoggerFactory类 : 日志记录器工厂接口, 充当抽象工厂角色 12345678910111213package pers.huangyuhui.factory_method.factory_method1;/** * @project: design-patterns * @description: 日志记录器工厂接口, 充当抽象工厂角色 * @author: 黄宇辉 * @date: 9/5/2019-9:33 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface LoggerFactory &#123; Logger createLogger();&#125; DatabaseLoggerFactory类 : 数据库日志记录器工厂类, 充当具体工厂角色 123456789101112131415161718package pers.huangyuhui.factory_method.factory_method1;/** * @project: design-patterns * @description: 数据库日志记录器工厂类, 充当具体工厂角色 * @author: 黄宇辉 * @date: 9/5/2019-9:36 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DatabaseLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; return new DatabaseLogger(); &#125;&#125; FileLoggerFactory类 : 文件日志记录器工厂类, 充当具体工厂角色 1234567891011121314151617package pers.huangyuhui.factory_method.factory_method1;/** * @project: design-patterns * @description: 文件日志记录器工厂类, 充当具体工厂角色 * @author: 黄宇辉 * @date: 9/5/2019-9:38 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FileLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; return new FileLogger(); &#125;&#125; Client类 : 客户端测试类 12345678910111213141516171819202122package pers.huangyuhui.factory_method.factory_method1;/** * @project: design-patterns * @description: 客户端测试类 * @author: 黄宇辉 * @date: 9/5/2019-9:39 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; LoggerFactory databaseLoggerFactory = new DatabaseLoggerFactory(); Logger databaseLogger = databaseLoggerFactory.createLogger(); databaseLogger.writeLog(); LoggerFactory fileLoggerFactory = new FileLoggerFactory(); Logger fileLogger = fileLoggerFactory.createLogger(); fileLogger.writeLog(); &#125;&#125; 程序运行结果如下所示 : 12this is some logs about databasethis is some logs about file 示例程序的类图 示例程序-工厂方法的重载下述示例代码文件同上述示例程序-简洁版,既只需修改部分代码即可哟~ LoggerFactory接口 : 日志记录器工厂接口, 充当抽象工厂角色(工厂方法的重载) 1234567891011121314151617package pers.huangyuhui.factory_method.factory_method2;/** * @project: design-patterns * @description: 日志记录器工厂接口, 充当抽象工厂角色(工厂方法的重载) * @author: 黄宇辉 * @date: 9/5/2019-9:33 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface LoggerFactory &#123; Logger createLogger(); Logger createLogger(String args); Logger createLogger(Object obj);&#125; DatabaseLoggerFactory类 : 数据库日志记录器工厂类, 充当具体工厂角色(工厂方法的重载) 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.factory_method.factory_method2;/** * @project: design-patterns * @description: 数据库日志记录器工厂类, 充当具体工厂角色(工厂方法的重载) * @author: 黄宇辉 * @date: 9/5/2019-9:36 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DatabaseLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; return new DatabaseLogger(); &#125; @Override public pers.huangyuhui.factory_method.factory_method2.Logger createLogger(String args) &#123; System.out.println(\"使用参数\" + args + \"作为连接字符串来连接数据库,代码省略 ···\"); Logger logger = new DatabaseLogger(); //初始化数据库日志记录器,代码省略 ··· return new DatabaseLogger(); &#125; @Override public pers.huangyuhui.factory_method.factory_method2.Logger createLogger(Object obj) &#123; System.out.println(\"使用封装在\" + obj.toString() + \"中的连接字符串来连接数据库,代码省略 ···\"); Logger logger = new DatabaseLogger(); //使用封装在参数obj中的数据来初始化数据库日志记录器，代码省略 ··· return logger; &#125;&#125; Client类 : 客户端测试类-(工厂方法的重载) 12345678910111213141516171819202122package pers.huangyuhui.factory_method.factory_method2;/** * @project: design-patterns * @description: 客户端测试类-(工厂方法的重载) * @author: 黄宇辉 * @date: 9/5/2019-9:39 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; LoggerFactory databaseLoggerFactory = new DatabaseLoggerFactory(); Logger databaseLogger = databaseLoggerFactory.createLogger(\"database-connection-info\"); databaseLogger.writeLog(); LoggerFactory fileLoggerFactory = new FileLoggerFactory(); Logger fileLogger = fileLoggerFactory.createLogger(); fileLogger.writeLog(); &#125;&#125; 程序运行结果如下所示 : 123使用参数database-connection-info作为连接字符串来连接数据库,代码省略 ···this is some logs about databasethis is some logs about file 示例程序的类图 示例程序-工厂方法的隐藏下述示例代码文件同上述示例程序-简洁版,既只需修改部分代码即可哟~ LoggerFactory类 : 日志记录器工厂接口, 充当抽象工厂角色(工厂方法的隐藏) 1234567891011121314151617181920package pers.huangyuhui.factory_method.factory_method3;/** * @project: design-patterns * @description: 日志记录器工厂接口, 充当抽象工厂角色(工厂方法的隐藏) * @author: 黄宇辉 * @date: 9/5/2019-9:33 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class LoggerFactory &#123; //工厂方法的隐藏 public void writeLog() &#123; Logger logger = this.createLogger(); logger.writeLog(); &#125; public abstract Logger createLogger();&#125; DatabaseLoggerFactory类 : 数据库日志记录器工厂类, 充当具体工厂角色 1public class DatabaseLoggerFactory extends LoggerFactory &#123; · · · · · · FileLoggerFactory类 : 文件日志记录器工厂类, 充当具体工厂角色 1public class FileLoggerFactory extends LoggerFactory &#123; · · · · · · Client类 : 客户端测试类(工厂方法的隐藏) 123456789101112131415161718192021222324package pers.huangyuhui.factory_method.factory_method3;/** * @project: design-patterns * @description: 客户端测试类(工厂方法的隐藏) * @author: 黄宇辉 * @date: 9/5/2019-9:39 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Client &#123; public static void main(String[] args) &#123; new DatabaseLoggerFactory().writeLog(); //LoggerFactory databaseLoggerFactory = new DatabaseLoggerFactory(); //Logger databaseLogger = databaseLoggerFactory.createLogger(); //databaseLogger.writeLog(); new FileLoggerFactory().writeLog(); //LoggerFactory fileLoggerFactory = new FileLoggerFactory(); //Logger fileLogger = fileLoggerFactory.createLogger(); //fileLogger.writeLog(); &#125;&#125; 程序运行结果如下所示 : 12this is some logs about databasethis is some logs about file 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"一个简单的JDBC基础模板","slug":"一个简单的JDBC基础模板","date":"2019-09-04T12:55:02.000Z","updated":"2019-09-04T13:20:14.215Z","comments":true,"path":"2019/09/04/一个简单的JDBC基础模板/","link":"","permalink":"http://yoursite.com/2019/09/04/一个简单的JDBC基础模板/","excerpt":"","text":"学习笔记 : 一个简单的JDBC基础模板最近在 GitHub 上又结识了一个小伙伴,看他最近在学习 JDBC 方面的知识,看到他所写的代码让我顿时回忆起自己初学编程的自己,所以想帮帮他,继而把前些日子写的 JDBC 基础模板整理了一下并给他提了一个 PR,详情请参考 : https://github.com/qinjiajuny/JDBCLearning/pull/4 tb_user : 用户信息数据表 1234567891011-- auto-generated definitioncreate table tb_user( id int auto_increment primary key, name varchar(10) null, age int null, gender char(2) null, password varchar(15) null, telephone varchar(11) null, birthday date null); db.properties : 数据库连接配置文件 12345# Database configuration information (Server version: 8.0.11 MySQL Community Server - GPL)Url=jdbc:mysql://localhost/database-name?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUserName=UserPassword=DriverName=com.mysql.cj.jdbc.Driver ConfigUtil.java : 读取数据库连接配置文件的工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.curd.utils;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @project: curd-demo * @description: 读取数据库配置文件的工具类 * @author: 黄宇辉 * @date: 8/22/2019-3:49 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */class ConfigUtil &#123; private ConfigUtil() &#123; &#125; private static Properties properties; // 读取数据库配置文件 private static InputStream inputStream = ConfigUtil.class.getResourceAsStream(\"/db.properties\"); static &#123; try &#123; properties = new Properties(); properties.load(inputStream); properties.getProperty(\"Url\"); properties.getProperty(\"UserName\"); properties.getProperty(\"UserPassword\"); properties.getProperty(\"DriverName\"); &#125; catch (FileNotFoundException e) &#123; System.err.println(\"error: not found db.properties file\"); e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获取数据库配置 static Properties getProperties() &#123; return properties; &#125;&#125; DBUtil : 连接数据库的工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.curd.utils;import java.sql.Connection;import java.sql.DriverManager;/** * @project: curd-demo * @description: 链接数据库的工具类 * @author: 黄宇辉 * @date: 8/22/2019-3:30 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DBUitl &#123; private static Connection connection; //获取数据库配置信息 private static String URL = ConfigUtil.getProperties().getProperty(\"Url\"); private static String USER = ConfigUtil.getProperties().getProperty(\"UserName\"); private static String PASSWORD = ConfigUtil.getProperties().getProperty(\"UserPassword\"); private static String DRIVER_NAME = ConfigUtil.getProperties().getProperty(\"DriverName\"); //加载数据库驱动 static &#123; try &#123; Class.forName(DRIVER_NAME); &#125; catch (Exception e) &#123; System.err.println(\"error: fail to init the driver of database\"); throw new ExceptionInInitializerError(e); &#125; &#125; //获取数据库连接 public static Connection getConnection() &#123; if (connection == null) &#123; try &#123; connection = DriverManager.getConnection(URL, USER, PASSWORD); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return connection; &#125;&#125; User.java : 用户信息类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package pers.huangyuhui.curd.bean;/** * @project: curd-demo * @description: 用户基础信息 * @author: 黄宇辉 * @date: 8/22/2019-3:22 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class User &#123; private Integer id; private String name; private Integer age; private String gender; private String password; private String telephone; private String birthday; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTelephone() &#123; return telephone; &#125; public void setTelephone(String telephone) &#123; this.telephone = telephone; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", gender='\" + gender + '\\'' + \", password='\" + password + '\\'' + \", telephone='\" + telephone + '\\'' + \", birthday='\" + birthday + '\\'' + '&#125;'; &#125;&#125; UserDao.java : 数据访问层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package pers.huangyuhui.curd.dao;import pers.huangyuhui.curd.bean.User;import pers.huangyuhui.curd.utils.DBUitl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * @project: curd-demo * @description: 数据访问层(DAO):可利用JDK8新特性Lambda来优化此程序 * @author: 黄宇辉 * @date: 8/22/2019-3:28 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class UserDao &#123; //获取数据库连接 private static Connection connection = DBUitl.getConnection(); //添加用户信息 public boolean insertNewUser(User user) &#123; String sql = \"insert into tb_user(name, age, gender, password, telephone, birthday) values (?,?,?,?,?,?)\"; try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) &#123; preparedStatement.setString(1, user.getName()); preparedStatement.setInt(2, user.getAge()); preparedStatement.setString(3, user.getGender()); preparedStatement.setString(4, user.getPassword()); preparedStatement.setString(5, user.getBirthday()); preparedStatement.setString(6, user.getTelephone()); return preparedStatement.executeUpdate() &gt; 0; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125; //查询所有用户信息 public List&lt;User&gt; selectAllUser() &#123; String sql = \"select id, name, age, gender, password, telephone, birthday from tb_user\"; List&lt;User&gt; list = new ArrayList&lt;&gt;(); try (PreparedStatement preparedStatement = connection.prepareStatement(sql); ResultSet resultSet = preparedStatement.executeQuery()) &#123; while (resultSet.next()) &#123; User user = new User(); user.setId(resultSet.getInt(\"id\")); user.setName(resultSet.getString(\"name\")); user.setAge(resultSet.getInt(\"age\")); user.setGender(resultSet.getString(\"gender\")); user.setPassword(resultSet.getString(\"password\")); user.setTelephone(resultSet.getString(\"telephone\")); user.setBirthday(resultSet.getString(\"birthday\")); list.add(user); &#125; return list; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; //更新用户信息 public boolean updateUserById(User user) &#123; String sql = \"UPDATE tb_user SET name = ? , gender = ? , age = ? , password = ?, birthday = ?, telephone = ? where id = ?\"; try &#123; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, user.getName()); preparedStatement.setString(2, user.getGender()); preparedStatement.setInt(3, user.getAge()); preparedStatement.setString(4, user.getPassword()); preparedStatement.setString(5, user.getBirthday()); preparedStatement.setString(6, user.getTelephone()); preparedStatement.setInt(7, user.getId()); return preparedStatement.executeUpdate() &gt; 0; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125; //删除用户信息 public boolean deleteUserById(Integer id) &#123; String sql = \"delete from tb_user where id = ?\"; try &#123; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, id); return preparedStatement.executeUpdate() &gt; 0; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; UserService.java : 业务逻辑层 123456789101112131415161718192021222324package pers.huangyuhui.curd.service;import pers.huangyuhui.curd.bean.User;import java.util.List;/** * @project: curd-demo * @description: 业务逻辑层(Service) * @author: 黄宇辉 * @date: 8/22/2019-3:29 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface UserService &#123; List&lt;User&gt; getAllUser(); boolean addUser(User user); boolean updateUser(User user); boolean deleteUser(Integer id);&#125; UserServiceImpl.java : 业务逻辑层的实现类 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.curd.service.impl;import pers.huangyuhui.curd.bean.User;import pers.huangyuhui.curd.dao.UserDao;import pers.huangyuhui.curd.service.UserService;import java.util.List;/** * @project: curd-demo * @description: 业务逻辑层的实现类 * @author: 黄宇辉 * @date: 8/22/2019-3:29 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class UserServiceImpl implements UserService &#123; private static UserDao userDao = new UserDao(); @Override public List&lt;User&gt; getAllUser() &#123; return userDao.selectAllUser(); &#125; @Override public boolean addUser(User user) &#123; return userDao.insertNewUser(user); &#125; @Override public boolean updateUser(User user) &#123; return userDao.updateUserById(user); &#125; @Override public boolean deleteUser(Integer id) &#123; return userDao.deleteUserById(id); &#125;&#125; AppTest.java : 程序测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package pers.huangyuhui.curd;import org.junit.BeforeClass;import org.junit.Test;import pers.huangyuhui.curd.bean.User;import pers.huangyuhui.curd.service.UserService;import pers.huangyuhui.curd.service.impl.UserServiceImpl;import java.util.List;/** * Unit test for simple App. */public class AppTest &#123; private static UserService userService; @BeforeClass public static void init() &#123; userService = new UserServiceImpl(); &#125; //test getAllUser() method @Test public void printAllUser() &#123; List&lt;User&gt; allUsers = userService.getAllUser(); System.out.println(\"获取所有的用户信息 : \" + allUsers); &#125; //test addUser method @Test public void addUser() &#123; User user = new User(); user.setName(\"addUser\"); user.setGender(\"男\"); user.setAge(0); user.setPassword(\"pwd\"); user.setTelephone(\"000000\"); user.setBirthday(\"0000-00-00\"); System.out.println(\"是否成功添加用户信息 : \" + userService.addUser(user)); &#125; //test updateUser method @Test public void updateUser() &#123; User user = new User(); user.setId(1); user.setName(\"updateUser\"); user.setGender(\"女\"); user.setAge(0); user.setPassword(\"pwd\"); user.setTelephone(\"111111\"); user.setBirthday(\"1111-11-11\"); System.out.println(\"是否成功更新用户信息 : \" + userService.updateUser(user)); &#125; //test deleteUser method @Test public void deleteUser() &#123; System.out.println(\"是否成功删除用户信息 : \" + userService.deleteUser(1)); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"Java设计模式之Template Method模式","slug":"Java设计模式之Template-Method-Pattern","date":"2019-09-04T05:31:23.000Z","updated":"2019-09-25T04:01:36.835Z","comments":true,"path":"2019/09/04/Java设计模式之Template-Method-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/04/Java设计模式之Template-Method-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Template Method模式概述模板设计模式 : 定义一个操作中算法的框架,而将这一些步骤延迟到子类中. 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤,简单点说既在父类中定义处理流程的框架,在子类中实现具体的处理. ( Template Method Pattern : Define the skeleton of an algorithm in an operation,deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure ) 其是一种基于继承的代码复用技术,它是一种行为型模式,当然也是最简单的行为设计模式 ~ 模板方法模式的实现分类模板方法模式的实现可划分为 : 模板方法( 基本方法的集合 )和基本方法( 实现具体的逻辑步骤 ) 模板方法模板方法是指定义在抽象类中,把基本操作方法组合在一起形成一个总算法或一个总行为的方法. 模板方法是一个具体方法,其逻辑的组成步骤在抽象类中可以是具体方法,也可以是抽象方法( 可将模板方法定义为 final 方法哟 ) 基本方法基本方法是实现算法各个步骤的方法,是模板方法的组成部分. 其可划分为 : 抽象方法 : 一个抽象方法由抽象类声明,由其具体子类实现. 具体方法 : 一个具体方法由是一个抽象类或具体类声明并实现,其子类可以进行覆盖也可以进行直接继承 钩子方法 : 一个钩子方法由一个抽象类或者具体类声明并实现,而其子类可能会加以扩展. 示例程序-简洁版下面是一个使用模板方法模式的简单示例程序 : 通过自定义模板样式来打印不同包裹字符的效果~ AbstractDisplay抽象类 : 充当抽象类角色 123456789101112131415161718192021222324252627282930313233343536package pers.huangyuhui.template_method.template_method1;/** * @project: design-patterns * @description: 充当抽象类角色 * @author: 黄宇辉 * @date: 9/4/2019-10:46 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class AbstractDisplay &#123; //基本方法-抽象方法 public abstract void open(); //基本方法-抽象方法 public abstract void print(); //基本方法-抽象方法 public abstract void close(); //模板方法:为具体方法,其逻辑的组成步骤可以是具体方法或抽象方法.. public /*final*/ void disply() &#123; open(); for (int i = 0; i &lt; 5; i++) &#123; print(); &#125; close(); &#125; //基本方法-具体方法 //略······ //基本方法-钩子方法 //略······&#125; CustomDisplay1类 : 充当具体类角色 1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.template_method.template_method1;/** * @project: design-patterns * @description: 充当具体类角色 * @author: 黄宇辉 * @date: 9/4/2019-10:44 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class CustomDisplay1 extends AbstractDisplay &#123; private String string; private int width; public CustomDisplay1(String string) &#123; this.string = string; width = string.getBytes().length; &#125; @Override public void open() &#123; printLine(); &#125; @Override public void print() &#123; System.out.println(\"█\" + string + \"█\"); &#125; @Override public void close() &#123; printLine(); &#125; private void printLine() &#123; System.out.print(\"●\"); for (int i = 0; i &lt; width; i++) &#123; System.out.print(\"■\"); &#125; System.out.println(\"●\"); &#125;&#125; CustomDisplay2类 : 充当具体类角色 12345678910111213141516171819202122232425262728293031323334353637383940414243package pers.huangyuhui.template_method.template_method1;/** * @project: design-patterns * @description: 充当具体类角色 * @author: 黄宇辉 * @date: 9/4/2019-11:03 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class CustomDisplay2 extends AbstractDisplay &#123; private String string; private int width; public CustomDisplay2(String string) &#123; this.string = string; this.width = string.getBytes().length; &#125; @Override public void open() &#123; printLine(); &#125; @Override public void print() &#123; System.out.println(\"|\" + string + \"|\"); &#125; @Override public void close() &#123; printLine(); &#125; private void printLine() &#123; System.out.print(\"+\"); for (int i = 0; i &lt; width; i++) &#123; System.out.print(\"-\"); &#125; System.out.println(\"+\"); &#125;&#125; Main类 : 程序测试 1234567891011121314151617181920package pers.huangyuhui.template_method.template_method1;/** * @project: design-patterns * @description: 测试类 * @author: 黄宇辉 * @date: 9/4/2019-10:54 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Main &#123; public static void main(String[] args) &#123; AbstractDisplay abstractDisplay = new CustomDisplay1(\"Template Method Pattern\"); AbstractDisplay abstractDisplay2 = new CustomDisplay2(\"Template Method Pattern\"); abstractDisplay.disply(); abstractDisplay2.disply(); &#125;&#125; 程序运行结果如下所示 : 1234567891011121314●■■■■■■■■■■■■■■■■■■■■■■■●█Template Method Pattern██Template Method Pattern██Template Method Pattern██Template Method Pattern██Template Method Pattern█●■■■■■■■■■■■■■■■■■■■■■■■●+-----------------------+|Template Method Pattern||Template Method Pattern||Template Method Pattern||Template Method Pattern||Template Method Pattern|s+-----------------------+ Template Method模式中登场的角色 AbstractClass( 抽象类 ) : AbstractClass角色不仅负责实现模板方法,还负责声明在模板方法中所使用到的抽象方法,这些抽象方法由子类ConcreteClass角色负责实现. ConcreteClass( 具体类 ) : 该类负责实现AbstrctClass中定义的抽象方法,这些实现的方法将会在AbstractClass角色的模板方法中别调用. 示例程序的类图 示例程序-详细版下面是一个使用方法模板模式的简单示例程序 : 该程序的功能( 模拟 )为支持多种数据源及图表的显示方式,但所有的图表实现操作都需基于XML格式的数据,因此可能需要对数据进行转换,如果从数据源中获取的数据已经是XML数据则无需进行转换,所以这里需要用到钩子方法哟 DataViewer抽象类 : 充当抽象类角色 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.template_method.template_method2;/** * @project: design-patterns * @description: 充当抽象类角色 * @author: 黄宇辉 * @date: 9/4/2019-12:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class DataViewer &#123; //抽象方法:获取数据 public abstract void getData(); //具体方法:转换数据 private void convertData() &#123; System.out.println(\"将数据转换为XML格式\"); &#125; //抽象方法:显示数据 public abstract void displayData(); //钩子方法:判断是否为XML格式的数据 public boolean isNotXMLData() &#123; return true; &#125; //模板方法 public final void process() &#123; getData(); //如果不是xml格式的数据,则需将其转换为xml格式的数据 if (isNotXMLData()) &#123; convertData(); &#125; displayData(); &#125;&#125; CustomDataViewer1类 : 充当具体类角色 1234567891011121314151617181920212223242526272829package pers.huangyuhui.template_method.template_method2;/** * @project: design-patterns * @description: 充当具体类角色 * @author: 黄宇辉 * @date: 9/4/2019-1:05 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class CustomDataViewer1 extends DataViewer &#123; @Override public void getData() &#123; System.out.println(\"从XML文件中获取数据\"); &#125; @Override public void displayData() &#123; System.out.println(\"以柱状图的方式显示数据\"); &#125; //覆盖父类的钩子方法 @Override public boolean isNotXMLData() &#123; //return super.isNotXMLData(); return false; &#125;&#125; CustomDataViewer2类 : 充当具体类角色 1234567891011121314151617181920212223package pers.huangyuhui.template_method.template_method2;/** * @project: design-patterns * @description: 充当具体类角色 * @author: 黄宇辉 * @date: 9/4/2019-1:08 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class CustomDataViewer2 extends DataViewer &#123; @Override public void getData() &#123; System.out.println(\"从XML文件中获取数据\"); &#125; @Override public void displayData() &#123; System.out.println(\"以圆饼图的方式显示数据\"); &#125;&#125; Main类 : 程序测试 12345678910111213141516171819package pers.huangyuhui.template_method.template_method2;/** * @project: design-patterns * @description: 测试类 * @author: 黄宇辉 * @date: 9/4/2019-1:10 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Main &#123; public static void main(String[] args) &#123; DataViewer dataViewer = new CustomDataViewer1(); DataViewer dataViewer2 = new CustomDataViewer2(); dataViewer.process(); System.out.println(\"--------------------\"); dataViewer2.process(); &#125;&#125; 程序运行结果如下所示 : 123456从XML文件中获取数据以柱状图的方式显示数据--------------------从XML文件中获取数据将数据转换为XML格式以圆饼图的方式显示数据 示例程序的类图","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Adapter模式","slug":"Java设计模式之Adapter-Pattern","date":"2019-09-03T10:18:31.000Z","updated":"2019-09-24T14:32:09.476Z","comments":true,"path":"2019/09/03/Java设计模式之Adapter-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/03/Java设计模式之Adapter-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Adapter模式概述适配器模式 : 将一个类的接口转换为客户希望的另一个接口. 适配器模式让那些接口不兼容的的类可以在一起工作. Adapter模式也称为Wrapper模式( Adapter Pattern : Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces ) 示例程序(使用继承的适配器)首先让我们来看一段使用继承的适配器的示例程序,该简单程序的作用是将一段输入的字符串显示为(hello)或`hello`. Banner类 : 充当Adaptee角色 1234567891011121314151617181920212223242526package pers.huangyuhui.adapter.adapter1;/** * @project: design-patterns * @description: 充当Adaptee角色 * @author: 黄宇辉 * @date: 9/3/2019-4:12 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Banner &#123; private String string; public Banner(String string) &#123; this.string = string; &#125; public void showWithParen() &#123; System.out.println(\"(\" + string + \")\"); &#125; public void showWithAster() &#123; System.out.println(\"*\" + string + \"*\"); &#125;&#125; Print接口 : 充当Target角色 123456789101112131415package pers.huangyuhui.adapter.adapter1;/** * @project: design-patterns * @description: 充当Target角色 * @author: 黄宇辉 * @date: 9/3/2019-4:15 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Print &#123; void printWeak(); void printStrong();&#125; PrintBanner类 : 充当Adapter角色 1234567891011121314151617181920212223242526package pers.huangyuhui.adapter.adapter1;/** * @project: design-patterns * @description: 充当Adapter角色 * @author: 黄宇辉 * @date: 9/3/2019-4:16 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class PrintBanner extends Banner implements Print &#123; public PrintBanner(String string) &#123; super(string); &#125; @Override public void printWeak() &#123; super.showWithParen(); &#125; @Override public void printStrong() &#123; super.showWithAster(); &#125;&#125; Main类 : 充当Client角色 1234567891011121314151617package pers.huangyuhui.adapter.adapter1;/** * @project: design-patterns * @description: 充当Client角色 * @author: 黄宇辉 * @date: 9/3/2019-4:17 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Main &#123; public static void main(String[] args) &#123; Print print = new PrintBanner(\"Hello\"); print.printWeak(); print.printStrong(); &#125;&#125; 程序运行结果如下所示 : 12(Hello)*Hello* 示例程序的类图 Adapter模式中登场的角色 Target( 目标抽象类 ) : 目标抽象类定义客户所需的接口,可以是一个抽象类或接口,也可以是具体类. 在类适配器中,由于Java语言不支持多重继承,所以它只能是接口. Client( 请求者 ) : 该角色负责使用 Target 角色所定义的方法进行具体的处理 Adapter( 适配器类 ) : 它可以调用另一个接口,作为一个转换器,对 Adaptee 和 Target 进行适配. 适配器 Adapter 是适配器模式的核心,在类适配器中,它通过实现 Target 接口并继承 Adaptee 来使两者产生联系,在对象适配器中,它通过继承Target并关联一个Adaptee对象来使两者产生联系. Adaptee( 适配者类 ) : 适配者既被适配的角色,它定义了一个已经存在的接口,这个接口需要适配,适配者类一般是一个具体类,其包含着客户希望使用的业务方法 示例程序(使用委托的适配器)在 Java 语言中,委托是指将某个方法中的实际处理交给其它实例的方法 Banner类 : 充当Adaptee角色(同上个示例程序) 12345678910111213141516171819202122232425package pers.huangyuhui.adapter.adapter2;/** * @project: design-patterns * @description: 充当Adaptee角色 * @author: 黄宇辉 * @date: 9/3/2019-4:23 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Banner &#123; private String string; public Banner(String string) &#123; this.string = string; &#125; public void showWithParen() &#123; System.out.println(\"(\" + string + \")\"); &#125; public void showWithAster() &#123; System.out.println(\"*\" + string + \"*\"); &#125;&#125; Print类 : 充当Target角色 123456789101112131415package pers.huangyuhui.adapter.adapter2;/** * @project: design-patterns * @description: 充当Target角色 * @author: 黄宇辉 * @date: 9/3/2019-4:21 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class Print &#123; public abstract void printWeak(); public abstract void pintStrong();&#125; PrintBanner类 : 充当Adapter角色 12345678910111213141516171819202122232425262728package pers.huangyuhui.adapter.adapter2;/** * @project: design-patterns * @description: 充当Adapter角色 * @author: 黄宇辉 * @date: 9/3/2019-4:22 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class PrintBanner extends Print &#123; private Banner banner; public PrintBanner(String string) &#123; this.banner = new Banner(string); &#125; @Override public void printWeak() &#123; banner.showWithParen(); &#125; @Override public void pintStrong() &#123; banner.showWithAster(); &#125;&#125; Main类 : 充当Client角色(同上个示例程序) 12345678910111213141516171819package pers.huangyuhui.adapter.adapter2;/** * @project: design-patterns * @description: 充当Client角色 * @author: 黄宇辉 * @date: 9/3/2019-4:26 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Main &#123; public static void main(String[] args) &#123; Print print = new PrintBanner(\"Adapter Pattern\"); print.printWeak(); print.pintStrong(); &#125;&#125; 示例程序的类图 扩-缺省适配模式缺省设计模式是适配器模式的一种变体,其应用也比较广泛,其定义为 : 缺省设计模式( Default Adapter Pattern ) : 当不需要实现一个接口提供的所有方法时,可先设计一个抽象类来实现接口,并为接口中的每个方法提供一个默认实现( 空方法 ),那么该抽象类的子类就可以选择性地覆盖父类的某些实现方法来实现需求,它适用于不想使用一个接口的所有方法的情况,又称为单接口适配器模式 示例程序下面是一个缺省适配模式的示例程序,创建一个 JFrame 窗体,并通过继承 MyWindowAdapter 适配器类,选择性地自定义监听事件. MyWindowAdapter接口 : 充当缺省适配器类. WindowListener, MouseListener接口 : 充当适配者接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package pers.huangyuhui.adapter.adapter3;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;/** * @project: design-patterns * @description: 充当缺省适配器类 * @author: 黄宇辉 * @date: 9/3/2019-4:35 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class MyWindowAdapter implements WindowListener, MouseListener &#123; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; &#125; @Override public void mouseExited(MouseEvent e) &#123; &#125; @Override public void windowOpened(WindowEvent e) &#123; &#125; @Override public void windowClosing(WindowEvent e) &#123; &#125; @Override public void windowClosed(WindowEvent e) &#123; &#125; @Override public void windowIconified(WindowEvent e) &#123; &#125; @Override public void windowDeiconified(WindowEvent e) &#123; &#125; @Override public void windowActivated(WindowEvent e) &#123; &#125; @Override public void windowDeactivated(WindowEvent e) &#123; &#125;&#125; MyEventService类 : 充当具体业务类 12345678910111213141516171819202122232425262728293031package pers.huangyuhui.adapter.adapter3;import java.awt.event.MouseEvent;import java.awt.event.WindowEvent;/** * @project: design-patterns * @description: 充当具体业务类 * @author: 黄宇辉 * @date: 9/3/2019-4:40 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class MyEventService extends MyWindowAdapter &#123; @Override public void windowOpened(WindowEvent e) &#123; System.out.println(\"windowOpened : Hello\"); &#125; @Override public void windowClosing(WindowEvent e) &#123; System.out.println(\"windowClosing : Bye\"); &#125; @Override public void mouseClicked(MouseEvent e) &#123; System.out.println(\"mouseClicked : Clicked\"); &#125;&#125; MyContoller类 : 测试类,创建JFrame窗体并为其绑定监听事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.adapter.adapter3;import javax.swing.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/** * @project: design-patterns * @description: 创建JFrame窗体并为其绑定监听事件 * @author: 黄宇辉 * @date: 9/3/2019-4:47 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class MyController &#123; public static void main(String[] args) &#123; MyEventService myEventService = new MyEventService(); JFrame j = new JFrame(\"title\"); j.setSize(500, 300); j.setVisible(true); j.setLocationRelativeTo(null); j.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //绑定事件 j.addWindowListener(new WindowAdapter() &#123; @Override public void windowOpened(WindowEvent e) &#123; myEventService.windowOpened(e); &#125; @Override public void windowClosing(WindowEvent e) &#123; myEventService.windowClosing(e); &#125; &#125;); j.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; myEventService.mouseClicked(e); &#125; &#125;); &#125;&#125; 示例程序的类图 Adapter模式中登场的角色 ServiceInterface( 适配器接口 ) : 该接口中声明了大量的方法. AbstractServiceClass( 缺省适配器类 ) : 为缺省适配器模式的核心类,通常将其定义为抽象类,使用空方法的形式实现了在 ServiceInterface 接口中声明的方法. ConcreteServiceClass( 具体业务类 ) : 直接继承 AbstractServiceClass 适配器类,根据需要有选择性地覆盖在适配器中定的方法.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"Java设计模式之Iterator模式","slug":"Java设计模式之Iterator-Pattern","date":"2019-09-02T13:50:06.000Z","updated":"2019-09-24T14:30:39.071Z","comments":true,"path":"2019/09/02/Java设计模式之Iterator-Pattern/","link":"","permalink":"http://yoursite.com/2019/09/02/Java设计模式之Iterator-Pattern/","excerpt":"","text":"学习笔记 : Java设计模式之Iterator模式概述迭代器模式 : 提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露该对象的内部表示. 迭代器模式又称( Cursor )模式,它是一种对象行为型模式( Iterator Pattern : Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation ) 示例程序-详细版下面是一个实现了Iterator模式的示例程序,其作用是将书籍信息( Book )放到存储书籍信息的书架( BookSelf )上,并将书的名字按顺序显示出来 Book : 图书信息类 1234567891011121314151617181920212223package pers.huangyuhui.iterator;/** * @project: design-patterns * @description: Book信息 * @author: 黄宇辉 * @date: 9/2/2019-4:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; Aggregate接口 : 充当集合角色 123456789101112131415package pers.huangyuhui.iterator;/** * @project: design-patterns * @description: 集合 * @author: 黄宇辉 * @date: 9/2/2019-5:00 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Aggregate &#123; Iterator iterator();&#125; BookSelf类 : 充当具体的集合角色 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.iterator;/** * @project: design-patterns * @description: 具体的集合 * @author: 黄宇辉 * @date: 9/2/2019-5:03 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BookSelf implements Aggregate &#123; private Book[] books; private int last = 0; public BookSelf(int maxsize) &#123; this.books = new Book[maxsize]; &#125; public Book getBookByIndex(int index) &#123; return books[index]; &#125; public void appendBook(Book book) &#123; this.books[last++] = book; &#125; public int getLength() &#123; return last; &#125; @Override public Iterator iterator() &#123; return new BookShelfIterator(this); &#125;&#125; Iterator接口 : 充当迭代器角色 123456789101112131415package pers.huangyuhui.iterator;/** * @project: design-patterns * @description: 迭代器 * @author: 黄宇辉 * @date: 9/2/2019-5:01 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface Iterator &#123; boolean hasNext(); Object next();&#125; BookShelfIterator类 : 充当具体的迭代器角色 123456789101112131415161718192021222324252627282930package pers.huangyuhui.iterator;/** * @project: design-patterns * @description: 集体的迭代器 * @author: 黄宇辉 * @date: 9/2/2019-5:07 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BookShelfIterator implements Iterator &#123; private BookSelf bookSelf; private int index; public BookShelfIterator(BookSelf bookSelf) &#123; this.bookSelf = bookSelf; this.index = 0; &#125; @Override public boolean hasNext() &#123; return index &lt; bookSelf.getLength(); &#125; @Override public Object next() &#123; return bookSelf.getBookByIndex(index++); &#125;&#125; Test测试类 123456789101112131415161718192021222324252627package pers.huangyuhui.iterator;/** * @project: design-patterns * @description: 测试类 * @author: 黄宇辉 * @date: 9/2/2019-5:09 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Test &#123; //demo public static void main(String[] args) &#123; BookSelf bookSelf = new BookSelf(5); bookSelf.appendBook(new Book(\"A-BOOK\")); bookSelf.appendBook(new Book(\"B-BOOK\")); bookSelf.appendBook(new Book(\"C-BOOK\")); bookSelf.appendBook(new Book(\"D-BOOK\")); bookSelf.appendBook(new Book(\"E-BOOK\")); Iterator iterator = bookSelf.iterator(); while (iterator.hasNext()) &#123; Book book = (Book) iterator.next(); System.out.println(book.getName()); &#125; &#125;&#125; 程序运行结果如下所示 : 12345A-BOOKB-BOOKC-BOOKD-BOOKE-BOOK 示例程序的类图 Iterator模式中的角色分析 Iterator( 迭代器 ) : 该角色负责定义按顺序逐个遍历元素的接口( API ),在上述程序中,由Iterator接口扮演此角色. ConcreteIterator( 具体的迭代器 ) : 该角色负责实现Iterator角色所定义的接口( API ). 在上述程序中,由BookShelfIterator类扮演此角色. Aggregate( 集合 / 抽象聚合类 ) : 该角色负责定义创建Iterator角色的接口( API ),在上述程序中,由Aggregate接口扮演此角色. ConcreteAggregate( 具体的集合 / 具体聚合类 ) : 该角色负责实现Aggregate角色所定义的接口( API ),它会创建出具体的Iterator角色. 在上述程序中,由BookSelf类扮演了此角色. 示例程序-简洁版下面同样是一个实现了Iterator模式的示例程序( 同上 ),其作用是将商品数据存储到商品集合( ProductList )中,并将商品的名字按顺序显示出来 AbstractObjectList : 抽象聚合类 123456789101112131415161718192021222324252627282930313233343536package pers.huangyuhui.iterator2;import java.util.List;/** * @project: design-patterns * @description: 抽象聚合类 * @author: 黄宇辉 * @date: 9/2/2019-5:51 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class AbstractObjectList &#123; protected List&lt;Object&gt; objects; public AbstractObjectList(List&lt;Object&gt; objects) &#123; this.objects = objects; &#125; public void addObject(Object object) &#123; this.objects.add(object); &#125; public void removeObject(Object object) &#123; this.objects.remove(object); &#125; public List&lt;Object&gt; getObjects() &#123; return objects; &#125; //创建迭代器的抽象工厂方法 public abstract AbstractIterator iterator();&#125; ProductList : 商品数据类,充当具体聚合类. ProductIterator(内部类) : 商品迭代器,充当具体迭代器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.iterator2;import java.util.List;/** * @project: design-patterns * @description: 商品书籍类, 充当具体聚合类 * @author: 黄宇辉 * @date: 9/2/2019-5:56 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ProductList extends AbstractObjectList &#123; public ProductList(List&lt;Object&gt; objects) &#123; super(objects); &#125; @Override public AbstractIterator iterator() &#123; return new ProductIterator(); &#125; /* ProductIterator:商品迭代器,充当具体迭代器(使用内部类实现迭代器,与jdk中的迭代器实现原理相同) */ public class ProductIterator implements AbstractIterator &#123; private int cursor; public ProductIterator() &#123; cursor = 0; &#125; @Override public boolean hasNext() &#123; return cursor &lt; objects.size(); &#125; @Override public Object next() &#123; return objects.get(cursor++); &#125; &#125;&#125; AbstractIterator : 抽象迭代器 12345678910111213141516package pers.huangyuhui.iterator2;/** * @project: design-patterns * @description: 抽象迭代器 * @author: 黄宇辉 * @date: 9/2/2019-5:55 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface AbstractIterator &#123; boolean hasNext(); Object next();&#125; Test : 测试类 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.iterator2;import java.util.ArrayList;import java.util.List;/** * @project: design-patterns * @description: 测试类 * @author: 黄宇辉 * @date: 9/2/2019-6:13 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Test &#123; //demo public static void main(String[] args) &#123; List&lt;Object&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(\"A-BOOK\"); arrayList.add(\"B-BOOK\"); arrayList.add(\"C-BOOK\"); ProductList productList = new ProductList(arrayList); productList.addObject(\"D-BOOK\"); productList.addObject(\"E-BOOK\"); productList.removeObject(\"A-BOOK\"); AbstractIterator iterator = productList.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; System.out.println(\"all datas : \" + productList.getObjects().toString()); &#125;&#125; 程序运行结果如下所示 : 12345B-BOOKC-BOOKD-BOOKE-BOOKall datas : [B-BOOK, C-BOOK, D-BOOK, E-BOOK] 示例程序的类图 📚参与书籍 : 《图解设计模式 - [日]结诚浩 · 著》, 《Java设计模式 - 刘伟编 · 著》","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and pattern","slug":"design-and-pattern","permalink":"http://yoursite.com/tags/design-and-pattern/"}]},{"title":"面向对象的设计原则","slug":"面向对象的设计原则","date":"2019-09-02T13:47:56.000Z","updated":"2019-09-03T01:32:19.196Z","comments":true,"path":"2019/09/02/面向对象的设计原则/","link":"","permalink":"http://yoursite.com/2019/09/02/面向对象的设计原则/","excerpt":"","text":"学习笔记 : 面向对象的设计原则概述软件的可维护性( Maintainability )和可复用性( Reusability )是两个非常重要的用于衡量软件质量的属性,软件的可维护性是指软件能够被理解,改正,适应及扩展的难以程度,软件的可复用性是指软件能够被重复使用的难易程度. 面向对象设计原则也是后续设计模式学习的基础,每一个设计模式都符合某一个或多个面向对象设计原则,面向对象原则是用于评价一个设计模式的使用效果的重要指标之一. 通过在软件中使用这些原则可以提高软件的可维护性和可复用性. 设计模式是在特定环境下为解决某一通用软件设计问题提供的一套制定的解决方案,该方案描述了对象和类之间的相互作用 单一职责原则单一职责原则 : 一个对象应该只包含单一的职责,并且该职责被完整地封在一个类中 Single Responsibility Principle( SRP ) : Every object should have a single responsibility,and that responsibility should be entirely encapsulated by the calss. 开闭原则开闭原则 : 软件实体应当对外扩展开放,对修改关闭 Open-Closed Principle( OCP ) : Software entities should be open for extension,but closed for modification. 里氏代换原则里氏代换原则 : 所有引用基类的地方必须能够透明地使用其子类的对象 Liskov Substitution Principle( LSP ) : Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 依赖倒转原则依赖倒转原则 : 高层模块不应该依赖底层模块,它们都应该依赖抽. 抽象不应该依赖于细节,细节应该依赖于抽象 Dependence Inversion Principle( DIP ) : High level modules should not depend upon low level modules,both should depend upon abstractions. Abstractions should not depend upon details,details should depend upon abstractions. 接口隔离原则接口隔离原则 : 客户端不应该依赖那些它不需要的接口 Interface Segregation Principle( ISP ) : Clients should not be forced to depend upon interfaces that they do not use. 合成复用原则合成复用原则 : 优先使用对象组合,而不是通过继承来达到复用的目的 Composite Reuse Principle(CRP) : Favor composition of objects over inheritance as reuse mechanism. 迪米特法则迪米特法则 : 每一个软件单位对其他单位都只有最少的知识,而且仅限于那些与本单位密切相关的软件单位 Law of Demeter( LoD ) : Each unit should have only limited knowledge about other units : only units “closely” related to the current unit. 摘自书籍 《Java设计模式 - 刘伟编著》","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"design and parttern","slug":"design-and-parttern","permalink":"http://yoursite.com/tags/design-and-parttern/"}]},{"title":"详解Binary Tree的实现方式及其应用","slug":"详解Binary-Tree的实现方式及其应用","date":"2019-09-01T13:10:45.000Z","updated":"2019-09-01T13:46:08.848Z","comments":true,"path":"2019/09/01/详解Binary-Tree的实现方式及其应用/","link":"","permalink":"http://yoursite.com/2019/09/01/详解Binary-Tree的实现方式及其应用/","excerpt":"","text":"学习笔记 : 详解Binary Tree的实现方式及其应用什么是二叉树如果一棵树中的每个结点有0,1或者2个孩子结点,那么这颗树就称为二叉树. 空树也是一棵有效的二叉树. 一个二叉树可以看作由根节点和两颗不相交的子树( 分别称为左子树和右子树 )组成. 其类型可分为 : 严格二叉树,满二叉树,完全二叉树. 二叉树的应用 编译器中的表达式树 用于数据压缩算法中的赫夫曼编码树 支持在集合中查找,插入和删除,其平均时间复杂度为 O(logn) 的二叉树搜索(或称为查找)树( BST ) 优先队列( PQ ),它支持以对数时间( 最坏情况下 )对集合中的最小( 或最大 )数据进行搜索和删除 二叉树的遍历根据实体( 结点 )处理顺序不同,可以定义不同的遍历方法. 其分类如下 : 前序遍历( DLR ) : 根节点 ——&gt; 左子树 ——&gt; 右子树 中序遍历( LDR ) : 左子树 ——&gt; 根节点 ——&gt; 右子树 后序遍历( LRD ) : 左子树 ——&gt; 右子树 ——&gt; 根节点 层次遍历 : 这种方法由图的广度优先遍历方法启发得来 程序实例 定义二叉树的结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.huangyuhui.tree;/** * @project: data structures and algorithms * @description: 定义二叉树的结构 * @author: 黄宇辉 * @date: 9/1/2019-2:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BinaryTreeNode &#123; private int data; private BinaryTreeNode left; private BinaryTreeNode right; public BinaryTreeNode() &#123; &#125; public BinaryTreeNode(int data) &#123; this.data = data; &#125; public BinaryTreeNode(int data, BinaryTreeNode left, BinaryTreeNode right) &#123; this.data = data; this.left = left; this.right = right; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public BinaryTreeNode getLeft() &#123; return left; &#125; public void setLeft(BinaryTreeNode left) &#123; this.left = left; &#125; public BinaryTreeNode getRight() &#123; return right; &#125; public void setRight(BinaryTreeNode right) &#123; this.right = right; &#125;&#125; 定义单向链表的结构 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.tree;/** * @project: data structures and algorithms * @description: 定义单向链表的结构 * @author: 黄宇辉 * @date: 9/1/2019-5:09 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LLNode&lt;T&gt; &#123; private T data; private LLNode next; public LLNode() &#123; &#125; public LLNode(T data) &#123; this.data = data; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public LLNode getNext() &#123; return next; &#125; public void setNext(LLNode next) &#123; this.next = next; &#125;&#125; 基于单向链表来实现一个栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package pers.huangyuhui.tree;/** * @project: data structures and algorithms * @description: 基于单向链表实现栈 * @author: 黄宇辉 * @date: 9/1/2019-3:10 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LLStack&lt;T&gt; &#123; private LLNode&lt;T&gt; headNode; public LLStack() &#123; this.headNode = new LLNode&lt;&gt;(); &#125; public boolean isEmpty() &#123; return headNode == null; &#125; //栈顶 public T top() &#123; if (headNode == null) &#123; return null; &#125; else &#123; return headNode.getData(); &#125; &#125; //入栈 public void push(T data) &#123; if (isEmpty()) &#123; headNode = new LLNode&lt;&gt;(data); &#125; else if (headNode.getData() == null) &#123; headNode.setData(data); &#125; else &#123; var llNode = new LLNode&lt;&gt;(data); llNode.setNext(headNode); headNode = llNode; &#125; &#125; //出栈 public T pop() &#123; if (isEmpty()) &#123; return null; &#125; else &#123; var data = headNode.getData(); headNode = headNode.getNext(); return data; &#125; &#125;&#125; 分别测试二叉树的前序,中序,后序遍历方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package pers.huangyuhui.tree;/** * @project: data structures and algorithms * @description: 二叉树的遍历方式 * @author: 黄宇辉 * @date: 9/1/2019-2:24 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BinaryTree &#123; public static BinaryTreeNode initBinaryTree() &#123; BinaryTreeNode root = new BinaryTreeNode(); root.setData(1); //根节点 root.setLeft(new BinaryTreeNode(2, new BinaryTreeNode(4), new BinaryTreeNode(5))); //左子树 root.setRight(new BinaryTreeNode(3, new BinaryTreeNode(6), new BinaryTreeNode(7))); //右子树 return root; &#125; //递归前序遍历 public void preOrder(BinaryTreeNode root) &#123; if (root != null) &#123; System.out.print(root.getData() + \", \"); preOrder(root.getLeft()); preOrder(root.getRight()); &#125; &#125; //非递归前序遍历 public void preOrderNonRecursive(BinaryTreeNode root) &#123; if (root == null) &#123; System.err.println(\"error : the tree is empty\"); &#125; var stack = new LLStack&lt;BinaryTreeNode&gt;(); while (true) &#123; while (root != null) &#123; System.out.print(root.getData() + \", \"); stack.push(root); root = root.getLeft(); &#125; if (stack.isEmpty()) &#123; break; &#125; root = stack.pop(); root = root.getRight(); &#125; &#125; //递归中序遍历 public void inOrder(BinaryTreeNode root) &#123; if (root != null) &#123; inOrder(root.getLeft()); System.out.print(root.getData() + \", \"); inOrder(root.getRight()); &#125; &#125; //非递归中序遍历 public void inOrderNonRecursive(BinaryTreeNode root) &#123; if (root == null) &#123; System.err.println(\"error : the tree is empty\"); &#125; var stack = new LLStack&lt;BinaryTreeNode&gt;(); while (true) &#123; while (root != null) &#123; stack.push(root); root = root.getLeft(); &#125; if (stack.isEmpty()) &#123; break; &#125; root = stack.pop(); System.out.print(root.getData() + \", \"); root = root.getRight(); &#125; &#125; //递归后序遍历 public void postOrder(BinaryTreeNode root) &#123; if (root != null) &#123; postOrder(root.getLeft()); postOrder(root.getRight()); System.out.print(root.getData() + \", \"); &#125; &#125; //非递归后序遍历 public void postNonRecursive(BinaryTreeNode root) &#123; //······ &#125; //test public static void main(String[] args) &#123; BinaryTree binaryTree = new BinaryTree(); BinaryTreeNode binaryTreeNode = BinaryTree.initBinaryTree(); System.out.println(\"------ 递归前序遍历 ------\"); binaryTree.preOrder(binaryTreeNode); //1,2,4,5,3,6,7 System.out.println(\"\\n------ 非递归前序遍历 ------\"); binaryTree.preOrderNonRecursive(binaryTreeNode); System.out.println(\"\\n------ 递归中序遍历 ------\"); binaryTree.inOrder(binaryTreeNode); //4,2,5,1,6,3,7 System.out.println(\"\\n------ 非递归中序遍历 ------\"); binaryTree.inOrderNonRecursive(binaryTreeNode); System.out.println(\"\\n------ 递归后序遍历 ------\"); binaryTree.postOrder(binaryTreeNode); //4,5,2,6,7,3,1 &#125;&#125; 程序运行结果如下所示 : 12345678910------ 递归前序遍历 ------1, 2, 4, 5, 3, 6, 7, ------ 非递归前序遍历 ------1, 2, 4, 5, 3, 6, 7, ------ 递归中序遍历 ------4, 2, 5, 1, 6, 3, 7, ------ 非递归中序遍历 ------4, 2, 5, 1, 6, 3, 7, ------ 递归后序遍历 ------4, 5, 2, 6, 7, 3, 1, 参考书籍( 已完善书中的示例代码 ) : 《数据结构与算法经典问题解析 - 原书第2版》","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"data structures and algorithms","slug":"data-structures-and-algorithms","permalink":"http://yoursite.com/tags/data-structures-and-algorithms/"}]},{"title":"详解Queue的实现方式及其应用","slug":"详解Queue的实现方式及其应用","date":"2019-08-31T13:37:20.000Z","updated":"2019-09-01T13:11:42.397Z","comments":true,"path":"2019/08/31/详解Queue的实现方式及其应用/","link":"","permalink":"http://yoursite.com/2019/08/31/详解Queue的实现方式及其应用/","excerpt":"","text":"学习笔记 : 详解Queue的实现方式及其应用什么是队列队列是一种只能在一端插入( 队尾 ),在另外一端删除( 堆首 )的有序线性表. 队列中第一个插入的元素也是第一个被删除的元素. 所以,队列是一种先进先出( FIFO,First In First Out )或后进后出( LILO,Last In Last Out )线性表. 队列的应用 直接相关的应用 操作系统根据( 具有相同优先级的 )任务到达的顺序调度任务( 例如,打印队列 ) 模拟现实世界中的队列,如售票柜台前的队伍,或者任何需要先来先服务的场景 多道程序设计 异步数据传输( 文件输入输出,管道,套接字 ) 间接相关的应用 作为算法的辅助数据结构 其他数据结构的组件 队列的实现方式队列抽象数据类型( 与栈类似 )有多种实现方式,下面是常用的方法 : 基于简单循环数组的实现方法 基于动态循环数据的实现方法 基于链表的实现方法 简单循环数组的实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package pers.huangyuhui.queue;import java.util.Arrays;/** * @project: Data structures and algorithms * @description: 基于简单循环数组实现队列 * @author: 黄宇辉 * @date: 8/31/2019-9:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ArrayQueue &#123; private int front; private int rear; private int capacity; private int[] array; public ArrayQueue(int size) &#123; this.capacity = size; front = rear = -1; array = new int[size]; &#125; public static ArrayQueue createQueue(int size) &#123; return new ArrayQueue(size); &#125; public boolean isEmpty() &#123; return (front == -1); &#125; public boolean isFull() &#123; return ((rear + 1) % capacity == front); &#125; public void traverse() &#123; System.out.println(Arrays.toString(array)); &#125; public int getQueueSize() &#123; if (front == -1) &#123; return 0; &#125; int size = (capacity - front + rear + 1) % capacity; if (size == 0) &#123; return capacity; &#125; else &#123; return size; &#125; &#125; //入队 public void enQueue(int data) &#123; if (isFull()) &#123; System.err.println(\"error : the queue is overflow\"); &#125; else &#123; rear = (rear + 1) % capacity; array[rear] = data; if (front == -1) &#123; front = rear; &#125; System.out.println(\"enter the data into the queue successfully : \" + data); &#125; &#125; //出队 public int deQueue() &#123; int data = 0; if (isEmpty()) &#123; System.err.println(\"error : the queue is empty\"); &#125; else &#123; data = array[front]; array[front] = 0; if (front == rear) &#123; front = rear = -1; &#125; else &#123; front = (front + 1) % capacity; &#125; System.out.println(\"delete the data from the queue successfully : \" + data); &#125; return data; &#125; //test public static void main(String[] args) &#123; ArrayQueue queue = ArrayQueue.createQueue(5); //enter queue.enQueue(1); queue.enQueue(2); queue.enQueue(3); queue.enQueue(4); queue.enQueue(5); System.out.println(\"the size of queue : \" + queue.getQueueSize()); System.out.print(\"traverse the queue : \"); queue.traverse(); //delete queue.deQueue(); queue.deQueue(); queue.deQueue(); queue.deQueue(); queue.deQueue(); System.out.println(\"the size of queue : \" + queue.getQueueSize()); System.out.print(\"traverse the queue : \"); queue.traverse(); &#125;&#125; 程序运行结果如下 :123456789101112131415enter the data into the queue successfully : 1enter the data into the queue successfully : 2enter the data into the queue successfully : 3enter the data into the queue successfully : 4enter the data into the queue successfully : 5the size of queue : 5traverse the queue : [1, 2, 3, 4, 5]delete the data from the queue successfully : 1delete the data from the queue successfully : 2delete the data from the queue successfully : 3delete the data from the queue successfully : 4delete the data from the queue successfully : 5the size of queue : 0traverse the queue : [0, 0, 0, 0, 0] 动态循环数据的实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package pers.huangyuhui.queue;import java.util.Arrays;/** * @project: Data structures and algorithms * @description: 基于动态循环数组实现队列 * @author: 黄宇辉 * @date: 9/1/2019-8:59 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DynArrayQueue &#123; private int front; private int rear; private int capacity; private int[] array; private DynArrayQueue() &#123; capacity = 1; front = rear = -1; array = new int[1]; &#125; public static DynArrayQueue createDynArrayQueue() &#123; return new DynArrayQueue(); &#125; public boolean isEmpty() &#123; return (front == -1); &#125; public boolean isFull() &#123; return ((rear + 1) % capacity == front); &#125; public void traverse() &#123; System.out.println(Arrays.toString(array)); &#125; public int getQueueSize() &#123; if (front == -1) &#123; return 0; &#125; int size = (capacity - front + rear + 1) % capacity; if (size == 0) &#123; return capacity; &#125; else &#123; return size; &#125; &#125; //扩容 private void resizeQueue() &#123; int initCapacity = capacity; capacity *= 2; int[] oldArray = array; array = new int[this.capacity]; for (int i = 0; i &lt; oldArray.length; i++) &#123; array[i] = oldArray[i]; &#125; //important if (rear &lt; front) &#123; for (int i = 0; i &lt; front; i++) &#123; array[i + initCapacity] = this.array[i]; array[i] = 0; &#125; rear += initCapacity; &#125; &#125; //入队 public void enQueue(int data) &#123; if (isFull()) &#123; resizeQueue(); &#125; rear = (rear + 1) % capacity; array[rear] = data; if (front == -1) &#123; front = rear; &#125; System.out.println(\"enter a data into the queue successfully : \" + data); &#125; //出队 public int deQueue() &#123; int data = -1; if (isEmpty()) &#123; System.err.println(\"error : the queue is empty\"); &#125; else &#123; data = array[front]; array[front] = 0; //delete the data if (front == rear) &#123; front = rear = -1; &#125; else &#123; front = (front + 1) % capacity; &#125; System.out.println(\"delete a data from the queue successfully : \" + data); &#125; return data; &#125; //test public static void main(String[] args) &#123; DynArrayQueue dynArrayQueue = DynArrayQueue.createDynArrayQueue(); //enter dynArrayQueue.enQueue(1); dynArrayQueue.enQueue(2); dynArrayQueue.enQueue(3); dynArrayQueue.enQueue(4); dynArrayQueue.enQueue(5); System.out.println(\"the size of queue : \" + dynArrayQueue.getQueueSize()); System.out.print(\"traverse the queue : \"); dynArrayQueue.traverse(); //delete dynArrayQueue.deQueue(); dynArrayQueue.deQueue(); dynArrayQueue.deQueue(); dynArrayQueue.deQueue(); dynArrayQueue.deQueue(); System.out.println(\"the size of queue : \" + dynArrayQueue.getQueueSize()); System.out.print(\"traverse the queue : \"); dynArrayQueue.traverse(); &#125;&#125; 程序运行结果如下所示 :123456789101112131415enter a data into the queue successfully : 1enter a data into the queue successfully : 2enter a data into the queue successfully : 3enter a data into the queue successfully : 4enter a data into the queue successfully : 5the size of queue : 5traverse the queue : [1, 2, 3, 4, 5, 0, 0, 0]delete a data from the queue successfully : 1delete a data from the queue successfully : 2delete a data from the queue successfully : 3delete a data from the queue successfully : 4delete a data from the queue successfully : 5the size of queue : 0traverse the queue : [0, 0, 0, 0, 0, 0, 0, 0] 链表的实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package pers.huangyuhui.queue;//定义一个单向链表class LLNode &#123; private int data; private LLNode next; public LLNode(int data) &#123; this.data = data; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public LLNode getNext() &#123; return next; &#125; public void setNext(LLNode next) &#123; this.next = next; &#125;&#125;/** * @project: Data structures and algorithms * @description: 基于链表实现队列 * @author: 黄宇辉 * @date: 9/1/2019-9:19 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class LLQueue &#123; private LLNode frontNode; //represents headNode private LLNode rearNode; //represents lastNode public LLQueue() &#123; this.frontNode = null; this.rearNode = null; &#125; public static LLQueue createQueue() &#123; return new LLQueue(); &#125; public boolean isEmpty() &#123; return (frontNode == null); &#125; public int getQueueSize() &#123; int length = 0; LLNode currentNode = frontNode; while (currentNode != null) &#123; length++; currentNode = currentNode.getNext(); &#125; return length; &#125; //遍历 public void traverse() &#123; if (isEmpty()) &#123; System.err.println(\"error : the queue is empty !\"); return; &#125; LLNode currentNode = frontNode; System.out.print(\"the all data of queue : [ \"); while (currentNode != null) &#123; System.out.print(currentNode.getData() + \" ,\"); currentNode = currentNode.getNext(); &#125; System.out.print(\" ]\\n\"); &#125; //入队 public void enQueue(int data) &#123; LLNode newNode = new LLNode(data); if (rearNode != null) &#123; rearNode.setNext(newNode); &#125; rearNode = newNode; if (frontNode == null) &#123; frontNode = rearNode; &#125; System.out.println(\"enter the data into the queue successfully : \" + data); &#125; //出队 public int deQueue() &#123; int data = 0; if (isEmpty()) &#123; System.err.println(\"error : the queue is empty\"); &#125; else &#123; data = frontNode.getData(); frontNode = frontNode.getNext(); &#125; System.out.println(\"delete the data from the queue successfully : \" + data); return data; &#125; //test public static void main(String[] args) &#123; LLQueue queue = LLQueue.createQueue(); //enter queue.enQueue(1); queue.enQueue(2); queue.enQueue(3); queue.enQueue(4); queue.enQueue(5); System.out.println(\"the size of the queue : \" + queue.getQueueSize()); System.out.print(\"traverse the queue : \"); queue.traverse(); //delete queue.deQueue(); queue.deQueue(); queue.deQueue(); queue.deQueue(); queue.deQueue(); System.out.println(\"the size of the queue : \" + queue.getQueueSize()); System.out.print(\"traverse the queue : \"); queue.traverse(); &#125;&#125; 程序运行结果如下所示 :123456789101112131415enter the data into the queue successfully : 1enter the data into the queue successfully : 2enter the data into the queue successfully : 3enter the data into the queue successfully : 4enter the data into the queue successfully : 5the size of the queue : 5traverse the queue : the all data of queue : [ 1 ,2 ,3 ,4 ,5 , ]delete the data from the queue successfully : 1delete the data from the queue successfully : 2delete the data from the queue successfully : 3delete the data from the queue successfully : 4delete the data from the queue successfully : 5the size of the queue : 0traverse the queue : error : the queue is empty ! 参考书籍( 已纠正书中错误的示例代码 ) : 《数据结构与算法经典问题解析 - 原书第2版》","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"data structures and algorithms","slug":"data-structures-and-algorithms","permalink":"http://yoursite.com/tags/data-structures-and-algorithms/"}]},{"title":"软件工程琐碎知识点","slug":"软件工程琐碎知识点","date":"2019-08-31T00:16:29.000Z","updated":"2019-08-31T04:00:49.793Z","comments":true,"path":"2019/08/31/软件工程琐碎知识点/","link":"","permalink":"http://yoursite.com/2019/08/31/软件工程琐碎知识点/","excerpt":"","text":"学习笔记 : 软件工程琐碎知识点以下摘自软件工程书籍中各个章节的习题,一些琐碎的知识点而已~ 软件工程概述 什么是软件 ? 答 : 计算机软件( Software )是指与计算机系统操作有关的程序,规程,规则及任何与之有关的数据和文档资料. 什么是软件危机 ? 答 : 西方计算机界的科学家把软件开发和维护过程中遇到的一系列严重问题统称为”软件危机”. 什么是软件工程 ? 构成软件工程的要素是什么 ? 答 : 软件工程是指导计算机软件开发和维护的工程学科. 软件工程的方法,工具,过程构成了软件工程的三要素. 过程和声明周期的建模 什么是软件周期生命周期模型 ? 有哪些主要模型 ? 答 : 瀑布模型( waterfall model )也称为软件生命周期模型 : 从时间角度对软件开发和维护的复杂问题进行分解,把软件生存的漫长周期依次划分为若干个阶段,每个阶段有相对独立的任务,然后逐步完成每个阶段的任务. 主要软件开发模型有 : 瀑布模型,渐近模型,螺旋模型,增量式开发模型等. . . 什么是软件生存周期 ? 它有哪些活动 ? 答 : 软件开发过程有时被称为软件生命周期,因为它从概念到实现,交付,使用和维护描述了软件产品的生命. 可行性研究 可行性研究的任务是什么 ? 答 : 用最小的代价在尽可能短的时间内确定问题是否能够解决,是否有必要去解决 说明系统流程图的作用 ? 答 : 系统分析员可直接在系统流程图上模拟出可以实现计算机处理的部分,可利用系统流程图来分析业务流程的合理性,这些都是系统流程图的作用 需求分析基础 需求分析阶段的任务是什么 ? 答 : 对软件进行需求分析,继而将软件功能和性能的总体概念描述为具体的规格说明书,而这种规格说明书正式开发软件的基础哟 面向数据流的分析方法 什么是数据流图 ? 其作用是什么 ? 其中基本符号各表示什么含义 ? 答 : 数据流图( Data Flow Diagram )是软件系统逻辑模型的一种图形表示. 其作用为描述数据在系统中的流动和处理的情况,具有直观,形象,容易理解等优点. 数据流用箭头表示,加工用圆表示,文件用直线段表示,数据流的源点和终点用长方形表示. 什么是数据词典 ? 其作用是什么 ? 它有哪些条目 ? 答 : 数据字典( Data Dictionary )的作用与一般字典的作用一致,只不过它是用来对数据流图中出现的所有名字进行定义的,包括数据流,加工,文件等. 其作用为可以借助数据字典查出数据流图中每个名字的具体含义. 其包含的条目为数据流,文件,数据项,加工. 软件设计基础 通常采用哪些措施来降低模块间的耦合度 ? 答 : 一使用过程语句( 函数方式等 )调用其它模块,降低接口的复杂性. 二模块间传送的参数是数据. 三模块间共用的信息尽量少. PDL是什么 ? 答 : 过程设计语言( Process Design Language )又称伪程序( Pseudo Code ),它是一种混杂语言. PAD是什么 ? 答 : 问题分析图( Problem Analysis Diagram ),用二维树形结构的图来表示程序的控制流,将这种按”走树”规则翻译成程序代码比较容易. 什么是模块的作用范围 ? 答 : 模块的作用范围是指这个模块内的一个判定的作用范围. 判定的作用范围是指所有受这个判定( 直接或间接 )影响的模块. 程序设计语言和编码 程序设计语言主要有哪几类 ? 答 : 机器语言( 第一代语言 ),汇编语言( 第二代语言 ),高级语言 : 包含第三代既面向过程的语言,第四代既新型程序设计语言. 程序设计风格是什么 ? 答 : 编程风格是在不影响性能的前提下,有效地编排和组织程序,以提高可读性和可维护性. 检验和测试方法 为什么要进行软件检测 ? 软件检测的主要手段有哪几种 ? 答 : 若在软件投入生产运行之前,没有发现并纠正软件中的大部分差错,则这些错误迟早会在生产过程中暴露出来,那时不仅改正这些错误的代码更高,而且往往会造成很恶劣的后果哟. 软件检测的主要手段有 : 静态检查,动态检查,正确性证明 为什么要进行软件评审 ? 答 : 软件评审综合了技术性和管理性措施,手续并不复杂,难度不是很大,所需开支也不高,但效果甚好哟~ 软件测试的目的是什么 ? 答 : 测试的目的是为了发现错误并而执行程序,只是在心理上被看做一种”破坏的步骤” 什么是黑盒测试法 ? 答 : 如果产品具备的功能已经知道,则可以测试它的每一个功能是否都达到了预期的要求. 什么是白盒测试法 ? 答 : 如果产品内部活动方式已经知道,则可以测试它的内部活动是否符合设计要求. 软件维护 为什么要进行软件维护 ? 答 : 因为计算机程序总是在变化 : 故障需要排除,改进的要加进去,而且优化工作也要做. 什么是软件的可维护性 ? 答 : 可维护性是指维护人员为纠正软件系统出现的错误或缺陷,以及为满足新的要求而理解,修改和完善软件系统的难易程度. 软件维护的流程是 ? 答 : 修改软件设计,复查,必要的代码修改,单元测试,整体测试,有效性测试和复审. 统一建模语言 简述面向对象方法的特点 ? 答 : 面向对象( Object Oriented). 面向对象方法的特点为 : 与人类习惯的思维方法一致,软件系统结构稳定,软件系统具有可复用性,软件系统易于维护. 类与对象的关系是什么 ? 答 : 类是指具有相同属性和操作的对象集合,是对象的抽象. UML有哪几部分组成 ? 答 : 视图,图,模型元素,公共机制. 面向对象设计 如何进行系统分解 ? 答 : 可以将系统结构分为顶层,中间层和底层. 其中顶层为主控界面,中间层为业务处理子系统,底层为实体类与报表. 简述动态模型的构成 ? 答 : 动态模型分为交互模型和状态模型,其中交互模型包括顺序图与协作图,状态图模型包括状态图和活动图. 顺序图中的消息分为哪几种类型 ? 答 : 消息的类型包括简单消息,同步消息,异步消息和返回消息. 其中发送消息以实线箭头表示,返回消息以虚线箭头表示. 面向对象软件开发工具 简述 Rational Rose 的特点 ? 答 : 模型与代码高度一致,支持UML建模,可生成软件文档,可支持多种程序设计语言等特点. 什么是顺序图 ? 答 : 顺序图用于描述对象之间的交互行为,注重消息的时间顺序,是一种交互图. 正向工程的概念是什么 ? 答 : 正向工程( Forward Engineering )指从Rational Rose模型转换为某种特定语言代码的过程. 逆向工程的概念是什么 ? 答 : 逆向工程( Reverse Engineering )指将某种特定语言转化为Rational Rose模型的过程. 设计模式 什么是设计模式 ? 其目的是什么 ? 答 : 设计模式( Design Pattern )是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结. 其目的是为了代码可重用性、让代码更容易被他人理解、保证代码可靠性 敏捷开发 什么是敏捷开发 ? 答 : 敏捷开发( Aglie Development )是一种面临迅速变化的需求快速开发软件的能力. 什么是极限编程 ? 答 : 极限编程( eXtreme Programming )是敏捷方法中最著名的一种方法. 它是由一系列简单却相互依赖的实践组成,这些实践结合在一起形成了一个胜于部分结合的整体. 什么是重构 ? 答 : 重构( 名词 ) : 对软件内部结构的一种调整,目的是在不改变”软件之可观察行为”前提下提高其可理解性,降低其修改成本. 重构( 动词 ) : 使用一系列重构准则(手法),在不改变”软件之可观察行为”前提下,调整其结构.","categories":[],"tags":[{"name":"software engineering","slug":"software-engineering","permalink":"http://yoursite.com/tags/software-engineering/"}]},{"title":"使用MyBatis完成通用DAO和通用Service","slug":"使用MyBatis完成通用DAO和通用Service","date":"2019-08-27T10:43:03.000Z","updated":"2019-08-27T14:52:50.506Z","comments":true,"path":"2019/08/27/使用MyBatis完成通用DAO和通用Service/","link":"","permalink":"http://yoursite.com/2019/08/27/使用MyBatis完成通用DAO和通用Service/","excerpt":"","text":"学习笔记 : 使用MyBatis完成通用DAO和通用Service简介如 UserMapper 里面有 insert(User user) , find(Integer id) ,delete(Integer id) 等方法，则在 Service 中也要有这些方法的实现,假设每个 Mapper 有5个方法,则 Service 也需要有5个方法的实现. 如果有10个实体类, Mapper 可以省略( 可由工具生成 ),但是 Service 需要有这50个方法的实现. 既而后期会导致代码臃肿难以维护,且项目难以扩展哟~ 一般 Java 项目的分层结构图如下所示,详情请参考学习笔记 : Java项目开发中PO,BO,VO,DTO,POJO,DAO的概念及其作用 通用的DAO接口1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.memo.dao;import java.io.Serializable;import java.util.List;/** * @project: memo * @description: 通用的Mapper接口 * @author: 黄宇辉 * @date: 8/22/2019-8:44 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface BaseMapper&lt;T, ID extends Serializable&gt; &#123; int deleteByPrimaryKey(ID[] id); int insert(T record); int insertSelective(T record); T selectByPrimaryKey(ID id); List&lt;T&gt; selectBySelective(T t); int updateByPrimaryKeySelective(T record); int updateByPrimaryKeyWithBLOBs(T record); int updateByPrimaryKey(T record);&#125; 通用的Service接口1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.memo.service;import com.github.pagehelper.PageInfo;import pers.huangyuhui.memo.object.BaseConditionVO;import java.io.Serializable;import java.util.List;/** * @project: memo * @description: 通用的Service接口 * @author: 黄宇辉 * @date: 8/22/2019-8:54 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface BaseService&lt;T, ID extends Serializable&gt; &#123; void setBaseMapper(); int deleteByPrimaryKey(ID[] id); int insert(T record); int insertSelective(T record); T selectByPrimaryKey(ID id); List&lt;T&gt; selectBySelective(T record); PageInfo&lt;T&gt; selectForPage(T reccord, BaseConditionVO baseConditionVO); int updateByPrimaryKeySelective(T record); int updateByPrimaryKeyWithBLOBs(T record); int updateByPrimaryKey(T record);&#125; 通用的Service实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package pers.huangyuhui.memo.service.impl;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import pers.huangyuhui.memo.object.BaseConditionVO;import pers.huangyuhui.memo.dao.BaseMapper;import pers.huangyuhui.memo.service.BaseService;import java.io.Serializable;import java.util.List;/** * @project: memo * @description: 通用的Service实现类 * @author: 黄宇辉 * @date: 8/22/2019-8:55 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public abstract class AbstractService&lt;T, ID extends Serializable&gt; implements BaseService&lt;T, ID&gt; &#123; private BaseMapper&lt;T, ID&gt; baseMapper; //初始化baseMapper public void setBaseMapper(BaseMapper&lt;T, ID&gt; baseMapper) &#123; this.baseMapper = baseMapper; &#125; @Override public int deleteByPrimaryKey(ID[] id) &#123; return baseMapper.deleteByPrimaryKey(id); &#125; @Override public int insertSelective(T record) &#123; return baseMapper.insertSelective(record); &#125; @Override public T selectByPrimaryKey(ID id) &#123; return baseMapper.selectByPrimaryKey(id); &#125; @Override public List&lt;T&gt; selectBySelective(T record) &#123; return baseMapper.selectBySelective(record); &#125; @Override public PageInfo&lt;T&gt; selectForPage(T record, BaseConditionVO baseConditionVO) &#123; PageHelper.startPage(baseConditionVO.getPageNum(), baseConditionVO.getPageSize()); //设置每页的记录数 List&lt;T&gt; list = baseMapper.selectBySelective(record); //获取列表信息 return new PageInfo&lt;&gt;(list); &#125; @Override public int updateByPrimaryKeySelective(T record) &#123; return baseMapper.updateByPrimaryKey(record); &#125; @Override public int updateByPrimaryKeyWithBLOBs(T record) &#123; return baseMapper.updateByPrimaryKeyWithBLOBs(record); &#125; @Override public int updateByPrimaryKey(T record) &#123; return baseMapper.updateByPrimaryKey(record); &#125; @Override public int insert(T record) &#123; return baseMapper.insert(record); &#125;&#125; 具体的Mapper写法12345678910111213141516171819202122232425262728293031323334package pers.huangyuhui.memo.dao;import org.springframework.stereotype.Repository;import pers.huangyuhui.memo.bean.Friend;import java.util.List;/** * @project: memo * @description: 好友信息数据访问层 * @author: 黄宇辉 * @date: 2019-08-25 10:06 AM * @version: 2.0 * @website: https://yubuntu0109.github.io/ */@Repositorypublic interface FriendMapper extends BaseMapper&lt;Friend, Integer&gt; &#123; // TODO: 8/23/2019 添加好友信息 @Override int insertSelective(Friend friend); // TODO: 8/23/2019 选择性查询好友信息 @Override List&lt;Friend&gt; selectBySelective(Friend friend); // TODO: 8/23/2019 更新好友信息 @Override int updateByPrimaryKey(Friend friend); // TODO: 8/23/2019 删除好友信息 @Override int deleteByPrimaryKey(Integer[] id);&#125; 具体的Service写法1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.memo.service;import pers.huangyuhui.memo.bean.Friend;import java.util.List;/** * @project: memo * @description: 好友信息业务层 * @author: 黄宇辉 * @date: 2019-08-25 10:30 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface FriendService extends BaseService&lt;Friend, Integer&gt; &#123; // TODO: 8/25/2019 添加好友信息 @Override int insertSelective(Friend friend); // TODO: 8/25/2019 选择性查询好友信息 @Override List&lt;Friend&gt; selectBySelective(Friend friend); // TODO: 8/25/2019 更新好友信息 @Override int updateByPrimaryKey(Friend friend); // TODO: 8/25/2019 删除好友信息 @Override int deleteByPrimaryKey(Integer[] id);&#125; 具体的Service实现类写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package pers.huangyuhui.memo.service.impl;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import pers.huangyuhui.memo.bean.Friend;import pers.huangyuhui.memo.dao.FriendMapper;import pers.huangyuhui.memo.object.BaseConditionVO;import pers.huangyuhui.memo.service.FriendService;import java.util.List;/** * @project: memo * @description: 好友信息业务层的实现类 * @author: 黄宇辉 * @date: 8/22/2019-x:xx PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Service@Transactionalpublic class FriendServiceImpl extends AbstractService&lt;Friend, Integer&gt; implements FriendService &#123; @Autowired private FriendMapper friendMapper; //the method must be implemented //注:记得注入对象哟,不然会报空指针异常,因为在实际掉用的时候不是BaseMapper调用,而是这个friendMapper @Autowired @Override public void setBaseMapper() &#123; super.setBaseMapper(friendMapper); &#125; @Override public int insertSelective(Friend record) &#123; return super.insertSelective(record); &#125; @Override public List&lt;Friend&gt; selectBySelective(Friend record) &#123; return super.selectBySelective(record); &#125; @Override public PageInfo&lt;Friend&gt; selectForPage(Friend record, BaseConditionVO baseConditionVO) &#123; return super.selectForPage(record, baseConditionVO); &#125; @Override public int updateByPrimaryKeySelective(Friend record) &#123; return super.updateByPrimaryKeySelective(record); &#125; @Override public int deleteByPrimaryKey(Integer[] id) &#123; return super.deleteByPrimaryKey(id); &#125;&#125; 更多实现细节请参考我的 SpringBoot 小项目 : https://github.com/YUbuntu0109/springboot-beginner/tree/refactor-190823","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"详解JDK 11中的新特性","slug":"JDK-11新特性详解","date":"2019-08-22T01:17:34.000Z","updated":"2019-08-25T06:31:00.982Z","comments":true,"path":"2019/08/22/JDK-11新特性详解/","link":"","permalink":"http://yoursite.com/2019/08/22/JDK-11新特性详解/","excerpt":"","text":"学习笔记 : 详解JDK 11中的新特性北京时间2018年9月26日,Oracle官方宣布 Java11 正式发布,这是 Java 大版本周期变化的第一个长期支持版本,非常值得关注. 从官网既可下载,最新发布的 Java11 将带来 ZGC, Http Client 等重要特性,一共包含17个 JEP (JDK Enhancement Proposals,既 JDK 增强方案提议), 其内容如下所示,更多详细信息请参阅 : http://openjdk.java.net/projects/jdk/11/ 181: Nest-Based Access Control (嵌套类可见性控制) 309: Dynamic Class-File Constants (动态文件常量) 315: Improve Aarch64 Intrinsics (改进Aarch64 Intrinsics) 318: Epsilon: A No-Op Garbage Collector (Epsilon:一个无操作的垃圾收集器) 320: Remove the Java EE and CORBA Modules (删除Java EE和CORBA模块) 321: HTTP Client (Standard) (重点:标准HTTP客户端) 323: Local-Variable Syntax for Lambda Parameters (用于Lambda参数的局部变量语法) 324: Key Agreement with Curve25519 and Curve448 (Curve25519和Curve448算法的密钥协议) 327: Unicode 10 328: Flight Recorder (飞行记录器) 329: ChaCha20 and Poly1305 Cryptographic Algorithms (haCha20和Poly1305加密算法支持) 330: Launch Single-File Source-Code Programs (启动单一文件的源代码程序) 331: Low-Overhead Heap Profiling (低开销的Heap Profiling) 332: Transport Layer Security (TLS) 1.3 (重点:支持 TLS 1.3) 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental) (可伸缩低延迟垃圾收集器) 335: Deprecate the Nashorn JavaScript Engine (弃用Nashorn JavaScript引擎) 336: Deprecate the Pack200 Tools and API (弃用Pack200工具和API) String 新增方法新增加一系列字符串处理方法,程序示例如下 :12345678910111213141516171819@Testpublic void testString() &#123; //判断字符串是否为空白 var blank = \" \\t \\n \".isBlank(); //去除首尾空白 var strip = \" JavaStack \".strip(); //去除尾部空格 var trailing = \"JavaStack \".stripTrailing(); //去除首部空格 var leading = \" JavaStack\".stripLeading(); //复制字符串 var repeat = \"JavaStack\".repeat(3); //行数统计 var count = \"A\\nB\\nC\".lines().count(); //输出结果 List.of(blank, strip, trailing, leading, repeat, count).forEach(System.out::println);&#125; 程序运行结果如下所示 :123456trueJavaStackJavaStackJavaStackJavaStackJavaStackJavaStack3 启动单一文件的源代码程序JDK11之前我们若运行一个 Java 源代码必须先编译,再运行,两个执行步骤. 而在 JDK11 版本中我们可以通过一个 Java 命令就直接搞定咯,如下所示 :12345//JDK11版本之前需先编译后再运行程序javac JavaStack.javajava JavaStack//JDK11版本可直接运行程序java JavaStack.java 一个命令编译运行源代码的注意点 : 只执行源文件中的第一个类,既第一个类必须包含主方法 不可以使用其它源文件中的自定义类( 本文件中的自定义类是可以使用的 ) 优化局部变量类型推断在 var 上添加注解的语法格式在 JDK10 中是不能实现的,但在 JDK11 中加入了这样的语法1Consumer&lt;String&gt; consumer = (@Nonnull var s) -&gt; s.toUpperCase(); 删除 Java EE 和 CORBA 模块Java EE和 CORBA 两个模块在 JDK9 中已经标记deprecated,在 JDK11 中正式移除. JDK中 deprecated 的意思是在不建议使用,在未来的release版本会被删除. JavaEE由4部分组成 : JAX-WS (Java API for XML-Based Web Services) JAXB (Java Architecture for XML Binding) JAF (the JavaBeans Activation Framework) Common Annotations 这些特性和 JavaSE 关系不大,并且JavaEE被维护在 Github( https://github.com/javaee )中,版本同步造成维护困难. 最后,JavaEE 可以单独引用,Maven中心仓库也提供了 JavaEE( https://mvnrepository.com/artifact/javax/javaee-api ),所以没必要把JavaEE包含到JavaSE中. 而 CORBA( Common Object Request Broker Architecture,公共对象请求代理体系结构 )被标记为 Proposed Optional,既而表明将来可能会放弃对这些技术的必要支持 更多 JDK11 的新特性描述请参阅 : JDK11 官方文档","categories":[],"tags":[{"name":"JDK11","slug":"JDK11","permalink":"http://yoursite.com/tags/JDK11/"}]},{"title":"详解JDK 10中的新特性","slug":"JDK-10新特性详解","date":"2019-08-21T08:49:44.000Z","updated":"2019-08-25T06:31:00.980Z","comments":true,"path":"2019/08/21/JDK-10新特性详解/","link":"","permalink":"http://yoursite.com/2019/08/21/JDK-10新特性详解/","excerpt":"","text":"学习笔记 : 详解JDK 10中的新特性2018年3月21日,Oracle官方宣布 Java10 正式发布. 需要注意的是 Java9 和 Java19 都不是 LTS( Long-Term-Support )版本,和过去的 Java 大版本升级不同,这两个只有两年半左右的开发和维护期. 而 Java11,也就是18.9LTS,才是继 Java8 之后的第一个 LTS 版本. JDK10 中一共定义了109个新特性,其中包含12个 JEP,还有一些新 API 和 JVM 规范以及 Java 语言规范上的改动,JDK10 的12个 JEP( JDK Enhancement Proposal 特性加强提议 )如下所示,更多信息请参阅官方文档 : http://openjdk.java.net/projects/jdk/10/ Local-Variable Type Inference (主要重点:局部变量类型推断) Consolidate the JDK Forest into a Single Repository (JDK库的合并) Garbage-Collector Interface (统一的垃圾回收接口) Parallel Full GC for G1 (为G1提供并行的Full GC) Application Class-Data Sharing (应用程序类数据( AppCDS )共享) Thread-Local Handshakes (threadLocal握手交互) Remove the Native-Header Generation Tool (javah) (移除JDK中附带的javah工具) Additional Unicode Language-Tag Extensions (使用附加的Unicode语言标记扩展) Heap Allocation on Alternative Memory Devices (在可选内存设备上进行堆分配) Experimental Java-Based JIT Compiler (使用基于Java的JIT编译器) Root Certificates (根证书) Time-Based Release Versioning (基于时间的发布版本) 局部变量类型推断前言很多人抱怨 Java 是一种强类型,需要引入大量的样板代码. 甚至在这些情况下,给定好变量名,通常很清楚发生了什么,明显类型声明往往被认为是不必要的. 许多流行的编程语言都已经支持某种形式的局部变量类型推断 : 如C++ (auto), C# (var), Scala (var/val), Go (declaration with :=)等 简介Java 局部变量类型推断( LVTI ),JDK10 中可以使用 var 作为局部变量类型推断标识符,此符号仅适用于局部变量,增强for循环的索引,以及传统for循环的本地变量. 它不能使用于方法形式参数,构造函数形式参数,方法返回类型,字段,catch块形式参数或任何其他类型的变量声明. 标识符 var 不是关键字,相反,它是一个保留的类型名称. 这意味着 var 用作变量,方法名或则包名称的代码不会受到影响. 但 var 不能作为类或则接口的名字( 但这样命名是比较罕见的,因为他违反了通常的命名约定,类和接口首字母应该大写 ). 其工作原理为 : 在处理 var 时,编译器先是查看表达式右边部分,并根据右边变量值的类型进行推断,作为左边变量的类型,然后将该类型写入字符码当中 示例类型推断代码示例 :123456var str = \"ABC\"; //根据推断为字符串类型var l = 10L; //根据10L推断为long类型var flag = true; //根据true推断为boolean类型var flag1 = 1; //这里会推断boolean类型,0表示false非0表示truevar list = new ArrayList&lt;String&gt;(); //推断为ArrayList&lt;String&gt;var stream = list.stream(); //推断为Stream&lt;String&gt; 上述示例代码的反编译class文件 :123456String str = \"ABC\";long l = 10L;boolean flag = true;int flag1 = true;ArrayList&lt;String&gt; list = new ArrayList();Stream&lt;String&gt; stream = list.stream(); 遍历代码中使用类型推断 :12345//集合遍历var list = new ArrayList&lt;String&gt;();for (var s : list) &#123; &#125;//普通遍历for (var i = 1; i &lt; 10; i++) &#123; &#125; var 类型可以被final修饰符修饰1final int limit = 10; 注意在局部变量使用中,这些情况不适用类型推断哟 : 没有初始化的局部变量声明, 方法的返回类型, 方法的参数类型, 构造器的参数类型, 属性, catch块. 部分示例如下所示 初始值不能为null,既如果局部变量不赋值,则无法实现类型推断 123//errorvar string1;var string2 = null; 为数组静态初始化中,语法格式需要注意 123int[] array = &#123;1, 2, 3, 4, 5&#125;; //正确写法var array2 = new int[]&#123;1, 2, 3, 4, 5&#125;; //正确写法var array3 = &#123;1, 2, 3, 4, 5&#125;; //错误写法 Lambda表达式及方法引用中,左边的函数式接口不能声明为 var 123456789//正确写法Comparator&lt;Integer&gt; comparator = (o1, o2) -&gt; Integer.compare(o1, o2);//错误写法var comparator = (o1, o2) -&gt; Integer.compare(o1, o2);//正确写法Consumer&lt;String&gt; consumer = System.out::println;//错误写法var consumer = System.out::println; 更多 JDK10 的新特性描述请参阅 : 官方文档","categories":[],"tags":[{"name":"JDK10","slug":"JDK10","permalink":"http://yoursite.com/tags/JDK10/"}]},{"title":"详解JDK 9中的新特性","slug":"JDK-9新特性详解","date":"2019-08-21T02:15:16.000Z","updated":"2019-08-25T06:31:00.988Z","comments":true,"path":"2019/08/21/JDK-9新特性详解/","link":"","permalink":"http://yoursite.com/2019/08/21/JDK-9新特性详解/","excerpt":"","text":"学习笔记 : 详解JDK 9中的新特性由于 JDK9 中下面两个特性很重要,所有小哥我就单独分开写啦~ 详解JDK 9中的新特性 : JDK 9目录结构的变化及新特性之模块化 详解JDK 9中的新特性 : JDK 9新特性之REPL(JShell) 接口的私有方法Java 8 中规定接口中的方法除了抽象方法之外,还可以定义静态和默认的方法. 一定程度上扩展了接口的功能,此时的接口更像是一个抽象类. 而在 Java 9 中,接口更加的灵活和强大,连方法的访问权限修饰符都可以声明为 private 的了,此时方法将不会成为你对外暴露的 API 的一部分,话说这个语法的改进不应该在 Java 8 中就施行的嘛~ 示例程序如下 :1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.jdk9;import org.junit.Test;//注:其方法的默认权限为public哟interface MyInterface &#123; //jdk 8 public default void defaultMethod() &#123; privateMethod(); System.out.println(\"this is default method\"); &#125; //jdk 8 public static void staticMethod() &#123; System.out.println(\"this is static method\"); &#125; //jdk 9 private void privateMethod() &#123; System.out.println(\"this is private method\"); &#125;&#125;/** * @project: jdk-learnig * @description: 测试JDK8及JDK9中的接口新语法 * @author: 黄宇辉 * @date: 8/21/2019-10:26 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Grammar implements MyInterface &#123; //@Override //public void defaultMethod() &#123; // System.out.println(\"override the default method\"); //&#125; @Test public void test() &#123; MyInterface.staticMethod(); new Grammar().defaultMethod(); &#125;&#125; 程序运行结果如下所示 :123this is static methodthis is private methodthis is default method 钻石操作符的使用升级与匿名实现类共同使用钻石操作符( diamond operator )在 Java 8 中如下的操作是会报错的,编译报错信息 : Cannot use &quot;&lt;&gt;&quot; with anonymous inner classes,在IDEA中将 Language level 调成 Java 9 即可解决编译错误啦123456789101112131415161718192021222324@Testpublic void testComparator() &#123; Comparator&lt;Integer&gt; comparator = new Comparator&lt;&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1, o2); &#125; &#125;; System.out.println(comparator.compare(1, 2));&#125;//简化代码:(JDK8)Lambda表达式写法@Testpublic void testComparatorWithLambda() &#123; Comparator&lt;Integer&gt; comparator = (o1, o2) -&gt; Integer.compare(o1, o2); System.out.println(comparator.compare(1, 2));&#125;//简化代码:(JDK8)方法引用写法@Testpublic void testComparatorWithMethodRef() &#123; Comparator&lt;Integer&gt; comparator = Integer::compare; System.out.println(comparator.compare(1, 2));&#125; 改进的 try-with-resourcs在 Java 7 中可以实现资源的自动关闭,但是要求必须将需要自动关闭的所有资源必须在try子句中进行初始化,否则编译不通过. 而在 Java 9 中可以将需要自动关闭的资源的实例放在 try 的小括号外哟,程序示例如下所示 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//JDK7版本之前释放资源的写法public void testTry() &#123; InputStreamReader reader = null; try &#123; reader = new InputStreamReader(System.in); char[] buffer = new char[50]; int len; if ((len = reader.read(buffer)) != -1) &#123; String s = new String(buffer, 0, len); System.out.println(s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//JDK7版本释放资源的写法public void testTryWithJDK7() &#123; try (InputStreamReader reader = new InputStreamReader(System.in)) &#123; //reader = null; //注意:此时reader已被为设置为常量,既而不能修改 char[] buffer = new char[50]; int len; if ((len = reader.read(buffer)) != -1) &#123; String s = new String(buffer, 0, len); System.out.println(s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;//JDK9版本优化了JDK7释放资源的写法public void testTryWithJDK9() &#123; InputStreamReader reader = new InputStreamReader(System.in); OutputStreamWriter writer = new OutputStreamWriter(System.out);//unused try (reader; writer) &#123; char[] buffer = new char[50]; int len; if ((len = reader.read(buffer)) != -1) &#123; String s = new String(buffer, 0, len); System.out.println(s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; String存储结构的变更从很多不同应用程序收集的信息表明,发现字符串是堆使用的主要组成部分. 而且,大多数字符串对象只包含一个字符,这样的字符只需要一个字节的存储空间,既而导致这些字符串对象的内部char数组中有一半的空间被闲置 JDK9 之前 String 底层使用 char 数组存储数据 private final char value[] JDK9 将 String 底层存储数据改为 byte 数组存储数据 private final byte[] value StringBuffer 和 StringBuilder 也同样做了变更,将以往 char 数组改为 byte 数组 快速创建只读集合JDK9在 List、Set 和 Map 集合中新增 of 静态方法,快速创建只读集合,程序示例如下所示 :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package pers.huangyuhui.jdk9;import org.junit.Test;import java.util.*;/** * @project: jdk-learnig * @description: 快速创建只读集合 * @author: 黄宇辉 * @date: 8/21/2019-1:19 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class CollectionTest &#123; //在JDK9之前创建只读集合 @Test public void test() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); //将List集合设为只读 list = Collections.unmodifiableList(list); System.out.println(list); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(\"E\"); set.add(\"F\"); set.add(\"G\"); //将Set集合设为只读 set = Collections.unmodifiableSet(set); System.out.println(set); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"k1\", \"v1\"); map.put(\"k2\", \"v2\"); map.put(\"k3\", \"v3\"); //将Map集合设为只读 map = Collections.unmodifiableMap(map); System.out.println(map); &#125; //在JDK9中,可以使用of方法直接快速创建只读集合 @Test public void testWithJDK9() &#123; //创建List只读集合 List&lt;String&gt; list = List.of(\"A\", \"B\", \"C\"); System.out.println(list); //创建Set只读集合 Set&lt;String&gt; set = Set.of(\"E\", \"F\", \"G\"); System.out.println(set); //创建List只读集合 Map&lt;String, String&gt; map = Map.of(\"k1\", \"v1\", \"k2\", \"v2\", \"k3\", \"v3\"); System.out.println(map); &#125;&#125; 程序运行结果相同,如下所示 :123[A, B, C][E, F, G]&#123;k1=v1, k2=v2, k3=v3&#125; 增强的 InputStream APIInputStream 终于有了一个非常有用的方法 : transferTo, 可以用来将数据直接传输到 OutputStream,这是在处理原始数据流时非常常见的一种用法,示例代码如下所示 :123456789101112@Testpublic void testTransferTo() throws FileNotFoundException &#123; ClassLoader classLoader = this.getClass().getClassLoader(); InputStream is = classLoader.getResourceAsStream(\"from.txt\"); OutputStream os = new FileOutputStream(\"to.txt\"); try (is; os) &#123; assert is != null; is.transferTo(os); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 增强的 Stream APIJava 的 Stream API 是 Java 标准款最好的改进之一,让开发者能够快速运算,从而能够有效的利用数据并行计算. Java 8 提供的Stream能够利用多核架构实现声明式的数据处理. 而在 Java 9 中,Stream API 变得更好,Stream 接口中添加了4个新方法 ( takeWhile, dropWhile, ofNullable, iterate的重载方法 ), 及为你提供一个 Predicate( 判断条件 )来指定什么时候结束迭代. 除了对 Stream 本身的扩展, Optional 和 Stream 之间的结合也得到了改进,现在可以通过 Optional 的新对象 stream() 来将一个 Optional 对象转换为一个可能为空的 Stream 对象. 程序示例如下所示 :12345678910111213141516171819202122232425262728293031323334353637383940public void testStream() &#123; //takeWhile: 可以用于从Stream中获取一部分数据,接受一个Predicate来进行选择,在有序的Stream中,takeWhile返回从头开始的尽可能多的元素 List&lt;Integer&gt; list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88); list.stream().takeWhile((x) -&gt; x &lt; 80).forEach(System.out::println); //运行结果 : 45 43 76 //从返回结果可以看出:takeWhile将会按照list集合有序的从45开始到第一个不符合条件为止的所有结果 //dropWhile: dropWhile方法刚好与takeWhile想法,返回剩余的元素 List&lt;Integer&gt; list2 = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88); list2.stream().dropWhile((x) -&gt; x &lt; 80).forEach(System.out::println); //运行结果 :87 42 77 90 73 67 88 //从返回结果可以看出:dropWhile方法刚好和takeWhile方法形成互补,按照list集合有序的返回从第一个不满足条件元素开始到最后为止的所有结果 //ofNullable: 在JDK8中Stream不能完全为null,否则会报空指针异常. 而在JDK9中ofNullable方法允许创建一个为空的Stream //Stream&lt;Object&gt; stream1 = Stream.of(null); //System.out.println(stream1.count());//NullPointerException //不报异常,允许这样写 Stream&lt;String&gt; stringStream = Stream.of(\"AA\", \"BB\", null); System.out.println(stringStream.count()); //程序运行结果:3 //不报异常,允许这样写 List&lt;String&gt; list3 = new ArrayList&lt;&gt;(); list3.add(\"A\"); list3.add(null); System.out.println(list3.stream().count()); //程序运行结果:2 //ofNullable():允许值为 null Stream&lt;Object&gt; stream = Stream.ofNullable(null); System.out.println(stream.count()); //程序运行结果:0 Stream&lt;String&gt; stream2 = Stream.ofNullable(\"Hello World\"); System.out.println(stream2.count()); //程序运行结果:1 //iterate()的重载方法 //JDK8 使用iterate方法,需配合limit截止 Stream.iterate(1, (x) -&gt; x + 1).limit(10).forEach(System.out::print); //JDK9 使用iterate的重载方法可以直接使用Predicate来截止 Stream.iterate(1, (x) -&gt; x &lt;= 10, (x) -&gt; x + 1).forEach(System.out::print); //程序运行结果:12345678910&#125; 改进的 Optional 类Optional 类是在JDK8中新增的类,主要是为了解决空指针异常. 在JDK9中对这个类进行了改进,主要是新增了三个方法 : stream, ifPresentOrElse 和 or stream : 将 Optional转为一个 Stream,如果 Optional 没有值就返回一个 Stream.empty ifPresentOrElse : 如果 Optional 包含值,则对其包含的值调用函数 action,即 action.accept(value),这与 ifPresent 一致.与 ifPresent 方法的区别在于 ifPresentOrElse 还有第二个参数 emptyAction. 如果 Optional 不包含值,那么 ifPresentOrElse 便会调用 emptyAction,即 emptyAction.run() or : 如果 Optional 有值,返回 Optional 指定的值,否则返回一个预设的值 全新的 HTTP 客服端 APIJDK9 中有新的方式来处理 HTTP 调用. 它提供了一个新的HTTP客户端(HttpClient),它将替代仅适用于 blocking 模式的HttpURLConnection( HttpURLConnection是在HTTP 1.0的时代创建的,并使用了协议无关的方法 ),并提供对 WebSocket 和 HTTP/2 的支持. 此外,HTTP 客户端还提供 API 来处理 HTTP/2 的特性,比如流和服务器推送等功能. 全新的 HTTP 客户端 API 可以从 jdk.incubator.httpclient 模块中获取. 因为在默认情况下,这个模块是不能根据 classpath 获取的,需要使用add modules命令选项配置这个模块,将这个模块添加到 classpath中 javadoc 的 HTML5 支持JDK8 生成的 java 帮助文档是在 HTML4 中,而HTML4 已经是很久的标准了. JDK9 的 javadoc 现支持HTML5 标准 更多 JDK9 的新特性描述请参阅 : What’s New in JDK9","categories":[],"tags":[{"name":"JDK9","slug":"JDK9","permalink":"http://yoursite.com/tags/JDK9/"}]},{"title":"JDK 9新特性之REPL( JShell )","slug":"JDK-9新特性之REPL-JShell","date":"2019-08-20T10:24:35.000Z","updated":"2019-08-25T06:31:00.985Z","comments":true,"path":"2019/08/20/JDK-9新特性之REPL-JShell/","link":"","permalink":"http://yoursite.com/2019/08/20/JDK-9新特性之REPL-JShell/","excerpt":"","text":"学习笔记 : JDK 9新特性之REPL( JShell )产生背景像 Python 和 Scala之类的语言早就有交互式编程环境 REPL( read-evaluate-print-loop )了,以交互式的方式对语句和表达式进行求值,开发者只需要输入一些代码,就可以在编译前获得对程序的反馈. 而之前的 Java 版本想要执行代码,必须创建文件,声明类,提供测试方法才可以实现,而现在使用 JShell( 既写既的,快速运行 ) 就可以摆脱这种困扰咯~ 实现目标 Java9 终于拥有了 REPL 工具 JShell : 既而可以让 Java 可以像脚本语言一样运行,从控制台启动 JShell,利用 JShell 在没有创建类的情况下直接声明变量,计算表达式,执行语句. 既开发时可以在命令行里直接运行Java的代码,而无需再创建 Java 文件,无需再使用 public static void main(String[]args)这句废话 JShell 也可以从文件中加载语句或将语句保存到文件中 JShell 也可以是 tab 键进行自动补全和自动添加分号 基本使用JShell 中的命令和代码片段是不一样的,命令都是以前导的反斜杠 / 开头,比如要显示所有已经定义的变量,可以使用 /var, 要显示所有已经定义的方法,可以使用 /methods,要显示所有已经定义的类型,可以使用 /types, 要显示所有输入的代码片段,可以使用 /list · · · 进入JShell命令行环境 :123456C:\\Users\\Administratorλ jshell| Welcome to JShell -- Version 11.0.2| For an introduction type: /help introjshell&gt; 输入/help可以查看 JShell 相关的命令 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263jshell&gt; /help | Type a Java language expression, statement, or declaration. | Or type one of the following commands: | /list [&lt;name or id&gt;|-all|-start] | list the source you have typed | /edit &lt;name or id&gt; | edit a source entry | /drop &lt;name or id&gt; | delete a source entry | /save [-all|-history|-start] &lt;file&gt; | Save snippet source to a file | /open &lt;file&gt; | open a file as source input | /vars [&lt;name or id&gt;|-all|-start] | list the declared variables and their values | /methods [&lt;name or id&gt;|-all|-start] | list the declared methods and their signatures | /types [&lt;name or id&gt;|-all|-start] | list the type declarations | /imports | list the imported items | /exit [&lt;integer-expression-snippet&gt;] | exit the jshell tool | /env [-class-path &lt;path&gt;] [-module-path &lt;path&gt;] [-add-modules &lt;modules&gt;] ... | view or change the evaluation context | /reset [-class-path &lt;path&gt;] [-module-path &lt;path&gt;] [-add-modules &lt;modules&gt;]... | reset the jshell tool | /reload [-restore] [-quiet] [-class-path &lt;path&gt;] [-module-path &lt;path&gt;]... | reset and replay relevant history -- current or previous (-restore) | /history [-all] | history of what you have typed | /help [&lt;command&gt;|&lt;subject&gt;] | get information about using the jshell tool | /set editor|start|feedback|mode|prompt|truncation|format ... | set configuration information | /? [&lt;command&gt;|&lt;subject&gt;] | get information about using the jshell tool | /! | rerun last snippet -- see /help rerun | /&lt;id&gt; | rerun snippets by ID or ID range -- see /help rerun | /-&lt;n&gt; | rerun n-th previous snippet -- see /help rerun | | For more information type &apos;/help&apos; followed by the name of a | command or a subject. | For example &apos;/help /list&apos; or &apos;/help intro&apos;. | | Subjects: | | intro | an introduction to the jshell tool | id | a description of snippet IDs and how use them | shortcuts | a description of keystrokes for snippet and command completion, | information access, and automatic code generation | context | a description of the evaluation context options for /env /reload and /reset | rerun | a description of ways to re-evaluate previously entered snippets jshell&gt; JShell 命令的自动补全功能 :1234567jshell&gt; //! /? /drop /edit /env /exit /help /history /imports/list /methods /open /reload /reset /save /set /types /vars&lt;press tab again to see synopsis&gt;jshell&gt; / System.out.后按下 Tab 键,就会列出当前类的所有的 public 方法的列表哟123456jshell&gt; System.out.append( checkError() close() equals( flush() format( getClass()hashCode() notify() notifyAll() print( printf( println( toString()wait( write(jshell&gt; 实例 : 在 JShell 中使用 Stream 流过滤并遍历输出数组元素 :12345678jshell&gt; public void streamDemo()&#123; ...&gt; String[]array = &#123;&quot;a&quot;,&quot;bc&quot;,&quot;bcd&quot;,&quot;abcd&quot;&#125;; ...&gt; Stream.of(array).filter(e-&gt;e.startsWith(&quot;a&quot;)).filter(e-&gt;e.length()&gt;3).forEach(System.out::println); ...&gt; &#125;| created method streamDemo()jshell&gt; streamDemo();abcd 例如使用/imports命令用于查看已导入的包 :12345678910111213jshell&gt; /imports| import java.io.*| import java.math.*| import java.net.*| import java.nio.file.*| import java.util.*| import java.util.concurrent.*| import java.util.function.*| import java.util.prefs.*| import java.util.regex.*| import java.util.stream.*jshell&gt; 列出到目前为止当前 session 里所有有效的代码片段 :12345678910111213jshell&gt; /list 1 : System.out.println(&quot;demo&quot;); 2 : public void streamDemo()&#123; String[]array = &#123;&quot;a&quot;,&quot;bc&quot;,&quot;bcd&quot;,&quot;abcd&quot;&#125;; Stream.of(array) .filter(e-&gt;e.startsWith(&quot;a&quot;)) .filter(e-&gt;e.length()&gt;3) .forEach(System.out::println); &#125; 3 : streamDemo();jshell&gt; 列出到目前为止当前 session 里所有方法 :12jshell&gt; /method| void StreamDemo() 在 JShell 中可以启用 JShell Edit Pad 编辑器来写更加便捷地书写 Java 代码,只需要输入命令/edit,代码编辑完成后,先点击”Accept”按钮,再点击”Exit”按钮,继而退出编辑器 调用已修改的程序,其运行结果如下所示 :1234567891011jshell&gt; /edit| created method streamDemo()jshell&gt; /edit| modified method streamDemo()| update overwrote method streamDemo()jshell&gt; streamDemo();2jshell&gt; JShell Edit Pad 编辑器功能非常有限,仅能提供一些最基础的功能,不过好消息是 JShell 可以配置外部的代码编辑器,只需要使用 /edit 设置外部编辑器的完整路径即可,例如使用 VS Code 来作为外部的代码编辑器12jshell&gt; /set editor /Visual Studio Code/Microsoft VS Code/Code.exe| Editor set to: /Visual Studio Code/Microsoft VS Code/Code.exe 从外部加载源代码 : 如果在外部已经有写好的 Java 文件,则可以使用 /open 命令导入到 JShell 环境中,例如现在有一个Test.java文件12345678910jshell&gt; /open /Java/Test.javajshell&gt; /methods| int add(int,int)| int sub(int,int)jshell&gt; add(1,2);$5 ==&gt; 3jshell&gt; JShell 命令缩写,例如 /list 的缩写为 /l,例如 /list -all 的缩写为 /l -a. 例如,我们可以使用 /l -a 来代替 list -all 输出所有的代码片段 :1234567891011121314151617181920212223242526272829303132333435363738394041jshell&gt; /l -a s1 : import java.io.*; s2 : import java.math.*; s3 : import java.net.*; s4 : import java.nio.file.*; s5 : import java.util.*; s6 : import java.util.concurrent.*; s7 : import java.util.function.*; s8 : import java.util.prefs.*; s9 : import java.util.regex.*; s10 : import java.util.stream.*; 1 : System.out.println(&quot;demo&quot;); 2 : public void StreamDemo()&#123; String[]array = &#123;&quot;a&quot;,&quot;bc&quot;,&quot;bcd&quot;,&quot;abcd&quot;&#125;; Stream.of(array) .filter(e-&gt;e.startsWith(&quot;a&quot;)) .filter(e-&gt;e.length()&gt;3) .forEach(System.out::println); &#125; 3 : StreamDemo(); 4 : public void streamDemo() &#123; String[] array = &#123;&quot;a&quot;, &quot;bc&quot;, &quot;abc&quot;, &quot;bcd&quot;, &quot;abcd&quot;&#125;; long count = Stream.of(array) .filter(element -&gt; element.startsWith(&quot;a&quot;)) .filter(element -&gt; element.length()&gt;3) .count(); System.out.println(count); &#125; 5 : public void streamDemo() &#123; String[] array = &#123;&quot;a&quot;, &quot;bc&quot;, &quot;abc&quot;, &quot;bcd&quot;, &quot;abcd&quot;, &quot;abcde&quot;&#125;; long count = Stream.of(array) .skip(1) .filter(element -&gt; element.startsWith(&quot;a&quot;)) .filter(element -&gt; element.length()&gt;3) .count(); System.out.println(count); &#125; 6 : streamDemo(); jshell&gt; 退出 JShell12jshell&gt; /exit| Goodbye 更多 JShell 的详细介绍请参考 : 官方介绍文档","categories":[],"tags":[{"name":"JDK9","slug":"JDK9","permalink":"http://yoursite.com/tags/JDK9/"}]},{"title":"JDK 9目录结构的变化及新特性之模块化","slug":"JDK-9目录结构的变化及新特性之模块化","date":"2019-08-20T08:21:13.000Z","updated":"2019-08-25T06:31:00.988Z","comments":true,"path":"2019/08/20/JDK-9目录结构的变化及新特性之模块化/","link":"","permalink":"http://yoursite.com/2019/08/20/JDK-9目录结构的变化及新特性之模块化/","excerpt":"","text":"学习笔记 : JDK 9目录结构的变化及新特性之模块化目录结构JDK 9( JDK 9以后的版本 )的具体目录结构如下所示 : bin : 该目录包含所有的命令 conf : 包含用户可以编辑的配置文件,例如以前位于jre\\lib 目录中的 .properties 和 .policy 文件 include : 包含一些编译本地代码时使用的C/C++头文件 jmods : 包含JMOD 格式的平台模块,创建自定义运行映射时需要它 legal : 包含法律声明 lib : 包含非 Windows 平台上动态链接的本地库,其子目录和文件不应由开发人员直接编辑或使用 注 : JDK9 目录中不再有jre子目录 模块化系统Java 9最大的变化之一是引入了模块系统( Jigsaw 项目 ),主要原因是Java和相关生态在不断丰富的同时越来越暴露一些问题 : Java 运行环境的膨胀和臃肿. 每次加载 JVM 启动时,至少会有 30 ~ 60MB 内存加载,主要原因是JVM需要加载rt.jar,不管其中的类是否被 classloader 加载,第一步整个 jar 都会被 JVM 加载到内存当中去( 而模块化可以根据模块的需要加载程序运行需要的class ) 当代码库越来越大,创建复杂,盘根错节的”意大利面条式代码”的几率呈指数级的增长, 不同版本的类库交叉依赖导致让人头疼的问题,这些都是阻碍了 Java 开发和运行效率的提升 很难真正地对代码进行封装,而系统并没有对不同部分( 也就是JAR文件 ) 之间的依赖关系有个明确的概念,每一个公共类都可以被类路径之下任何其它的公共类访问到,这样就会导致无意中使用了并不想被公开访问的 API 模块化的概念 : 模块( 代码和数据的封装体 )的概念其实就是package外再包裹一层,用模块来管理各个package,使得代码组织上更加安全,因为他可以指定哪些部分可以暴露,哪些部分可以隐藏 模块化的特性 : Java9 模块的重要特征是在其工件 (artifact) 的根目录中包含了一个描述模块的 module-info.class 文件,这个文件由根目录中的源代码文件 module-info.java 编译而来,该模块声明文件可以描述模块的不同特征. JDK 9将 JDK 分成一组模块,可以在编译时,运行时或构建时进行组合. 模块化可以减少内存开销,只需必要的模块,并非全部模块,既而可以简化各种类库和大型应用的开发和维护 实例 模块目录结构如下所示( 有两个名称分别为modela, modelb的模块 ) : modela模块中的module-info.java : 123module modela &#123; exports com.cnblogs.bean;&#125; modelb模块中的module-info.java : 123module modelb &#123; requires modela;&#125; modelb模块中的Test.java : 1234567891011package com.cnblogs.tset; import com.cnblogs.bean.Person; public class Test &#123; public static void main(String[] args) &#123; Person person = new Person(\"jdk9\",2); System.out.println(person); &#125; &#125; 程序运行结果 : 1Person&#123;name=&apos;jdk9&apos;, age=2&#125; 如上示例,如果需要在modelb模块项目中使用modela模块项目的内容,必须在modela项目的module-info.java中定义exports com.cnblogs.bean将该目录下可以被其他模块使用,如果没有写,则包默认是封装在模块下,不被外界使用. 而在modela项目中需要使用requires modela导入需要使用的模块名,则可以在modelb中使用modela定义exports的类 (即而才可以在Test类中使用Person类) module-info.java : 该文件必须位于项目的根目录中. 该文件用于定义模块需要什么依赖,以及那些包被外部使用 exports : 控制着那些包可以被其他模块访问到,所有不被exports的包默认都被封装在模块里面不被外界所使用 requires : 指明对其他模块的依赖 参考博客 : 《JDK9 新特性》 更多新特性详细信息请参阅 : What’s New in JDK9","categories":[],"tags":[{"name":"JDK9","slug":"JDK9","permalink":"http://yoursite.com/tags/JDK9/"}]},{"title":"JDK 9新特性概述","slug":"JDK-9新特性概述","date":"2019-08-20T01:01:19.000Z","updated":"2019-08-25T06:31:00.987Z","comments":true,"path":"2019/08/20/JDK-9新特性概述/","link":"","permalink":"http://yoursite.com/2019/08/20/JDK-9新特性概述/","excerpt":"","text":"学习笔记 : JDK 9新特性概述简介⏳ 来看一下Java成立到Java 9版本发布的时间线吧,不得不说比我还大三岁哟~ 1990年初, 最初被命名为Oak 1995年5月23日, Java语言诞生 1996年1月, 第一个JDK-JDK1.0诞生 1996年4月, 10个最主要的操作系统供应商申明将在其产品中嵌入Java技术 1996年9月, 约8.3万个网页应用了Java技术来制作 1997年2月18日, JDK1.1发布 1997年4月2日, JavaOne会议召开, 参与者逾一万人, 创当时全球同类会议纪录 1997年9月, JavaDeveloperConnection 社区成员超过十万 1998年2月, JDK1.1被下载超过2,000,000次 1998年12月8日, Java 2企业平台J2EE发布 1999年6月, SUN公司发布Java三个版本 : 标准版(J2SE)、企业版(J2EE)和微型版(J2ME) 2000年5月8日, JDK1.3发布 2000年5月29日, JDK1.4发布 2001年6月5日, Nokia宣布到2003年将出售1亿部支持Java的手机 2001年9月24日, J2EE1.3发布 2002年2月26日, J2SE1.4发布, 此后Java的计算能力有了大幅提升 2004年9月30日, J2SE1.5发布, 成为Java语言发展史上的又一里程碑. 为了表示该版本的重要性, J2SE1.5更名为Java SE 5.0 2005年6月, JavaOne大会召开, SUN公司公开Java SE 6. 此时Java的各种版本已经更名, 以取消其中的数字”2” : J2EE更名为Java EE,J2SE更名为Java SE, J2ME更名为Java ME 2006年12月, SUN公司发布JRE6.0 2009年4月20日, 甲骨文以74亿美元的价格收购SUN公司, 取得java的版权, 业界传闻说这对Java程序员是个坏消息(其实恰恰相反) 2010年11月, 由于甲骨文对Java社区的不友善,因此Apache扬言将退出JCP 2011年7月28日, 甲骨文发布Java SE 7 2014年3月18日, 甲骨文发表Java SE 8 2017年7月, 甲骨文发表Java SE 9, 其带来了很多新特性, 其中最主要的变化是已经实现的模块化系统 JDK 9新特新 模块系统 : 模块是一个包的容器,Java 9 最大的变化之一是引入了模块系统(Jigsaw 项目) REPL (JShell) : 交互式编程环境 HTTP 2 客户端 : HTTP/2标准是HTTP协议的最新版本,新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性 改进的 Javadoc : Javadoc 现在支持在 API 文档中的进行搜索,另外Javadoc 的输出现在符合兼容 HTML5 标准 多版本兼容 JAR 包 : 多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本 集合工厂方法 : List,Set 和 Map 接口中,新的静态工厂方法可以创建这些集合的不可变实例 私有接口方法 : 在接口中使用private私有方法,我们可以使用 private 访问修饰符在接口中编写私有方法 进程 API : 改进的 API 来控制和管理操作系统进程. 引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境 改进的 Stream API : 改进的 Stream API 添加了一些便利的方法,使流处理更容易,并使用收集器编写复杂的查询 改进 try-with-resources : 如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量,而无需在 try-with-resources 语句中声明一个新变量 改进的弃用注解 @Deprecated : 注解 @Deprecated 可以标记 Java API 状态,可以表示被标记的 API 将会被移除,或者已经破坏 改进钻石操作符(Diamond Operator) : 匿名类可以使用钻石操作符(Diamond Operator) 改进 Optional 类 : java.util.Optional 添加了很多新的有用方法,Optional 可以直接转为 stream 多分辨率图像 API : 定义多分辨率图像API,开发者可以很容易的操作和展示不同分辨率的图像了 改进的 CompletableFuture API : CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作 轻量级的 JSON API : 内置了一个轻量级的JSON API 响应式流(Reactive Streams) API : Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程 更多的新特性描述请参阅 : What’s New in JDK9","categories":[],"tags":[{"name":"JDK9","slug":"JDK9","permalink":"http://yoursite.com/tags/JDK9/"}]},{"title":"JDK 8新特性之默认方法的基本使用","slug":"JDK-8新特性之默认方法的基本使用","date":"2019-08-19T12:41:39.000Z","updated":"2019-08-25T06:31:00.985Z","comments":true,"path":"2019/08/19/JDK-8新特性之默认方法的基本使用/","link":"","permalink":"http://yoursite.com/2019/08/19/JDK-8新特性之默认方法的基本使用/","excerpt":"","text":"学习笔记 : JDK 8新特性之默认方法的基本使用简介Java 8 新增了接口的默认方法,简单点说既默认方法就是接口可以有实现方法,而且不需要实现类去实现其方法. 我们只需在方法名前面加个 default 关键字即可实现默认方法的定义哟~ 那为什么要引入这个特性呢 ? 解答如下 :1234567891011121314首先,之前的接口是个双刃剑,好处是面向抽象而不是面向具体编程. 缺陷是当需要修改接口时候,需要修改全部实现该接口的类,目前的 java 8 之前的集合框架没有 foreach 方法,通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现. 然而,对于已经发布的版本,是没法在给接口添加新方法的同时不影响已有的实现. 所以引进的默认方法,他们的目的是为了解决接口的修改与现有的实现不兼容的问题``` *接口默认方法的`类优先`原则 : 若一个接口中定义了一个默认方法,而另一个父类或接口中又定义了一个同名的方法时,可分为情况 :** 选择父类中的方法 : 如果一个父类提供了具体的实现,那么接口中具有相同名称和参数的默认方法会被忽略* 接口冲突 : 如果一个父接口提供了一个默认方法,而另一个接口也提供了一个具有相同名称和参数列表的方法( 不管方法是否为默认方法 ),那么必须覆盖该方法来解决冲突*语法格式如下所示 :*```javapublic interface Vehicle &#123; default void print()&#123; System.out.println(&quot;this is a car&quot;); &#125;&#125; 多个默认方法一个接口有默认方法,考虑这样的情况,一个类实现了多个接口,且这些接口有相同的默认方法,以下实例说明了这种情况的解决方法 :1234567891011public interface Vehicle &#123; default void print()&#123; System.out.println(\"this is a car\"); &#125;&#125; public interface FourWheeler &#123; default void print()&#123; System.out.println(\"this is a brougham\"); &#125;&#125; 第一个解决方案是创建自己的默认方法,来覆盖重写接口的默认方法 :12345public class Car implements Vehicle, FourWheeler &#123; default void print()&#123; System.out.println(\"this is a motorcycle\"); &#125;&#125; 第二种解决方案可以使用 super 来调用指定接口的默认方法 :12345public class Car implements Vehicle, FourWheeler &#123; public void print()&#123; Vehicle.super.print(); &#125;&#125; 静态默认方法Java 8 的另一个特性是接口可以声明( 并且可以提供实现 )静态方法,例如 :123456789public interface Vehicle &#123; default void print()&#123; System.out.println(\"this is a car\"); &#125; static void blowHorn()&#123; System.out.println(\"sound the horn\"); &#125;&#125; 默认方法实例通过以下代码来了解下关于默认方法的使用吧~12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.jdk8.method;import org.junit.Test;interface Vehicle &#123; default void print() &#123; System.out.println(\"this is a car\"); &#125; static void blowHorn() &#123; System.out.println(\"sound the horn\"); &#125;&#125;interface FourWheeler &#123; default void print() &#123; System.out.println(\"this is a brougham\"); &#125;&#125;class Car implements Vehicle, FourWheeler &#123; public void print() &#123; Vehicle.super.print(); FourWheeler.super.print(); Vehicle.blowHorn(); System.out.println(\"this is a motorcycle\"); &#125;&#125;/** * @project: jdk-learnig * @description: 默认方法实例 * @author: 黄宇辉 * @date: 8/19/2019-9:11 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class DefaultMethod &#123; @Test public void test() &#123; Vehicle vehicle = new Car(); vehicle.print(); &#125;&#125; 程序运行结果如下所示 :1234this is a carthis is a broughamsound the hornthis is a motorcycle 参考 《Java 8 默认方法》 : https://www.runoob.com/java/java8-default-methods.html","categories":[],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://yoursite.com/tags/JDK8/"}]},{"title":"JDK 8新特性之Optional类的基本使用","slug":"JDK-8新特性之Optional类的基本使用","date":"2019-08-19T09:59:44.000Z","updated":"2019-08-25T06:31:00.983Z","comments":true,"path":"2019/08/19/JDK-8新特性之Optional类的基本使用/","link":"","permalink":"http://yoursite.com/2019/08/19/JDK-8新特性之Optional类的基本使用/","excerpt":"","text":"学习笔记 : JDK 8新特性之Optional类的基本使用简介到目前为止,臭名昭著的空指针异常是导致Java应用程序失败的最常见原因. 以前为了解决空指针异常,Google公司著名的Guava项目引入了Optional类,Guava通过使用检查空值的方法来防止代码受污染,它鼓励程序员写更干净的代码~ 受到Google Guava的启发,Option类已经成为Java 8类库的一部分. java.util.Optional&lt;T&gt;是一个容器类,它可以保存类型为T的值,代表这个值存在. 或者仅仅保存null,表示这个值不存在. 原来用null表示一个值不存在,现在Optional可以更好的表达这个概念,并且可以避免空指针异常~ Optional类的javadoc对其的描述为 : 这是一个可以为null的容器对象,如果值存在则isPresent()方法会返回true,调用get()方法会返回该对象 类方法 static &lt;T&gt; Optional&lt;T&gt; empty() : 返回空的 Optional 实例 boolean equals(Object obj) : 判断其他对象是否等于 Optional Optional&lt;T&gt; filter(Predicate&lt;? super &lt;T&gt; predicate) : 如果值存在,并且这个值匹配给定的 predicate,返回一个Optional用以描述这个值,否则返回一个空的Optional &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper) : 如果值存在,返回基于Optional包含的映射方法的值,否则返回一个空的Optional T get() : 如果在这个Optional中包含这个值,返回值,否则抛出异常:NoSuchElementException int hashCode() : 返回存在值的哈希码,如果值不存在则返回 0 void ifPresent(Consumer&lt;? super T&gt; consumer) : 如果值存在则使用该值调用 consumer,否则不做任何事情 boolean isPresent() : 如果值存在则方法会返回true,否则返回 false &lt;U&gt;Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper) : 如果有值,则对其执行调用映射函数得到返回值. 如果返回值不为 null,则创建包含映射返回值的Optional作为map方法返回值,否则返回空Optional static &lt;T&gt; Optional&lt;T&gt; of(T value) : 返回一个指定非null值的Optional static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) : 如果为非空,返回 Optional 描述的指定值,否则返回空的 Optional T orElse(T other) : 如果存在该值,返回值,否则返回 other T orElseGet(Supplier&lt;? extends T&gt; other) : 如果存在该值,返回值,否则触发 other,并返回 other 调用的结果 &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) : 如果存在该值,返回包含的值，否则抛出由 Supplier 继承的异常 String toString() : 返回一个Optional的非空字符串,用来调试","categories":[],"tags":[{"name":"JDK 8","slug":"JDK-8","permalink":"http://yoursite.com/tags/JDK-8/"}]},{"title":"Stream流基本使用的综合案例","slug":"Stream流基本使用的综合案例","date":"2019-08-19T05:27:27.000Z","updated":"2019-08-25T06:31:01.062Z","comments":true,"path":"2019/08/19/Stream流基本使用的综合案例/","link":"","permalink":"http://yoursite.com/2019/08/19/Stream流基本使用的综合案例/","excerpt":"","text":"学习笔记 : Stream流基本使用的综合案例题目现有两个ArrayList集合分别存储着若干个元素,要求 : 一使用传统的for循环 / 增强for循环依次进行以下若干操作步骤, 二使用Stream流的方式依次进行以下若干操作步骤,相信最后你定会体会到Stream的美 (✪ω✪)~ 第一个集合只要包含’E’字符的元素,并将其存储到一个新集合中 第一个集合筛选之后只要前3个元素,并将其存储到新集合中 第二个集合只要包含’K’字符的元素,并将其存储到新集合中 第二个集合筛选之后不要前2两个元素,并将其存储到一个新集合中 将两个集合合并成一个集合,并存储到一个新集合中 根据合并后的集合中的元素值创建Element对象,并将其存储到新集合中 打印整个集合的Element对象信息 解答传统方式的代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package pers.huangyuhui.jdk8.Stream;import org.junit.Test;import java.util.ArrayList;import java.util.List;//定义Element类class Element &#123; private String name; public Element(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Element&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125;/** * @project: jdk-learnig * @description: 传统方式的代码实现 * @author: 黄宇辉 * @date: 8/19/2019-1:32 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Eaxmple &#123; @Test public void testExample() &#123; //A集合 List&lt;String&gt; alist = new ArrayList&lt;&gt;(); alist.add(\"ABC\"); alist.add(\"BCD\"); alist.add(\"CDE\"); alist.add(\"DEF\"); alist.add(\"EFG\"); alist.add(\"EEE\"); //1.第一个集合只要包含'E'字符的元素,并将其存储到一个新集合中 List&lt;String&gt; alistA = new ArrayList&lt;&gt;(); for (String s : alist) &#123; if (s.contains(\"E\")) &#123; alistA.add(s); &#125; &#125; //2.第一个集合筛选之后只要前3个元素,并将其存储到新集合中 List&lt;String&gt; alistB = new ArrayList&lt;&gt;(); for (String s : alistA) &#123; if (alistB.size() != 3) &#123; alistB.add(s); //[CDE, DEF, EFG] &#125; &#125; //B集合 List&lt;String&gt; blist = new ArrayList&lt;&gt;(); blist.add(\"HIJ\"); blist.add(\"IJK\"); blist.add(\"JKL\"); blist.add(\"KLM\"); blist.add(\"KKK\"); //3.第二个集合只要包含'K'字符的元素,并将其存储到新集合中 List&lt;String&gt; blistA = new ArrayList&lt;&gt;(); for (String s : blist) &#123; if (s.contains(\"K\")) &#123; blistA.add(s); &#125; &#125; //4.第二个集合筛选之后不要前2两个元素,并将其存储到一个新集合中 List&lt;String&gt; blistB = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; blistA.size(); i++) &#123; blistB.add(blistA.get(i)); //[KLM, KKK] &#125; //5.将两个集合合并成一个集合,并存储到一个新集合中 List&lt;String&gt; abList = new ArrayList&lt;&gt;(); abList.addAll(alistB); abList.addAll(blistB); //6.根据合并后的集合中的元素值创建Element对象,并将其存储到新集合中 List&lt;Element&gt; pList = new ArrayList&lt;&gt;(); for (String s : abList) &#123; pList.add(new Element(s)); &#125; //7.打印整个集合的Element对象信息 for (Element element : pList) &#123; System.out.println(element.toString()); &#125; &#125;&#125; 程序运行结果如下 :12345Person&#123;name=&apos;CDE&apos;&#125;Person&#123;name=&apos;DEF&apos;&#125;Person&#123;name=&apos;EFG&apos;&#125;Person&#123;name=&apos;KLM&apos;&#125;Person&#123;name=&apos;KKK&apos;&#125; 使用Stream流的代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package pers.huangyuhui.jdk8.Stream;import org.junit.Test;import java.util.ArrayList;import java.util.List;import java.util.stream.Stream;//定义Element类class Element &#123; private String value; public Element(String value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Element&#123;\" + \"value='\" + value + '\\'' + '&#125;'; &#125;&#125;/** * @project: jdk-learnig * @description: 使用Stream流的代码实现 * @author: 黄宇辉 * @date: 8/19/2019-3:57 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Example &#123; @Test public void testWithStream() &#123; //A集合 List&lt;String&gt; alist = new ArrayList&lt;&gt;(); alist.add(\"ABC\"); alist.add(\"BCD\"); alist.add(\"CDE\"); alist.add(\"DEF\"); alist.add(\"EFG\"); alist.add(\"EEE\"); //1.第一个集合只要包含'E'字符的元素,并将其存储到一个新集合中 //2.第一个集合筛选之后只要前3个元素,并将其存储到新集合中 Stream&lt;String&gt; streamA = alist.stream() .filter(value -&gt; value.contains(\"E\")) .limit(3); //B集合 List&lt;String&gt; blist = new ArrayList&lt;&gt;(); blist.add(\"HIJ\"); blist.add(\"IJK\"); blist.add(\"JKL\"); blist.add(\"KLM\"); blist.add(\"KKK\"); //3.第二个集合只要包含'K'字符的元素,并将其存储到新集合中 //4.第二个集合筛选之后不要前2两个元素,并将其存储到一个新集合中 Stream&lt;String&gt; streamB = blist.stream() .filter(value -&gt; value.contains(\"K\")) .skip(2); //5.将两个集合合并成一个集合,并存储到一个新集合中 //6.根据合并后的集合中的元素值创建Element对象,并将其存储到新集合中 //7.打印整个集合的Element对象信息 Stream.concat(streamA, streamB) .map(Element::new) //.map(value -&gt; new Element(value)) .forEach(System.out::println); &#125;&#125; 程序运行结果如下 :12345Element&#123;value=&apos;CDE&apos;&#125;Element&#123;value=&apos;DEF&apos;&#125;Element&#123;value=&apos;EFG&apos;&#125;Element&#123;value=&apos;KLM&apos;&#125;Element&#123;value=&apos;KKK&apos;&#125;","categories":[],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://yoursite.com/tags/JDK8/"}]},{"title":"JDK 8新特性之Stream流的基本使用","slug":"JDK-8新特性之Stream流的基本使用","date":"2019-08-18T13:09:29.000Z","updated":"2019-08-25T06:31:00.983Z","comments":true,"path":"2019/08/18/JDK-8新特性之Stream流的基本使用/","link":"","permalink":"http://yoursite.com/2019/08/18/JDK-8新特性之Stream流的基本使用/","excerpt":"","text":"学习笔记 : JDK 8新特性之Stream流的基本使用简介Java 8 API添加了一个新的抽象称为Stream流,其让你以一种声明的方式处理数据. Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象. 其 API 可以极大提高Java程序员的生产力,让程序员写出高效率、干净、简洁的代码. 其把将要处理的元素集合看作一种流, 流在管道中传输, 并且可以在管道的节点上进行处理, 比如筛选,排序,聚合等, 元素流在管道中经过中间操作 (intermediate operation) 的处理,最后由最终操作 (terminal operation) 得到前面处理的结果 123+--------------------+ +------+ +------+ +---+ +-------+| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|+--------------------+ +------+ +------+ +---+ +-------+ 以上的流程可以转换Java代码 :123456List&lt;Integer&gt; transactionsIds = widgets.stream() .filter(b -&gt; b.getColor() == RED) .sorted((x,y) -&gt; x.getWeight() - y.getWeight()) .mapToInt(Widget::getWeight) .sum(); 特征Stream (流) 是一个来自数据源的元素队列并支持聚合操作 : 元素是特定类型的对象,形成一个队列. Java中的Stream并不会存储元素,而是按需计算 数据源,流的来源可以是集合,数组,I/O channel,产生器generator等 聚合操作,类似SQL语句一样的操作,比如filter, map, reduce, find, match, sorted等 和以前的Collection操作不同， Stream操作还有如下两个基础的特征 : Pipelining : 中间操作都会返回流对象本身, 这样多个操作可以串联成一个管道,如同流式风格(fluent style), 这样做可以对操作进行优化,比如延迟执行(laziness)和短路(short-circuiting) 内部迭代 : 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代,这叫做外部迭代. Stream则提供了内部迭代的方式,通过访问者模式(Visitor)实现 当使用一个流的时候,通常包括三个基本步骤 : 获取一个数据源(source) -&gt; 数据转换 -&gt; 执行操作获取想要的结果,每次转换原有 Stream 对象不改变,返回一个新的 Stream 对象(可以有多次转换),这就允许对其操作可以像链条一样排列,变成一个管道. 注 : Steam流属于管道流,既只能被消费/使用一次哟 获取Stream流的方式java.util.stream.Stream&lt;T&gt;是Java8新加入的最常用的流接口 (注 : 这并不是一个函数式接口哟),获取一个流非常简单,有以下几种常用的方式 : 所有的Collection集合都可以通过stream默认方法获取流 通过Stream接口的静态方法of可以获取数组对应的流 Stream流的常用方法Stream流模型的操作很丰富,其方法可以划分为两类 : 延迟方法 : 返回值类型仍然是Stream接口自身类型的方法,因此支持链式调用( 除了终结方法外,其余方法均为延迟方法 ) 终结方法 : 返回值类型不再是Stream接口自身类型的方法,因此不再支持类似StringBuilder那样的链式调用,终结方法例如count和forEach 程序示例(对比)话不多说,来对比一下传统遍历并过滤集合与使用Stream流遍历并过滤集合的代码,感受下Stream流的美~1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package pers.huangyuhui.Stream;import org.junit.Test;import java.util.ArrayList;import java.util.List;/** * @project: jdk-learnig * @description: 使用Stream流遍历并过滤集合 * @author: 黄宇辉 * @date: 8/18/2019-9:10 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class StreamTest &#123; //传统方式:遍历并过滤集合 @Test public void test() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"bc\"); list.add(\"abc\"); list.add(\"bcd\"); list.add(\"abcd\"); //元素内容过滤 List&lt;String&gt; list_a = new ArrayList&lt;&gt;(); for (String s : list) &#123; if (s.startsWith(\"a\")) &#123; list_a.add(s); &#125; &#125; //元素长度过滤 List&lt;String&gt; list_len = new ArrayList&lt;&gt;(); for (String s : list_a) &#123; if (s.length() &gt; 3) &#123; list_len.add(s); &#125; &#125; //打印集合元素 for (String s : list_len) &#123; System.out.println(s); //结果:abcd &#125; &#125; //使用Steam流:遍历并过滤集合 @Test public void testWithStream() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"bc\"); list.add(\"abc\"); list.add(\"bcd\"); list.add(\"abcd\"); //过滤集合元素后输出 list.stream() .filter(name -&gt; name.startsWith(\"a\")) //元素内容过滤 .filter(name -&gt; name.length() &gt; 3) //元素长度过滤 //.forEach(name -&gt; System.out.println(name)); .forEach(System.out::println); //结果:abcd &#125;&#125; 获取Stream流的两种方式获取流的两种方式 : 一将集合装换为Stream流, 二将数组转换为Stream流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package pers.huangyuhui.Stream;import java.util.*;import java.util.stream.Stream;/** * @project: jdk-learnig * @description: 获取流的两种方式:将集合装换为Stream流,及将数组转换为Stream流 * @author: 黄宇辉 * @date: 8/19/2019-8:30 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class GetStreamWay &#123; //将List集合装换为Stream流 public void testList() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); &#125; //将Set集合转换为Stream流 public void testSet() &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream = set.stream(); &#125; //将Map集合转换为Stream流 public void testMap() &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); //分别获取并存储键与值 Set&lt;Integer&gt; integers = map.keySet(); Collection&lt;String&gt; values = map.values(); //将存储键与值的集合转换为Stream流 Stream&lt;Integer&gt; key = integers.stream(); Stream&lt;String&gt; value = values.stream(); //获取键值对(键与值映射关系),并将其转换为Stream流 Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet(); Stream&lt;Map.Entry&lt;Integer, String&gt;&gt; entry = entries.stream(); &#125; //将数组转换为Stream流 public void testArray() &#123; String[] array = &#123;\"a\", \"ab\", \"bc\", \"abc\", \"bcd\", \"abcd\"&#125;; Stream&lt;String&gt; stream = Stream.of(array); &#125; // ······&#125; forEach方法该方法接收一个Consumer接口函数,会将每一个流元素交给该函数进行处理1void forEach(Consumer&lt;? super T&gt; action); 复习Consumer接口此前已学过java.util.function.Consumer&lt;T&gt;函数式接口,该接口是一个消费型接口,其中唯一的抽象方法如下,意为消费一个指定泛型的数据1void accept(T t); 基本使用遍历输出数组中的元素123456789101112@Testpublic void testForEach() &#123; String[] array = &#123;\"a\", \"bc\", \"abc\", \"bcd\", \"abcd\"&#125;; //第一种方式 Stream&lt;String&gt; stream = Arrays.stream(array); stream.forEach(element -&gt; System.out.println(element)); //第二种方式 Stream&lt;String&gt; stream2 = Stream.of(array); stream2.forEach(System.out::println);&#125; filter方法可以通过filter方法将一个流转换成另一个子集流,该接口接收一个Predicate函数式接口参数( 可以是一个Lambda或方法引用 )作为筛选条件 复习Predicate接口此前已学过java.util.function.Predicate&lt;T&gt;函数式接口,其中唯一的抽象方法如下,该方法将会产生一个boolean值结果,代表指定的条件是否满足,如果结果为true,那么Stream流的filter方法将会留用元素,反之舍弃1boolean test(T t); 基本使用延迟方法与终结方法结合使用 : 过滤并遍历数组元素12345678@Testpublic void testFilter() &#123; String[] array = &#123;\"a\", \"bc\", \"abc\", \"bcd\", \"abcd\"&#125;; Stream.of(array) .filter(element -&gt; element.startsWith(\"a\")) .filter(element -&gt; element.length() &gt; 3) .forEach(System.out::println); //abcd&#125; map方法如果需要将流中的元素映射到另一个流中,则可以使用map方法,方法签名如下,该接口需要一个函数式接口参数,可以将当前流中的T类型数据转换为另一种R类型的流1&lt;R&gt; Stream&lt;R&gt; map(function&lt;? super T,? extends R&gt; mapper); 复习Function接口此前已学过java.util.function.Function&lt;T, R&gt;函数式接口,其中唯一的抽象方法如下,其可以将一种 T 类型转换为 R 类型,而这种转换的动作称为映射1R apply(T t); 基本使用将String类型的数组元素装换为Integer类型并输出12345678910111213141516171819202122232425262728//Lambda表达式写法@Testpublic void testMapWithLambda() &#123; String[] array = &#123;\"1\", \"2\", \"3\", \"4\", \"5\"&#125;; Stream&lt;String&gt; stream = Stream.of(array); Stream&lt;Integer&gt; stream2 = stream.map((String string) -&gt; &#123; return Integer.valueOf(string); &#125;); stream2.forEach(element -&gt; System.out.println(element));&#125;//Lambda表达式简写@Testpublic void testMapWithSimpleLambda() &#123; String[] array = &#123;\"1\", \"2\", \"3\", \"4\", \"5\"&#125;; Stream.of(array) .map(string -&gt; Integer.valueOf(string)) .forEach(element -&gt; System.out.println(element));&#125;//方法引用写法@Testpublic void testMapWithMethodRef() &#123; String[] array = &#123;\"1\", \"2\", \"3\", \"4\", \"5\"&#125;; Stream.of(array) .map(Integer::valueOf) .forEach(System.out::println);&#125; count方法正如就集合Collection当中的size方法一样,Stream流提供了count方法来计数元素个数,该方法返回一个long值代表元素个数(不再像同旧集合为int值). 注 : 该方法为终结方法哟~1long count(); 基本使用统计数组中以”a”开头的元素个数123456@Testpublic void testCount() &#123; String[] array = &#123;\"a\", \"bc\", \"abc\", \"bcd\", \"abcd\"&#125;; long count = Stream.of(array).filter(element -&gt; element.startsWith(\"a\")).count(); System.out.println(count);&#125; limit方法limit方法可以对流进行截取,如果集合当前长度大于参数则进行截取,否则不进行操作1Stream&lt;T&gt; limit(long maxSize); 基本使用截取数组中的前三个元素并输出12345@Testpublic void testLimit() &#123; String[] array = &#123;\"a\", \"bc\", \"abc\", \"bcd\", \"abcd\"&#125;; Stream.of(array).limit(3).forEach(System.out::println);&#125; skip方法如果希望跳过前几个元素,可以使用skip方法获取一个截取之后的流. 如果流的当前长度大于n,则跳过前n个,否则将会的到一个长度为0的空流1Stream&lt;T&gt; skip(long n); 基本使用使用skip方法跳过数组中的前三个元素并输出12345@Testpublic void testSkip() &#123; String[] array = &#123;\"a\", \"bc\", \"abc\", \"bcd\", \"abcd\"&#125;; Stream.of(array).skip(3).forEach(System.out::println);&#125; concat方法如果有两个流,希望合并称为一个流,那么可以使用Stream接口的静态方法concat. 注 : 这是一个静态方法,不用与java.lang.String中的concat方法哟1Stream&lt;T&gt; skip(long n); 基本使用通过合并两个数组中的元素得到新的流,并输出合并后的数组元素123456789101112131415161718//Lambda表达式写法@Testpublic void testConcat() &#123; String[] array1 = &#123;\"a\", \"abc\"&#125;; String[] array2 = &#123;\"abcd\", \"abcde\"&#125;; Stream&lt;String&gt; stream1 = Stream.of(array1); Stream&lt;String&gt; stream2 = Stream.of(array2); Stream&lt;Serializable&gt; concatStream = Stream.concat(stream1, stream2); concatStream.forEach(System.out::println);&#125;//简写@Testpublic void testSimpleConcat() &#123; String[] array1 = &#123;\"a\", \"abc\"&#125;; String[] array2 = &#123;\"abcd\", \"abcde\"&#125;; Stream.concat(Stream.of(array1), Stream.of(array2)).forEach(System.out::println);&#125; 参考《Java 8 Stream》 : https://www.runoob.com/java/java8-streams.html","categories":[],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://yoursite.com/tags/JDK8/"}]},{"title":"JDK 8新特性之方法引用","slug":"JDK-8新特性之方法引用","date":"2019-08-18T02:42:23.000Z","updated":"2019-08-25T06:31:00.984Z","comments":true,"path":"2019/08/18/JDK-8新特性之方法引用/","link":"","permalink":"http://yoursite.com/2019/08/18/JDK-8新特性之方法引用/","excerpt":"","text":"学习笔记 : JDK 8新特性之方法引用简介当要传递给Lambda体的操作已经有实现的方法时,就可以使用方法引用咯~ 方法引用可以看做是Lambda表达式深层的表达,换句话说 : 方法引用就是Lambda表达式,既函数式接口的一个实例,通过方法的名字来指定一个方法,可以认为是Lambda表达式的一个语法糖~ 要求实现接口的抽象方法的参数列表和返回值类型,必须与方法引用的方法的参数列表和返回值类型保持一致 格式使用操作符 :: 将类(或对象)与方法名分隔开来 语法 对象 :: 实例方法名 类 :: 静态方法名 类 :: 实例方法名 基本使用下面通过一个简单的程序示例,来对比Lambda表达式与方法引用写法之间的区别 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package pers.huangyuhui.method;import org.junit.Ignore;import org.junit.Test;//定义一个函数式接口@FunctionalInterfaceinterface Printable &#123; void print(String s);&#125;/** * @project: jdk-learnig * @description: Java 8新特性之方法引用的基本使用 * @author: 黄宇辉 * @date: 8/18/2019-2:15 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class methodTest &#123; //定义打印字符的方法 public void printResult(String s, Printable printable) &#123; printable.print(s); &#125; //传统写法 @Test public void testPrintString() &#123; printResult(\"hello lambda\", new Printable() &#123; @Override public void print(String s) &#123; System.out.println(s); &#125; &#125;); &#125; //Lambda表达式写法 @Test public void testPrintStringWithLambda() &#123; printResult(\"hello lambda\", s1 -&gt; System.out.println(s1)); &#125; //方法引用写法 @Test public void testPrintStringWithMethodRef() &#123; //对象 :: 实例方法名 printResult(\"hello lambda\", System.out::println); &#125;&#125; 语义分析例如上例中,System.out对象中有一个重载的println(String)方法恰好就是我们所需要的,那么对于printResult方法的函数式接口参数,对比以下两种写法,完全等效 : Lambda表达式写法 : s -&gt; System.out.println(s) 方法引用写法 : System.out::println 第一种语义是指 : 拿到参数之后,继而传递给System.out.println方法去处理第二种语义是指 : 直接让System.out中的println方法取代Lambda. 这种写法复用了已有方案,更加简洁 常用的几种方法引用通过对象名引用成员方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package pers.huangyuhui.method;import org.junit.Test;//定义函数式接口@FunctionalInterfaceinterface Printable &#123; void print(String s);&#125;//定义含有成员方法类class Method &#123; public void printUpperCaseStr(String s) &#123; System.out.println(s.toUpperCase()); &#125;&#125;/** * @project: jdk-learnig * @description: 通过对象名引用成员方法 * @author: 黄宇辉 * @date: 8/18/2019-3:07 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class RefMethodByObjTest &#123; public void printResult(String s, Printable printable) &#123; printable.print(s); &#125; //传统方法 @Test public void testPrintResult() &#123; printResult(\"hello lambda\", new Printable() &#123; @Override public void print(String s) &#123; Method obj = new Method(); //创建Method对象 obj.printUpperCaseStr(s); //调用对象的成员方法,将字符串转换为大写后输出 &#125; &#125;); &#125; //Lambda表达式写法 @Test public void testPrintResultWithLambda() &#123; printResult(\"hello lambda\", s -&gt; &#123; Method obj = new Method(); obj.printUpperCaseStr(s); &#125;); &#125; //方法引用写法 @Test public void testPrintResultWithMethodRef() &#123; Method obj = new Method(); printResult(\"hello lambda\", obj::printUpperCaseStr); &#125;&#125; 通过类名引用静态方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package pers.huangyuhui.method;import org.junit.Test;//定义函数式接口@FunctionalInterfaceinterface calculable &#123; int add(int x, int y);&#125;//定义含有静态方法类class Method &#123; public static int add(int x, int y) &#123; return x + y; &#125;&#125;/** * @project: jdk-learnig * @description: 通过类名引用静态方法 * @author: 黄宇辉 * @date: 8/18/2019-3:36 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class RefStatisMethodByClazzName &#123; public int getResult(int x, int y, calculable calculable) &#123; return calculable.add(x, y); &#125; //传统写法 @Test public void testGetResult() &#123; int result = getResult(1, 2, new calculable() &#123; @Override public int add(int x, int y) &#123; return Method.add(x, y); &#125; &#125;); System.out.println(result); &#125; //Lambda表达式写法 @Test public void testGetResultWithLambda() &#123; int result = getResult(1, 2, (x, y) -&gt; Method.add(x, y)); System.out.println(result); &#125; //方法引用写法 @Test public void testGetResultWithMethodRef() &#123; int result = getResult(1, 2, Method::add); System.out.println(result); &#125;&#125; 通过Supper引用父类中的成员方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package pers.huangyuhui.method;import org.junit.Test;//定义一个函数式接口@FunctionalInterfaceinterface Agreeable &#123; void greet();&#125;//定义一个父类class Human &#123; public void hello() &#123; System.out.println(\"hello my sun !\"); &#125;&#125;/** * @project: jdk-learnig * @description: 通过Supper引用父类中的成员方法 * @author: 黄宇辉 * @date: 8/18/2019-4:06 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class RefMethodBySupper extends Human &#123; @Override public void hello() &#123; System.out.println(\"hello my father !\"); &#125; public void printResult(Agreeable agreeable) &#123; agreeable.greet(); &#125; //传统写法 @Test public void testPrintResult() &#123; printResult(new Agreeable() &#123; @Override public void greet() &#123; RefMethodBySupper.super.hello(); &#125; &#125;); &#125; //Lambda表达式写法 @Test public void testPrintResultWithLambda() &#123; printResult(() -&gt; super.hello()); &#125; //方法引用写法 @Test public void testPrintResultWithMethodRef() &#123; printResult(super::hello); &#125;&#125; 通过this引用成员方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package pers.huangyuhui.method;import org.junit.Test;//定义函数式接口@FunctionalInterfaceinterface Supermarket &#123; void buy();&#125;/** * @project: jdk-learnig * @description: 通过this引用成员方法 * @author: 黄宇辉 * @date: 8/18/2019-4:30 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class RefMethodByThis &#123; public void buyLaptop() &#123; System.out.println(\"buy a laptop successfully\"); &#125; public void printResult(Supermarket supermarket) &#123; supermarket.buy(); &#125; //传统写法 @Test public void testPrintResult() &#123; printResult(new Supermarket() &#123; @Override public void buy() &#123; buyLaptop(); &#125; &#125;); &#125; //Lambda表达式写法 @Test public void testPrintResultWithLambda() &#123; printResult(() -&gt; this.buyLaptop()); &#125; //方法引用写法 @Test public void testPrintResultWithMethodRef() &#123; printResult(this::buyLaptop); &#125;&#125; 类的构造器引用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package pers.huangyuhui.method;import org.junit.Test;//定义函数式接口@FunctionalInterfaceinterface UserBuilder &#123; User builder(String name);&#125;//定义含待引用的构造方法类class User &#123; private String name; public User(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;/** * @project: jdk-learnig * @description: 类的构造器引用 * @author: 黄宇辉 * @date: 8/18/2019-7:09 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class RefConstructor &#123; public void printResult(String name, UserBuilder userBuilder) &#123; User user = userBuilder.builder(name); System.out.println(user.getName()); &#125; //传统写法 @Test public void testPrintResult() &#123; printResult(\"yubuntu0109\", new UserBuilder() &#123; @Override public User builder(String name) &#123; return new User(name); &#125; &#125;); &#125; //Lambda表达式写法 @Test public void testPrintResultWithLambda() &#123; printResult(\"yubuntu0109\", s -&gt; new User(s)); &#125; //方法引用写法 @Test public void testPrintResultWithMethodRef() &#123; printResult(\"yubuntu0109\", User::new); &#125;&#125; 数组的构造器引用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package pers.huangyuhui.method;import org.junit.Test;import java.util.Arrays;//定义函数式接口@FunctionalInterfaceinterface ArrayBuilder &#123; int[] builderArray(int length);&#125;/** * @project: jdk-learnig * @description: 数组的构造器引用 * @author: 黄宇辉 * @date: 8/18/2019-7:51 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class RefArrayConstructor &#123; public static int[] getArray(int length, ArrayBuilder arrayBuilder) &#123; return arrayBuilder.builderArray(length); &#125; //传统写法 @Test public void testgetArray() &#123; int[] array = getArray(10, new ArrayBuilder() &#123; @Override public int[] builderArray(int length) &#123; return new int[length]; &#125; &#125;); System.out.println(Arrays.toString(array)); &#125; //Lambda表达式写法 @Test public void testArrayWithLambda() &#123; int[] array = getArray(10, length -&gt; new int[length]); System.out.println(Arrays.toString(array)); &#125; //方法引用写法 @Test public void testArrayWithMethodRef() &#123; int[] array = getArray(10, int[]::new); System.out.println(Arrays.toString(array)); &#125;&#125;","categories":[],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://yoursite.com/tags/JDK8/"}]},{"title":"JDK 8新特性之函数式接口的基本使用","slug":"JDK-8新特性之函数式接口的基本使用","date":"2019-08-18T00:48:00.000Z","updated":"2019-08-25T06:31:00.984Z","comments":true,"path":"2019/08/18/JDK-8新特性之函数式接口的基本使用/","link":"","permalink":"http://yoursite.com/2019/08/18/JDK-8新特性之函数式接口的基本使用/","excerpt":"","text":"学习笔记 : JDK 8新特性之函数式接口的基本使用简介函数式接口是整个 Lambda 表达式的一个根源,换句话来说 Java8 中的 Lambda 表达式要想彻底掌握,前提是要彻底理解好函数式接口哟,那么什么是函数接口呢 ? 答 : 函数式接口 (Functional Interface) 就是一个有且仅有一个抽象方法,但是可以有多个非抽象方法的接口,函数式接口可以被隐式转换为 Lambda 表达式. 注 : 我们可以通过在接口上使用 @FunctionalInterface 注解来检查它是否是一个函数接口. Java8中丰富的函数式接口都定义在 Java.util.function 包中哟~ Java内置四大核心函数式接口 函数式接口 参数类型 返回类型 用途 Consumer&lt;T&gt; 消费性接口 T void 对类型为T的对象应用操作,包含方法: void accept(T t) Supplier&lt;T&gt; 供给性接口 无 T 返回类型为T的对象,包含方法: T get() Function&lt;T,R&gt; 函数型接口 T R 对类型为T的对象应用操作,并返回结果是R类型的对象,包含方法: R apply(T t) Predicate&lt;T&gt; 断定性接口 T boolean 确定类型为T的对象是否满足某约束,并返回boolean值,包含方法: boolean test(T t) 四大核心函数式接口程序示例消费性接口的程序示例 :1234567891011121314151617181920212223242526272829303132333435363738394041package pers.huangyuhui.function;import org.junit.Ignore;import org.junit.Test;import java.util.function.Consumer;/** * @project: jdk-learnig * @description: Java 8中函数式接口的基本使用 * @author: 黄宇辉 * @date: 8/18/2019-9:30 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class functionTest &#123; //四大核心函数式接口:模拟消费性接口 public void consumer(double monery, Consumer&lt;Double&gt; consumer) &#123; consumer.accept(monery); &#125; //未使用Lambda表达式 @Test @Ignore public void testConsumer() &#123; consumer(100.0, new Consumer&lt;Double&gt;() &#123; @Override public void accept(Double monery) &#123; System.out.println(\"costed monery : \" + monery); &#125; &#125;); &#125; //使用Lambda表达式 @Test public void testConsumerWithLamdba() &#123; //可简写为: consumer(100.0, m -&gt; System.out.println(\"costed monery : \" + m)); consumer(100.0, (Double m) -&gt; System.out.println(\"costed monery :\" + m)); &#125;&#125; 断定性接口的程序示例 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package pers.huangyuhui.function;import org.junit.Ignore;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Consumer;import java.util.function.Predicate;/** * @project: jdk-learnig * @description: Java 8中函数式接口的基本使用 * @author: 黄宇辉 * @date: 8/18/2019-9:30 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class functionTest &#123; //四大核心函数式接口:模拟断定性接口 public List&lt;String&gt; predicate(List&lt;String&gt; list, Predicate&lt;String&gt; p) &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (String s : list) &#123; if (p.test(s)) &#123; arrayList.add(s); &#125; &#125; return arrayList; &#125; //未使用Lambd表达式 @Test @Ignore public void testPredicate() &#123; List&lt;String&gt; list = Arrays.asList(\"ab\", \"bc\", \"abc\", \"bcd\", \"abcd\", \"bcde\"); List&lt;String&gt; filterList = predicate(list, new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) &#123; return s.contains(\"a\"); &#125; &#125;); System.out.println(filterList); &#125; //使用Lambda表达式 @Test public void testPredicateWithLambda() &#123; List&lt;String&gt; list = Arrays.asList(\"ab\", \"bc\", \"abc\", \"bcd\", \"abcd\", \"bcde\"); //可简写为: List&lt;String&gt; filterList = predicate(list, s -&gt; s.contains(\"a\")); List&lt;String&gt; filterList = predicate(list, (String s) -&gt; s.contains(\"a\")); System.out.println(filterList); &#125;&#125;","categories":[],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://yoursite.com/tags/JDK8/"}]},{"title":"JDK 8新特性之Lambda表达式的基本语法","slug":"JDK-8新特性之Lambda表达式的基本语法","date":"2019-08-17T08:40:31.000Z","updated":"2019-08-25T06:31:00.982Z","comments":true,"path":"2019/08/17/JDK-8新特性之Lambda表达式的基本语法/","link":"","permalink":"http://yoursite.com/2019/08/17/JDK-8新特性之Lambda表达式的基本语法/","excerpt":"","text":"学习笔记 : JDK 8新特性之Lambda表达式的基本语法简介Lambda表达式 : 在Java8语言中引入的一种新的语言元素和操作符,这个操作符为-&gt;,该操作符被称为Lambda操作符或箭头操作符,它将Lambda分为以下两个部分 左侧 : 指定Lambda表达式需要的参数列表 右侧 : 制定了Lambda体,是抽象方法的实现逻辑,也既Lambda表达式要执行的功能 特征 可选类型声明 : 不需要声明参数类型,编译器可以统一识别参数值 可选的参数圆括号 : 一个参数无需定义圆括号,但多个参数需要定义圆括号 可选的大括号 : 如果主体包含了一个语句,就不需要使用大括号 可选的返回关键字 : 如果主体只有一个表达式返回值则编译器会自动返回值,大括号需要指定明表达式返回了一个数值 语法 语法格式一 : 无参,无返回值 1Runnable runnable = () -&gt; System.out.println(\"Hello Lambda1 !\"); 语法格式二 : Lambda需要一个参数,但是没有返回值 12//可以简写为: Consumer&lt;String&gt; consumer = System.out::println;Consumer&lt;String&gt; consumer = (String str) -&gt; System.out.println(str); 语法格式三 : 数据类型可以省略,因为可由编译器推断得出,称为”类型推断” 1Consumer&lt;String&gt; c = (str) -&gt; &#123; System.out.println(str) &#125;; 语法格式四 : Lambda若需要一个参数时,参数的小括号可以省略 1Consumer&lt;String&gt; c = str -&gt; &#123; System.out.println(str) &#125;; 语法格式五 : Lambda需要两个或以上的参数,多条执行语句,并且可以有返回值 1234Comparator&lt;String&gt; c = (x,y) -&gt; &#123; System.out.println(\"this is comparator\"); return Integer.compare(x,y);&#125;; 语法格式六 : 当Lambda体只有一条语句时,return与大括号若有,都可以省略 12//可以简写为: Comparator&lt;Integer&gt; comparator = Integer::compare;Comparator&lt;Integer&gt; c = (x,y) -&gt; Integer.compare(x,y); 程序示例 程序示例 : 语法格式一 123456789101112131415161718//未使用Lambda表达式@Testpublic void runnable() &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"this is runnable\"); &#125; &#125;; runnable.run();&#125;//使用Lambda表达式@Testpublic void runnableWithLambda() &#123; Runnable runnable = () -&gt; System.out.println(\"this is runnable\"); runnable.run();&#125; 程序示例 : 语法格式二/三/四 12345678910111213141516171819@Testpublic void consumer() &#123; Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;; consumer.accept(\"this is consumer\");&#125;@Testpublic void consumerWithLambda() &#123; //可以简写为: Consumer&lt;String&gt; consumer = (str) -&gt; System.out.println(str); //可以简写为: Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str); //可以简写为: Consumer&lt;String&gt; consumer = System.out::println; Consumer&lt;String&gt; consumer = (String str) -&gt; System.out.println(str); consumer.accept(\"this is consumer\");&#125; 程序示例 : 语法格式五 1234567891011121314151617181920@Testpublic void comparator() &#123; Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer x, Integer y) &#123; return Integer.compare(x, y); &#125; &#125;; System.out.println(comparator.compare(1, 2));&#125;@Testpublic void comparatorWithLambda() &#123; Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123; System.out.println(\"this is comparator\"); return Integer.compare(x, y); &#125;; System.out.println(comparator.compare(1, 2));&#125; 程序示例 : 语法格式六 1234567891011121314151617@Testpublic void comparator() &#123; Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer x, Integer y) &#123; return Integer.compare(x, y); &#125; &#125;; System.out.println(comparator.compare(1, 2));&#125;@Testpublic void comparatorWithLambda() &#123; //可以简写为: Comparator&lt;Integer&gt; comparator = Integer::compare; Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y); System.out.println(comparator.compare(1, 2));&#125;","categories":[],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://yoursite.com/tags/JDK8/"}]},{"title":"Java项目开发中PO,BO,VO,DTO,POJO,DAO的概念及其作用","slug":"Java项目开发中PO-BO-VO-DTO-POJO-DAO的概念及其作用","date":"2019-08-15T07:39:18.000Z","updated":"2019-08-25T06:31:01.011Z","comments":true,"path":"2019/08/15/Java项目开发中PO-BO-VO-DTO-POJO-DAO的概念及其作用/","link":"","permalink":"http://yoursite.com/2019/08/15/Java项目开发中PO-BO-VO-DTO-POJO-DAO的概念及其作用/","excerpt":"","text":"学习笔记 : Java项目开发中PO,BO,VO,DTO,POJO,DAO的概念及其作用最近参与了GitHub上的一个开源项目 : 一个简洁优美的Springboot集成Shiro的权限管理系统, 项目中无论是模块的划分,还是结构的分层,都让我眼前一亮! 既而代码的功能被理所当然地划分的非常有层次感,可见作者的编程设计水平实属厉害啊~ 下面来一起学习下Java项目开发中 PO, BO, VO, DTO, POJO, DAO 的概念及其作用吧~ PO(bean、entity等命名)Persistant Object持久对象 : 数据库表中的记录在Java对象中的显示状态. 最形象的理解就是一个PO就是数据库中的一条记录,好处是可以把一条记录作为一个对象处理,可以方便的转为其它对象 BO(service、manager、business等命名)Business Object业务对象 : 主要作用是把业务逻辑封装为一个对象. 这个对象可以包括一个或多个其它的对象,形象描述为一个对象的形为和动作,当然也有涉及到基它对象的一些形为和动作. 比如处理一个人的业务逻辑,有睡觉,吃饭,工作,上班等等形为,这样处理业务逻辑时,我们就可以针对BO去处理 VO(from也有此写法)Value Object值对象 : 主要体现在视图的对象,对于一个WEB页面将整个页面的属性封装成一个对象,然后用一个VO对象在控制层与视图层进行传输交换 DTO(经过处理后的PO,可能增加或者减少PO的属性)Data Transfer Object数据传输对象 : 主要用于远程调用等需要大量传输对象的地方. 比如我们一张表有100个字段,那么对应的PO就有100个属性,但是我们界面上只要显示10个字段,客户端用WEB service来获取数据,没有必要把整个PO对象传递到客户端,这时我们就可以用只有这10个属性的DTO来传递结果到客户端,这样也不会暴露服务端表结构. 到达客户端以后,如果用这个对象来对应界面显示,那此时它的身份就转为VO POJO(POJO是一种概念或者接口,身份及作用随环境变化而变化)Plain Ordinary Java Object简单Java对象 : 即POJO是一个简单的普通的Java对象,它不包含业务逻辑或持久逻辑等,但不是JavaBean、EntityBean等,不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口. POJO有一些Private的参数作为对象的属性. 然后针对每个参数定义了get和set方法作为访问的接口,POJO对象有时也被称为Data对象，大量应用于表现现实中的对象. 一个POJO持久化以后就是PO. 直接用它传递、传递过程中就是DTO. 直接用来对应表示层就是VO DAO(Data Access Object数据访问对象)这个大家最熟悉,和上面几个O区别最大,基本没有互相转化的可能性和必要. 主要用来封装对数据库的访问,通过它可以把POJO持久化为PO,用PO组装出来VO、DTO Controller(控制层)控制层主要由Action / Servlet等构成( 目前Spring MVC则是通过@Controller标签使用 ),此层业务层与视图层打交道的中间层,负责传输VO对象和调用BO层的业务方法,负责视图层请求的数据处理后响应给视图层 View(视图层)主要是指由JSP、HTML等文件形成的显示层,总结一下要用具体的X0需要看具体环境及项目架构,在不同的层、不同的应用场合,对象的身份也不一样,而且对象身份的转化也是很自然的. 就像你对老婆来说就是老公,对父母来说就是子女. 设计这些概念的初衷不是为了唬人而是为了更好的理解和处理各种逻辑,让大家能更好的去用面向对象的方式处理问题 上述名词在实际项目的应用举例控制层( controller-action ),业务层/服务层( bo-manager ),实体层( po-entity ),数据访问( dao ),视图对象( Vo-本项目省略 ),视图层( view-jsp/html ) 在平时开发项目中大家记得要精细设计各层,既而避免后续项目开发中产生不必要的大量重复工作. 如果不是大型系统可简化一些层,毕竟技术是为应用服务哒~ 🙏摘自(获益匪浅,非常感谢) : https://www.cnblogs.com/EasonJim/p/7967949.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"SpringBoot整合FreeMarker","slug":"SpringBoot整合FreeMarker","date":"2019-08-14T01:43:05.000Z","updated":"2019-08-25T06:31:01.060Z","comments":true,"path":"2019/08/14/SpringBoot整合FreeMarker/","link":"","permalink":"http://yoursite.com/2019/08/14/SpringBoot整合FreeMarker/","excerpt":"","text":"学习笔记 : Spring Boot整合FreeMarkerFreeMarker官方简介Apache FreeMarker™ is a template engine: a Java library to generate text output (HTML web pages, e-mails, configuration files, source code, etc.) based on templates and changing data. Templates are written in the FreeMarker Template Language (FTL), which is a simple, specialized language (not a full-blown programming language like PHP). Usually, a general-purpose programming language (like Java) is used to prepare the data (issue database queries, do business calculations). Then, Apache FreeMarker displays that prepared data using templates. In the template you are focusing on how to present the data, and outside the template you are focusing on what data to present. This approach is often referred to as the MVC (Model View Controller) pattern, and is particularly popular for dynamic web pages. It helps in separating web page designers (HTML authors) from developers (Java programmers usually). Designers won&#39;t face complicated logic in templates, and can change the appearance of a page without programmers having to change or recompile code. 引入Maven依赖12345678910&lt;!-- Web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- FreeMark --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 编写Controller1234567891011121314151617181920212223package pers.huangyuhui.freemark.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/** * @project: springboot-freemarker * @description: SpringBoot整合FreeMarker * @author: 黄宇辉 * @date: 8/14/2019-9:16 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controllerpublic class ViewController &#123; @RequestMapping(\"/hiFreeMark\") public String hiFreeMark(Model model) &#123; model.addAttribute(\"resource\", \"SringBoot is integrated with FreeMarker !\"); return \"index\"; &#125;&#125; 编写FreeMarker页面12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 align=\"center\" style=\"color: blueviolet\"&gt;$&#123;resource&#125; Date: $&#123;.now?string(\"yyyy-MM-dd HH:mm:ss.sss\")&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 程序运行效果如下所示 :","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"FreeMarker","slug":"FreeMarker","permalink":"http://yoursite.com/tags/FreeMarker/"}]},{"title":"Lombok简介及基本使用","slug":"Lombok简介及基本使用","date":"2019-08-13T12:46:07.000Z","updated":"2019-08-25T06:31:01.016Z","comments":true,"path":"2019/08/13/Lombok简介及基本使用/","link":"","permalink":"http://yoursite.com/2019/08/13/Lombok简介及基本使用/","excerpt":"","text":"学习笔记 : Lombok简介及基本使用简介问题引入 : 开发中经常需要写的JavaBean,都需要花时间去添加相应的getter/setter,也许还要去写构造器、equals等方法,而且需要维护,当属性多时会出现大量的getter/setter方法,这些显得很冗长也没有太多技术含量,一旦修改属性,就容易出现忘记修改对应方法的失误哟~ Lombok能通过注解的方式,在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法. 出现的神奇就是在源码中没有getter和setter方法,但是在编译生成的字节码文件中有getter和setter方法. 这样就省去了手动重建这些代码的麻烦,既而达到简化代码,提高开发人员的开发效率的目的 优点 : 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法,提高了一定的开发效率 让代码变得简洁,不用过多的去关注相应的方法 属性做修改时,也简化了维护为这些属性所生成的getter/setter方法等 缺点 : 不支持多种参数构造器的重载 虽然省去了手动创建getter/setter方法的麻烦,但大大降低了源代码的可读性和完整性,降低了阅读源代码的舒适度 总结 : Lombok虽然有很多优点,但Lombok更类似于一种IDE插件,项目也需要依赖相应的jar包. Lombok依赖jar包是因为编译时要用它的注解,为什么说它又类似插件 ? 因为在使用时Eclipse或IntelliJ IDEA都需要安装相应的插件,在编译器编译时通过操作AST( 抽象语法树 )改变字节码生成,变向的就是说它在改变Java语法. 它不像Spring的依赖注入或者MyBatis的ORM一样是运行时的特性,而是编译时的特性 开发环境 添加Maven依赖 : 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 安装IDEA(IntelliJ Lombok plugin)插件 常见异常 (已添加lombok依赖情况下)抛出此异常,(IDEA环境)解决方案:安装IntelliJ Lombok plugin并启用Enable annotation processing 1234567Warning:(49, 8) java: lombok.javac.apt.LombokProcessor could not be initialized. Lombok will not run during this compilation: java.lang.IllegalArgumentException: com.sun.tools.javac.main.DelegatingJavaFileManager$DelegatingSJFM extends com.sun.tools.javac.main.DelegatingJavaFileManager implements javax.tools.StandardJavaFileManager at lombok.javac.apt.LombokFileObjects.getCompiler(LombokFileObjects.java:148) at lombok.javac.apt.InterceptingJavaFileManager.&lt;init&gt;(InterceptingJavaFileManager.java:40) at lombok.javac.apt.LombokProcessor.placePostCompileAndDontMakeForceRoundDummiesHook(LombokProcessor.java:165) at lombok.javac.apt.LombokProcessor.init(LombokProcessor.java:87) at lombok.core.AnnotationProcessor$JavacDescriptor.want(AnnotationProcessor.java:87) at lombok.core.AnnotationProcessor.init(AnnotationProcessor.java:140) JDK版本bug,解决方案:重置JDK版本,Project Structure—&gt;Porject settings—&gt;Project : 将Project SDK设置为:9(java version&quot;9.0.4&quot;), language level设置为8,详情操作请参考 : IDEA为何多处设置JDK,有什么区别呢 ? 123Warning:(9, 8) java: lombok.javac.apt.LombokProcessor could not be initialized. Lombok will not run during this compilation: java.lang.IllegalArgumentException: com.sun.tools.javac.main.DelegatingJavaFileManager$DelegatingSJFM extends com.sun.tools.javac.main.DelegatingJavaFileManager implements javax.tools.StandardJavaFileManager at lombok.javac.apt.LombokFileObjects.getCompiler(LombokFileObjects.java:148) at lombok.javac.apt.InterceptingJavaFileManager.&lt;init&gt;(InterceptingJavaFileManager.java:40) 使用Lombok前后对比 一个未使用Lombok的普通JavaBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.huangyuhui.lombok.bean;import org.apache.log4j.Logger;public class User &#123; private Integer id; private String name; private String password; private Logger log = Logger.getLogger(this.getClass()); public User() &#123; &#125; public User(Integer id, String name, String password) &#123; this.id = id; this.name = name; this.password = password; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; 一个使用Lombok的普通JavaBean( 使用Lombok注解达到与上述JavaBean同样的效果 )~ @Data : 注解在类上,提供类所有属性的 getting 和 setting 方法,此外还提供了equals、canEqual、hashCode、toString方法 @Setter : 注解在属性上,为属性提供 setting 方法 @Getter : 注解在属性上,为属性提供 getting 方法 @Log4j : 注解在类上,为类提供一个属性名为 log 的 log4j 日志对象 @ToString : 注解在类上,为类提供一个 toString 方法 @NoArgsConstructor : 注解在类上,为类提供一个无参的构造方法 @AllArgsConstructor : 注解在类上,为类提供一个全参的构造方法 123456789101112131415161718192021222324package pers.huangyuhui.lombok.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;import lombok.extern.log4j.Log4j;@Data@Log4j@ToString@NoArgsConstructor@AllArgsConstructorpublic class UserWithLombok &#123; private Integer id; private String name; private String password; public void outLogInfo() &#123; log.info(\"the message object to log ~\"); &#125;&#125; 参考链接 : https://github.com/rzwitserloot/lombok https://www.cnblogs.com/heyonggang/p/8638374.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"http://yoursite.com/tags/Lombok/"}]},{"title":"详解在IDEA中多处设置JDK及其区别","slug":"详解在IDEA中多处设置JDK及其区别","date":"2019-08-13T01:56:45.000Z","updated":"2019-08-25T06:31:01.221Z","comments":true,"path":"2019/08/13/详解在IDEA中多处设置JDK及其区别/","link":"","permalink":"http://yoursite.com/2019/08/13/详解在IDEA中多处设置JDK及其区别/","excerpt":"","text":"学习笔记 : IDEA为何多处设置JDK,有什么区别呢 ?设置编译器的版本编译器的版本,既生成class文件的jdk版本 : Settings &gt; Build,Execution,Deployment &gt; Complier &gt; Java Compiler 设置Modules中的SDK和language level版本这里选择Modules中的SDK和language level的默认版本 : Project Structure &gt; Project Settings &gt; Project 注意 : Language Level为限定项目编译检查时最低要求的 JDK 特性 设置项目实际的Language Level版本Project Structure &gt; Project Settings &gt; Modules &gt; Sources 设置项目实际的SDK版本相比整个工程设置语言级别可以更加地精确控制 : Project Structure &gt; Project Settings &gt; Modules &gt; Dependencies ❓ IDEA为何多处设置JDK,有什么区别 ?project SDK : 表示开发环境使用什么JDK来编译language level : 表示项目最低可以使用什么版本的JDK通过 至于说两者之间的区别,让我来给你举个例子 :若设置project SDK为1.8,language level设置为1.7,此时若使用lambda表达式,IDEA则会帮你标红并提醒你若这么写,项目未来可就不能使用1.7版本的JDK编译啦 ( languang level用来保证代码最低可以被什么级别的 JDK 编译 ) ,尽管你使用的是SDK1.8 · · ·","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}]},{"title":"一个基础的的SSM整合Shiro案例","slug":"一个基础的的SSM整合Shiro案例","date":"2019-08-10T23:43:50.000Z","updated":"2019-08-25T06:31:01.128Z","comments":true,"path":"2019/08/11/一个基础的的SSM整合Shiro案例/","link":"","permalink":"http://yoursite.com/2019/08/11/一个基础的的SSM整合Shiro案例/","excerpt":"","text":"学习笔记 : 一个基础的的SSM整合Shiro案例前些日子写了一个基础的SpringBoot整合Shiro案例,然后又进阶地学习了SSM整合Shiro的基本知识,继而今天总结一下 : 写一个基础的SSM整合Shiro案例(该案例与上述案例思路相同)~ 该案例的代码仓库 : https://github.com/YUbuntu0109/Shiro-learning/tree/master/ssm%20project%20with%20shiro 数据库设计数据库ER图如下所示 : 数据表中用户及其分配的权限信息如下所示 : 账户 密码(MD5加密前) 角色 权限 admin demo admin * tea demo teacher teaListView:view , stuListView:view , stuListView:add , stuListView:edit stu demo student stuListView:view 案例截屏解析用户登录页面,访问资源前必须先进行用户身份认证,详情参考资源拦截器中的配置信息哟 若要访问教师 / 学生信息管理页面,需要用户拥有teaListView:view / stuListView:view权限 管理员( admin )拥有访问资源的所有权限( ),所以可以操控学生信息页面中的任何操作* 管理员( admin )拥有访问资源的所有权限( ),所以可以操控教师信息页面中的任何操作* 教师( tea )拥有学生页面面的stuListView:view , stuListView:add , stuListView:edit权限,所以删除信息操作为不可见 教师( tea )仅拥有教师信息管理页面的teaListView:view权限,所以增,删,改,操作为不可见状态 学生( stu )仅拥有学生信息管理页面的stuListView:view权限,所以增,删,改,操作为不可见状态 学生( stu )没有访问教师信息管理页面的权限,所以被资源拦截器所拦截继而进入指定的’unauthorized.html’页面面","categories":[],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"详解JSP中Shiro标签的使用","slug":"详解JSP中Shiro标签的使用","date":"2019-08-10T23:42:13.000Z","updated":"2019-08-25T06:31:01.209Z","comments":true,"path":"2019/08/11/详解JSP中Shiro标签的使用/","link":"","permalink":"http://yoursite.com/2019/08/11/详解JSP中Shiro标签的使用/","excerpt":"","text":"学习笔记 : 详解JSP中Shiro标签的使用Apache Shiro provides a Subject-aware JSP/GSP tag library that allows you to control your JSP, JSTL or GSP page output based on the current Subject’s state. This is quite useful for personalizing views based on the identity and authorization state of the current user viewing the web page. For more information, please refer to : http://shiro.apache.org/web.html#Web-taglibrary Tag Library ConfigurationThe Tag Library Descriptor (TLD) file is bundled in shiro-web.jar in the META-INF/shiro.tld file. To use any of the tags, add the following line to the top of your JSP page (or wherever you define page directives) :1&lt;%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %&gt; We’ve used the shiro prefix to indicate the shiro tag library namespace, but you can assign whatever name you like. shiro : authenicated表示认证已通过,但不包括remember me登录的123&lt;shiro:authenticated&gt; &lt;label&gt;用户身份验证已通过&lt;/label&gt;&lt;/shiro:authenticated&gt; 说明 : 只有已通过用户认证,但不是通过记住我(remember me)浏览才会看到标签内的内容 shiro : guest表示是游客身份,没有登录123&lt;shiro:guest&gt; &lt;label&gt;您当前是游客,&lt;/label&gt;&lt;a href=\"/login.jsp\" &gt;请登录&lt;/a&gt;&lt;/shiro:guest&gt; 说明 : 只有是没有登录过,以游客的身份浏览才会看到标签内的内容 shiro : hasAnyRoles表示拥有这些角色中其中一个123&lt;shiro:hasAnyRoles name=\"admin,user\"&gt; &lt;label&gt;这是拥有admin或者是user角色的用户&lt;/label&gt;&lt;/shiro:hasAnyRoles&gt; 说明 : 只有成功登录后,且具有admin或者user角色的用户才会看到标签内的内容. name属性中可以填写多个角色名称，以逗号( , )分隔 shiro : hasPermission表示拥有某一权限123&lt;shiro:hasPermission name=\"admin:add\"&gt; &lt;label&gt;这个用户拥有admin:add的权限&lt;/label&gt;&lt;/shiro:hasPermission&gt; 说明 : 只有成功登录后,且具有admin:add权限的用户才可以看到标签内的内容,name属性中只能填写一个权限的名称 shiro : hashRole表示拥有某一角色123&lt;shiro:hasRole name=\"admin\"&gt; &lt;label&gt;这个用户拥有的角色是admin&lt;/label&gt;&lt;/shiro:hasRole&gt; 说明 : 只有成功登录后,且具有admin角色的用户才可以看到标签内的内容,name属性中只能填写一个角色的名称 shiro : lacksPermission表示不拥有某一角色123&lt;shiro:lacksPermission name=\"admin:delete\"&gt; &lt;label&gt;这个用户不拥有admin:delete的权限&lt;/label&gt;&lt;/shiro:lacksPermission&gt; 说明 : 只有成功登录后,且不具有admin:delete权限的用户才可以看到标签内的内容,name属性中只能填写一个权限的名称 shiro : lacksRole表示不拥有某一角色123&lt;shiro:lacksRole name=\"admin\"&gt; &lt;label&gt;这个用户不拥有admin的角色&lt;/label&gt;&lt;/shiro:lacksRole&gt; 说明 : 只有成功登录后，且不具有admin角色的用户才可以看到标签内的内容,name属性中只能填写一个角色的名称 shiro : notAuthenticated表示没有通过验证123&lt;shiro:notAuthenticated&gt; &lt;label&gt;用户身份验证没有通过&lt;/label&gt;&lt;/shiro:notAuthenticated&gt; 说明 : 只有没有通过验证的才可以看到标签内的内容,包括通过记住我(remember me)登录的 shiro : principal表示用户的身份 : 取值取的是你登录的时候,在Realm实现类中的SimpleAuthenticationInfo(Object principal, Object hashedCredentials, ByteSource credentialsSalt, String realmName)放的第一个参数哟~ 例如 :1return new SimpleAuthenticationInfo(user, user.getPassword(), ByteSource.Util.bytes(user.getUsername()), this.getName()); 如果第一个放的是username或者是一个值,那么就可以直接用 12&lt;!--取到username--&gt;&lt;shiro: principal/&gt; 如果第一个参数放的是对象,比如放User对象. 那么如果要取其中某一个值,可以通过property属性来指定 12&lt;!--需要指定property--&gt;&lt;shiro:principal property=\"username\"/&gt; shiro : user表示已登录123&lt;shiro:user&gt; &lt;label&gt;欢迎[&lt;shiro:principal/&gt;],&lt;/label&gt;&lt;a href=\"/logout.jsp\"&gt;退出&lt;/a&gt;&lt;/shiro:user&gt; 说明 : 只有已经登录(包含通过记住我(remember me)登录的)的用户才可以看到标签内的内容. 一般和标签shiro : principal一起用,来做显示用户的名称 标签嵌套shiro的jsp标签可以嵌套使用,可以根据业务的具体场景进行使用. 例如一个按钮需要排除不是admin或user角色的用户才可以显示,则可以像如下这样实现 :12345&lt;shiro:lacksRole name=\"admin\"&gt; &lt;shiro:lacksRole name=\"user\"&gt; &lt;label&gt;这个用户不拥有admin或user的角色&lt;/label&gt; &lt;/shiro:lacksRole&gt;&lt;/shiro:lacksRole&gt; 🙏参考链接(获益匪浅,非常感谢) : https://blog.csdn.net/yaodieteng1510/article/details/79992247","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"SSM整合Shiro的基本配置","slug":"SSM整合Shiro的基本配置","date":"2019-08-10T22:55:55.000Z","updated":"2019-08-25T06:31:01.020Z","comments":true,"path":"2019/08/11/SSM整合Shiro的基本配置/","link":"","permalink":"http://yoursite.com/2019/08/11/SSM整合Shiro的基本配置/","excerpt":"","text":"学习笔记 : SSM整合Shiro的基本配置学习Spring Boot整合Shiro知识后,写了一个简单的Spring Boot整合Shiro的权限管理案例,可随后在GitHub上发现了一个基于SSM框架简单的后台权限管理系统,很喜欢该项目(比较初级,适合练手),所以又开始学习如何在SSM中整合Shiro,Spring集成Shiro一般通过的 xml 配置,相比Spring Boot较为繁琐哟~ 以下基本配置信息摘自案例 : 一个简单的SSM整合Shiro的权限管理案例 Maven依赖Shiro-learning/ssm project with shiro/ssm-shiro/pom.xml123456789101112&lt;!-- Shiro --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt; web.xml配置Shiro-learning/ssm project with shiro/ssm-shiro/src/main/webapp/WEB-INF/web.xml123456789101112&lt;!--配置Spring整合Shiro的过滤器:将拦截下来的请求交给Spring容器中名为'shiroFilter'(与filter-name同名)的bean处理详情信息见:applicationContext-shiro.xml--&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Shiro的基本配置Shiro-learning/ssm project with shiro/ssm-shiro/src/main/resources/spring-config/applicationContext-shiro.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;description&gt;configuration informations about Shiro&lt;/description&gt; &lt;!-- 配置shiroFilter:这里的id名(shiroFilter)要和web.xml配置的名字保持一致哟 --&gt; &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt; &lt;!-- 关联SecurityManage --&gt; &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt; &lt;!-- 定义过虑器链,从上向下顺序执行,一般将/**放在最下边 --&gt; &lt;property name=\"filterChainDefinitions\"&gt; &lt;value&gt; &lt;!-- 防止过滤器拦截验证用户登录信息的请求(/login ) --&gt; /login=anon &lt;!-- 设置Shiro默认的注销请求:其具体的注销逻辑代码Shiro已经替我们实现了哟 --&gt; /logout=logout &lt;!-- 设置角色过滤 --&gt; /teaListView=roles[admin] &lt;!-- 设置请求权限过滤:除身份认证外,还需要用户拥有对stuListView/teaListView资源的view权限 --&gt; /stuListView=perms[stuListView:view] /teaListView=perms[teaListView:view] &lt;!-- 所有资源的访问都需要身份认证 --&gt; /**=authc &lt;/value&gt; &lt;/property&gt; &lt;!-- 指定Shiro默认的登录请求,默认: http://localhost:8080/login.jsp --&gt; &lt;property name=\"loginUrl\" value=\"/loginView\"/&gt; &lt;!-- 指定用户未授权操作提示页 --&gt; &lt;property name=\"unauthorizedUrl\" value=\"/unauthorizedView\"/&gt; &lt;/bean&gt; &lt;!-- 自定义realm --&gt; &lt;bean id=\"realm\" class=\"pers.huangyuhui.shiro.shiro.UserRealm\"&gt; &lt;!-- 用户凭证加密配置 --&gt; &lt;property name=\"credentialsMatcher\" ref=\"credentialsMatcher\"/&gt; &lt;!-- 是否启用缓存:默认为true --&gt; &lt;property name=\"cachingEnabled\" value=\"true\"/&gt; &lt;!-- 是否启用身份验证缓存 --&gt; &lt;property name=\"authenticationCachingEnabled\" value=\"true\"/&gt; &lt;!-- 缓存AuthenticationInfo信息的缓存名称 --&gt; &lt;property name=\"authenticationCacheName\" value=\"authenticationCache\"/&gt; &lt;!-- 是否启用授权缓存:缓存AuthorizationInfo信息 --&gt; &lt;property name=\"authorizationCachingEnabled\" value=\"true\"/&gt; &lt;!-- 缓存AuthorizationInfo信息的缓存名称 --&gt; &lt;property name=\"authorizationCacheName\" value=\"authorizationCache\"/&gt; &lt;/bean&gt; &lt;!-- Shiro安全管理器 --&gt; &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt; &lt;!-- 注入自定义Realm --&gt; &lt;property name=\"realm\" ref=\"realm\"/&gt; &lt;!-- 注入缓存管理器 --&gt; &lt;property name=\"cacheManager\" ref=\"ehCacheManager\"/&gt; &lt;/bean&gt; &lt;!-- Shiro凭证匹配器:对登录用户的密码进行MD5加密,hashIterations是散列加密次数,盐值信息见:UserRealm.java --&gt; &lt;bean id=\"credentialsMatcher\" class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"&gt; &lt;property name=\"hashAlgorithmName\" value=\"MD5\"/&gt; &lt;property name=\"hashIterations\" value=\"3\"/&gt; &lt;/bean&gt; &lt;!-- Shiro缓存管理器 --&gt; &lt;bean id=\"ehCacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"&gt; &lt;!-- 注入ehcache配置文件 --&gt; &lt;property name=\"cacheManagerConfigFile\" value=\"classpath:shiro-config/ehcache-shiro.xml\"/&gt; &lt;/bean&gt; &lt;!-- Shiro生命周期处理器 --&gt; &lt;bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"/&gt; &lt;!-- 开启shiro注解模式:如果使用注解模式,必须采用cglib针对类进行代理 --&gt; &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" depends-on=\"lifecycleBeanPostProcessor\"&gt; &lt;property name=\"proxyTargetClass\" value=\"true\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"&gt; &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Shiro-learning/ssm project with shiro/ssm-shiro/src/main/resources/shiro-config/ehcache-shiro.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\" name=\"myEhcache\"&gt; &lt;diskStore path=\"java.io.tmpdir\"/&gt; &lt;!-- 授权信息缓存 --&gt; &lt;cache name=\"authorizationCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- 身份信息缓存 --&gt; &lt;cache name=\"authenticationCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- Session缓存 --&gt; &lt;cache name=\"activeSessionCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- 缓存半小时 --&gt; &lt;cache name=\"halfHour\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- 缓存一小时 --&gt; &lt;cache name=\"hour\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"3600\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- 缓存一天 --&gt; &lt;cache name=\"oneDay\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"86400\" timeToLiveSeconds=\"86400\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- name: 缓存名称 maxElementsInMemory: 缓存最大个数 eternal: 对象是否永久有效,一但设置了,timeout将不起作用 timeToIdleSeconds: 设置对象在失效前的允许闲置时间(单位：秒). 仅当eternal=false对象不是永久有效时使用,可选属性,默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds: 设置对象在失效前允许存活时间(单位：秒). 最大时间介于创建时间和失效时间之间. 仅当eternal=false对象不是永久有效时使用,默认是0,也就是对象存活时间无穷大 overflowToDisk: 当内存中对象数量达到maxElementsInMemory时,Ehcache将会对象写到磁盘中 diskSpoolBufferSizeMB: 这个参数设置DiskStore(磁盘缓存)的缓存区大小,默认是30MB. 每个Cache都应该有自己的一个缓冲区 maxElementsOnDisk: 硬盘最大缓存个数 diskPersistent: 是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskExpiryThreadIntervalSeconds: 磁盘失效线程运行时间间隔,默认是120秒 memoryStoreEvictionPolicy: 当达到maxElementsInMemory限制时,Ehcache将会根据指定的策略去清理内存. 默认策略是LRU(最近最少使用). 你可以设置为FIFO(先进先出)或是LFU(较少使用) clearOnFlush: 内存数量最大时是否清除 --&gt; &lt;defaultCache name=\"defaultCache\" maxElementsInMemory=\"10000\" timeToIdleSeconds=\"600\" timeToLiveSeconds=\"600\" overflowToDisk=\"false\" maxElementsOnDisk=\"100000\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 自定义Realm的基本配置Shiro-learning/ssm project with shiro/ssm-shiro/src/main/java/pers/huangyuhui/shiro/shiro/UserRealm.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package pers.huangyuhui.shiro.shiro;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.ByteSource;import org.springframework.beans.factory.annotation.Autowired;import pers.huangyuhui.shiro.bean.Permission;import pers.huangyuhui.shiro.bean.Role;import pers.huangyuhui.shiro.bean.User;import pers.huangyuhui.shiro.service.UserService;import java.util.Collection;import java.util.HashSet;import java.util.Set;/** * @project: ssm-shiro * @description: 配置自定义Realm * @author: 黄宇辉 * @date: 8/10/2019-1:11 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class UserRealm extends AuthorizingRealm &#123; @Autowired private UserService userService; /** * @description: 授权认证:提供用户信息,返回权限信息 * @param: principals * @date: 2019-08-11 7:50 AM * @return: org.apache.shiro.authz.AuthorizationInfo */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; System.err.println(\"------------&gt; 授权认证 ------------&gt;\"); //获取当前登录的用户信息 Subject currentUser = SecurityUtils.getSubject(); User u = (User) currentUser.getPrincipal(); //从数据库中获取用户所拥有的角色及权限信息 User user = userService.findByName(u.getUsername()); if (user != null) &#123; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //用于存储用户的角色及权限信息 Collection&lt;String&gt; rolesCollection = new HashSet&lt;&gt;(); Collection&lt;String&gt; permissionsCollection = new HashSet&lt;&gt;(); Set&lt;Role&gt; roles = user.getRoles(); //获取用户Role的Set集合 //通过遍历用户所拥有的角色,来获取其对应的权限信息 for (Role role : roles) &#123; rolesCollection.add(role.getName()); //将每一个role的name封装到集合中 Set&lt;Permission&gt; permissionSet = role.getPermissions(); //获取每一个role所对应的permission的set集合 //遍历用户所拥有的权限信息 for (Permission permission : permissionSet) &#123; permissionsCollection.add(permission.getName()); //将每一个permission的name封装到集合中 &#125; info.addStringPermissions(permissionsCollection); //为用户授权 &#125; info.addRoles(rolesCollection); //为用户授予角色 System.out.println(\"[roles]------------&gt;\" + rolesCollection.toString()); System.out.println(\"[permissions]------------&gt;\" + permissionsCollection.toString()); return info; &#125; return null; &#125; /** * @description: 登录认证:提供帐户信息,返回认证信息 * @param: authenticationToken * @date: 2019-08-11 7:51 AM * @return: org.apache.shiro.authc.AuthenticationInfo */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.err.println(\"------------&gt; 开始认证 ------------&gt;\"); UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; //从数据库中获取用户信息 User user = userService.findByName(token.getUsername()); System.out.println(\"[user]------------&gt;\" + user); //验证账户信息 if (user == null) &#123; return null; //it's will be throw a UnknownAccountException &#125; //验证密码信息(盐值:ByteSource.Util.bytes(user.getUsername())) return new SimpleAuthenticationInfo(user, user.getPassword(), ByteSource.Util.bytes(user.getUsername()), this.getName()); &#125;&#125;","categories":[],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"GitHub中emoji表情的含义及使用规范","slug":"GitHub中emoji表情的含义及使用规范","date":"2019-08-10T12:02:55.000Z","updated":"2019-08-25T06:31:00.961Z","comments":true,"path":"2019/08/10/GitHub中emoji表情的含义及使用规范/","link":"","permalink":"http://yoursite.com/2019/08/10/GitHub中emoji表情的含义及使用规范/","excerpt":"","text":"学习笔记 : GitHub中emoji表情的含义及使用规范日语 : 絵文字/えもじ emoji,是日本在无线通信中所使用的视觉情感符号,绘指图画,文字指的则是字符,可用来代表多种表情,如笑脸表示笑、蛋糕表示食物等. emoji 频繁地出现在我们的聊天记录、朋友圈、甚至很多时候我们都会用 emoji 代替文字来聊天,既而来传达自己想要表达的一切,作为一名程序员,常用的代码托管平台 GitHub 中也是可以使用 emoji 表情的哟~ 😜 执行git commit时使用 emoji 为本次提交打上一个标签, 使得此次 commit 的主要工作得以凸现,也能够使得其在整个提交历史中易于区分与查找,添加了 emoji 表情的提交记录真的能包含很多有用信息,阅读体验非常棒. 但是,emoji 表情在提交代码的时候也不能乱用,否则容易造成误解. 因此开源项目 gitmoji 专门规定了在 GitHub 提交代码时应当遵循的 emoji 规范~ 更多信息请参考 : https://github.com/carloscuesta/gitmoji/ emoji emoji代码 commit描述 🎨 (调色板) :art: 改进代码结构/代码格式 ⚡️(闪电) :zap: 提高性能 🔥 (火焰) :fire: 移除代码或文件 🐛 (bug) :bug: 修复 bug 🚑 (急救车) :ambulance: 重要补丁 ✨ (火花) :sparkles: 引入新功能 📝 (备忘录) :memo: 撰写文档 🚀 (火箭) :rocket: 部署功能 💄 (口红) :lipstick: 更新 UI 和样式文件 🎉 (庆祝) :tada: 初次提交 ✅ (白色复选框) :white_check_mark: 增加测试 🔒 (锁) :lock: 修复安全问题 🍎 (红苹果) :apple: 修复 macOS 下的问题 🍏(青苹果) :green_apple: 修复 iOS 下的问题 🐧 (企鹅) :penguin: 修复 Linux 下的问题 🏁 (旗帜) :checkered_flag: 修复 Windows 下的问题 🤖(机器人) :robot: 修复 androd 下的问题 🔖 (书签) :bookmark: 发行/版本标签 🚨 (警车灯) :rotating_light: 移除 linter 警告 🚧 (施工) :construction: 工作进行中 💚 (绿心) :green_heart: 修复 CI 构建问题 ⬇️ (下降箭头) :arrow_down: 降级依赖 ⬆️ (上升箭头) :arrow_up: 升级依赖 👷 (工人) :construction_worker: 添加 CI 构建系统 📈 (上升趋势图) :chart_with_upwards_trend: 添加分析或跟踪代码 🔨 (锤子) :hammer: 重大重构 ➖ (减号) :heavy_minus_sign: 减少一个依赖 🐳 (鲸鱼) :whale: Docker 相关工作 ➕ (加号) :heavy_plus_sign: 增加一个依赖 🔧 (扳手) :wrench: 修改配置文件 🌐 (地球) :globe_with_meridians: 国际化与本地化 ✏️ (铅笔) :pencil2: 修复错别字 👌 (OK手势) :ok_hand: 由于代码审查更改而更新代码 :pushpin: Pinning dependencies to specific versions :recycle: Refactoring code :poop: Writing bad code that needs to be improved :rewind: Reverting changes :twisted_rightwards_arrows: Merging branches :package: Updating compiled files or packages :alien: Updating code due to external API changes :truck: Moving or renaming files :page_facing_up: Adding or updating license :boom: Introducing breaking changes :bento: Adding or updating assets :wheelchair: Improving accessibility :bulb: Documenting source code :beers: Writing code drunkenly :speech_balloon: Updating text and literals :card_file_box: Performing database related changes :loud_sound: Adding logs :mute: Removing logs :busts_in_silhouette: Adding contributor(s) :children_crossing: Improving user experience / usability :building_construction: Making architectural changes :iphone: Working on responsive design :clown_face: Mocking things :egg: Adding an easter egg :see_no_evil: Adding or updating a .gitignore file :camera_flash: Adding or updating snapshots :alembic: Experimenting new things :mag: Improving SEO :wheel_of_dharma: Work about Kubernetes :label: Adding or updating types (Flow, TypeScript) 🙏参考链接 : https://qq52o.me/1974.html","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"Git Commit Message 规范","slug":"Git-Commit-Message-规范","date":"2019-08-08T11:59:13.000Z","updated":"2019-08-25T06:31:00.959Z","comments":true,"path":"2019/08/08/Git-Commit-Message-规范/","link":"","permalink":"http://yoursite.com/2019/08/08/Git-Commit-Message-规范/","excerpt":"","text":"学习笔记 : Git Commit Message规范Git Commit Message 应该清晰明了,要用精简的语言说明本次提交的目的,其主要作用是为了后续的搜索、版本的回滚、合并冲突的追溯等操作~ 规范介绍这次主要介绍 AngularJS 的规范,它是由 Google 推出的一套提交消息规范标准,也是目前使用范围最广的规范,比较合理和系统化,并且还有配套的工具可以供我们使用,规范执行方案如下 : 格式要求12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 消息只占用一行,任何行都不能超过 100 个字符 允许使用 GitHub 以及各种 Git 工具阅读消息 提交消息由页眉、正文和页脚组成,由空行分隔 HeaderHeader部分只有一行,包括三个字段 : type(必需)、scope(可选)、和subject(必需) type代表某次提交的类型,比如是修复一个 bug 或是增加一个 feature,类型如下 : 类型 说明 feat 新增feature fix 修复bug docs 仅仅修改了文档,比如README , CHANGELOG , CONTRIBUTE等等 style 修改了空格,格式缩进,逗号等,不改变代码逻辑 refactor 代码重构,没有添加新功能或修复Bug perf 优化相关,比如提升性能,体验 test 测试用例,包括单元测试,集成测试等 chore 改变构建流程,或者增加依赖库,工具等 revert 回滚到上一个版本 scope用于说明 commit 影响的范围,可以是指定提交更改位置的任何内容,如 : 对 package.json 文件新增依赖库，chore(package.json): 新增依赖库 或对代码进行重构，refacto(weChat.vue): 重构微信进件 subject是 commit 目的的简短描述,不超过50个字符. 如果没有更合适的范围,可以直接写提交内容,格式要求如下 : 以动词开头,使用第一人称现在时,比如change,而不是changed或changes 第一个字母小写 结尾不加句号( . ) BodyBody 部分是对本次 commit 的详细描述,可以分成多行. 下面是一个范例 :1234567More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有两个注意点 : 使用第一人称现在时,比如使用change而不是changed或changes 应该说明代码变动的动机,以及与以前行为的对比 FooterFooter 部分只用于两种情况 : 不兼容变动 : 如果当前代码与上一个版本不兼容,则 Footer 部分以BREAKING CHANGE开头,后面是对变动的描述、以及变动理由和迁移方法,示例如下 : 1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: &apos;attribute&apos;, &#125; After: scope: &#123; myAttr: &apos;@&apos;, &#125; The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it. 关闭 Issue : 如果当前 commit 针对某个issue,那么可以在 Footer 部分关闭这个 issue : 1Closes #234 也可以一次关闭多个 issue :1Closes #123, #245, #992 Revert还有一种特殊情况,如果当前 commit 用于撤销以前的 commit,则必须以revert:开头，后面跟着被撤销 Commit 的 Header,示例如下 :123revert: feat(pencil): add &apos;graphiteWidth&apos; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &amp;lt;hash&gt;,其中的hash是被撤销 commit 的SHA标识符。 ✨规范参考链接 : https://github.com/vuejs/vue/commits/dev https://github.com/angular/angular/commits/master 🙏文章参考链接(获益匪浅,非常感谢) : https://www.cnblogs.com/wubaiqing/p/10307605.html http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"为GitHub量身定制的浏览器插件","slug":"为GitHub量身定制的浏览器插件","date":"2019-08-08T00:29:09.000Z","updated":"2019-08-25T06:31:01.134Z","comments":true,"path":"2019/08/08/为GitHub量身定制的浏览器插件/","link":"","permalink":"http://yoursite.com/2019/08/08/为GitHub量身定制的浏览器插件/","excerpt":"","text":"力推几款为GitHub量身定制的浏览器插件OctotreeGitHub现有的目录层级形式,在查看来自不同层级文件夹的文件的时候显得似乎不是很方便,体验相当糟糕,只能重复地点进一个文件夹,再进入其中一个文件夹,如此循环. 尤其是在文件繁多的项目之中,文件夹嵌套堪称噩梦,一个个点击太费时间和精力. 而octotree这款插件则可以解决这个痛点,他能够像 IDE 一样提供项目目录,快捷导航,方便浏览 ! https://github.com/ovity/octotree Awesome Autocomplete for GitHubAwesome Autocomplete for GitHub是一款GitHub智能搜索插件 : 有点类似自动补全功能,实时监听输入的搜索关键字,自动列出相关内容. 正如官方介绍 : 致力于打造 GitHub 上最好的搜索引擎,助你在搜索仓库和用户方面,比以往更快人一步 ! https://github.com/algolia/github-awesome-autocomplete Isometric ContributionsIsometric Contributions是一款可以将冷冰冰的数据转化为生动图形的扩展程序 : 它可以将你每天的contributions数目转化为颜色不一的立体柱状图,并给出自己的统计数据. Contributions数目由少到多分别以颜色逐渐变重的立体柱状图显示,宛如搭建一座高低错落的城市一般. 这个插件允许你在普通的 Github 贡献表与等距像素艺术版之间切换,除了”图形化”你的数据之外,它还可以将你一年内的提交状况,以及”最忙”的一天提交数目统计出来 ! https://github.com/jasonlong/isometric-contributions 更多优秀插件介绍可参考 : https://www.cnblogs.com/fang8206/p/7484703.html","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"一个基础的SpringBoot整合Shiro案例","slug":"一个基础的SpringBoot整合Shiro案例","date":"2019-08-07T04:14:55.000Z","updated":"2019-08-25T06:31:01.116Z","comments":true,"path":"2019/08/07/一个基础的SpringBoot整合Shiro案例/","link":"","permalink":"http://yoursite.com/2019/08/07/一个基础的SpringBoot整合Shiro案例/","excerpt":"","text":"学习笔记 : 一个基础的SpringBoot整合Shiro案例前些日子写了一个整合Shiro的基本Web案例,然后又进阶地学习了SpringBoot整合Shiro的基本知识,继而今天总结一下 : 写一个基础的SpringBoot整合Shiro案例~ 该案例的代码仓库 : https://github.com/YUbuntu0109/Shiro-learning/tree/master/spring%20boot%20project%20with%20shiro 数据库设计数据库ER图如下所示 : 数据表中用户及其分配的权限信息如下所示 : 账户 密码(MD5加密前) 角色 权限 admin demo admin * tea demo teacher teaListView:view , stuListView:view , stuListView:add , stuListView:edit stu demo student stuListView:view 资源权限设计springboot-shiro/src/main/java/pers/huangyuhui/ss/shiro/ShiroConfig.java : 资源过滤及其权限的配置信息如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @description: 配置过滤器 * @param: securityManager * @date: 2019-08-05 7:59 AM * @return: org.apache.shiro.spring.web.ShiroFilterFactoryBean */@Beanpublic ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //设置自定义过滤器 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap()); //设置用户登录页,默认: http://localhost:8080/login.jsp shiroFilterFactoryBean.setLoginUrl(\"/loginView\"); //设置用户未授权操作提示页 shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorizedView\"); return shiroFilterFactoryBean;&#125;/** * @description: 设置资源的权限控制 * @date: 2019-08-05 8:31 AM * @return: java.util.Map */private Map&lt;String, String&gt; filterChainDefinitionMap() &#123; Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); //需身份认证 filterMap.put(\"/stuListView\", \"authc\"); filterMap.put(\"/teaListView\", \"authc\"); //无需身份认证:防止验证用户登录信息操作被'filterMap.put(\"/**\", \"authc\")'拦截 filterMap.put(\"/login\", \"anon\"); //注销过滤器:其具体的注销逻辑代码Shiro已经替我们实现了哟 filterMap.put(\"/logout\", \"logout\"); //角色过滤:需要用户拥有'admin'角色 filterMap.put(\"/teaListView\", \"roles[admin]\"); //权限过滤:除身份认证外,还需要用户拥有对stuListView资源的view权限 filterMap.put(\"/stuListView\", \"perms[stuListView:view]\"); filterMap.put(\"/teaListView\", \"perms[teaListView:view]\"); //拦截需要登录(用户认证)方可访问的资源(一般将/**放在最下边,不然会导致所有url都被拦截哟) filterMap.put(\"/**\", \"authc\"); return filterMap;&#125;// ······ 凭证加密设计springboot-shiro/src/main/java/pers/huangyuhui/ss/shiro/ShiroConfig.java : 用户凭证加密的配置信息如下(盐值:用户名)1234567891011121314151617181920212223242526272829/** * @description: 初始化自定义Realm * @param: credentialsMatcher * @date: 2019-08-05 7:50 AM * @return: pers.huangyuhui.ss.shiro.UserRealm */@Beanpublic UserRealm userRealm(HashedCredentialsMatcher hashedCredentialsMatcher) &#123; UserRealm userRealm = new UserRealm(); //设置凭证匹配器 userRealm.setCredentialsMatcher(hashedCredentialsMatcher); return userRealm;&#125;/** * @description: 哈希密码匹配器:比较用户登录时输入的密码,跟数据库密码配合盐值salt解密后是否一致 * @date: 2019-08-05 9:01 PM * @return: org.apache.shiro.authc.credential.HashedCredentialsMatcher */@Beanpublic HashedCredentialsMatcher hashedCredentialsMatcher() &#123; HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName(\"md5\"); //散列算法 hashedCredentialsMatcher.setHashIterations(3); //散列的次数 hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true); //默认是true:Hex编码.false:Base64编码 return hashedCredentialsMatcher;&#125;// ······ springboot-shiro/src/main/java/pers/huangyuhui/ss/utils/SecurityUtils.java : 密码加密逻辑如下123456789101112131415161718/** * @project: springboot-shiro * @description: 加密工具 * @author: 黄宇辉 * @date: 8/5/2019-9:09 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SecurityUtils &#123; public static void main(String[] args) &#123; //admin-pwd [source:demo+salt:admin+hashIterations:3] : 257e3b15d67a9127d230175e43118e40 //tea-pwd [source:demo+salt:tea+hashIterations:3] : f97ccdcf125073d5f19bd3de0b67eb40 //stu-pwd [source:demo+salt:stu+hashIterations:3] : e1a1c9a1340d179077086b5dbee621b4 String md5Pwd = new SimpleHash(\"md5\", \"demo\", ByteSource.Util.bytes(\"stu\"), 3).toHex(); System.out.println(md5Pwd); &#125;&#125; Thymeleaf整合Shiro标签springboot-shiro/src/main/java/pers/huangyuhui/ss/shiro/ShiroConfig.java : Thymeleaf整合Shiro标签的配置如下123456789 /** * @description: 配置ShiroDialect, 用于thymeleaf和shiro标签配合使用 * @date: 2019-08-05 6:37 PM * @return: at.pollux.thymeleaf.shiro.dialect.ShiroDialect */ @Bean public ShiroDialect shiroDialect() &#123; return new ShiroDialect();&#125; Shiro集成EhCache缓存springboot-shiro/src/main/java/pers/huangyuhui/ss/shiro/ShiroConfig.java : Shiro集成EhCache的配置信息如下12345678910111213141516171819202122232425262728293031323334 /** * @description: 安全事务管理器 * @param: credentialsMatcher * @date: 2019-08-05 7:53 AM * @return: org.apache.shiro.web.mgt.DefaultWebSecurityManager */ @Bean public SecurityManager securityManager(UserRealm userRealm, EhCacheManager ehCacheManager) &#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); //关联自定义realm defaultWebSecurityManager.setRealm(userRealm); //关联缓存管理 defaultWebSecurityManager.setCacheManager(ehCacheManager); return defaultWebSecurityManager; &#125; /** * @description: 设置缓存管理, 缓存用户及其权限信息 * @date: 2019-08-07 7:51 AM * @return: org.apache.shiro.cache.ehcache.EhCacheManager */ @Bean public EhCacheManager ehCacheManager() &#123; //注意:myEhcache对应ehcache-shiro.xml中的'&lt;ehcache name=\"myEhcache\"&gt;' CacheManager cacheManager = CacheManager.getCacheManager(\"myEhcache\"); if (cacheManager == null) &#123; cacheManager = CacheManager.create(); &#125; EhCacheManager ehCacheManager = new EhCacheManager(); ehCacheManager.setCacheManager(cacheManager); return ehCacheManager; // ······&#125; 案例截屏解析用户登录页,访问资源前必须先进行用户身份认证,详情参考资源拦截器中的配置信息哟 若要访问教师 / 学生信息管理页,需要用户拥有teaListView:view / stuListView:view权限 管理员( admin )拥有访问资源的所有权限( ),所以可以操控学生信息页面中的任何操作* 管理员( admin )拥有访问资源的所有权限( ),所以可以操控教师信息页面中的任何操作* 教师( tea )拥有学生页面的stuListView:view , stuListView:add , stuListView:edit权限,所以删除信息操作为不可见 教师( tea )仅拥有教师信息管理页面的teaListView:view权限,所以增,删,改,操作为不可见状态 学生( stu )仅拥有学生信息管理页面的stuListView:view权限,所以增,删,改,操作为不可见状态 学生( stu )没有访问教师信息管理页面的权限,所以被资源拦截器所拦截继而进入指定的’unauthorized.html’页面 数据库设计参考了(非常感谢) : https://www.jianshu.com/p/7716951f4d7f","categories":[],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://yoursite.com/tags/Thymeleaf/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"EhCache","slug":"EhCache","permalink":"http://yoursite.com/tags/EhCache/"}]},{"title":"详解Shiro的缓存机制","slug":"详解Shiro的缓存机制","date":"2019-08-07T04:12:16.000Z","updated":"2019-08-25T06:31:01.212Z","comments":true,"path":"2019/08/07/详解Shiro的缓存机制/","link":"","permalink":"http://yoursite.com/2019/08/07/详解Shiro的缓存机制/","excerpt":"","text":"学习笔记 : 详解Shiro的缓存机制简介Shiro作为一个开源的权限框架,其组件化的设计思想使得开发者可以根据具体业务场景灵活地实现权限管理方案,权限粒度的控制非常方便,Shiro框架的架构图如下所示 : 从上图我们可以很清晰地看到,CacheManager也是Shiro架构中的主要组件之一,Shiro正是通过CacheManager组件实现权限数据缓存.当权限信息存放在数据库中时,对于每次前端的访问请求都需要进行一次数据库查询. 特别是在大量使用shiro的jsp标签的场景下,对应前端的一个页面访问请求会同时出现很多的权限查询操作,这对于权限信息变化不是很频繁的场景,每次前端页面访问都进行大量的权限数据库查询是非常不经济的! 因此非常有必要对权限数据使用缓存方案~ Shiro权限数据的缓存方式关于shiro权限数据的缓存方式,可以分为以下两类 : 将权限数据缓存到集中式存储中间件中,比如redis或者memcached 将权限数据缓存到本地 如何在Shiro中使用缓存根据Shiro官方的说法,虽然缓存在权限框架中非常重要,但是如果实现一套完整的缓存机制会使得Shiro偏离了核心的功能(认证和授权). 因此Shiro只提供了一个可以支持具体缓存实现(如 : Hazelcast, Ehcache, OSCache, Terracotta, Coherence, GigaSpaces, JBossCache 等)的抽象API接口,这样就允许Shiro用户根据自己的需求灵活地选择具体的CacheManager,当然,其实Shiro也自带了一个本地内存CacheManager(org.apache.shiro.cache.MemoryConstrainedCacheManager),Shiro的缓存组件类图如下所示 : 从Shiro缓存组件类图可以看到,Shiro提供的缓存抽象API接口正是 : org.apache.shiro.cache.CacheManager,那么我们应该如何配置和使用CacheManager呢 ? 如下我们以使用Shiro提供的MemoryConstrainedCacheManager组件为例进行说明. 我们知道,SecurityManager是Shiro的核心控制器,我们来看一下其类图 : org.apache.shiro.mgt.CachingSecurityManager是Shiro中SecurityManager接口的基础抽象类,我们来看一下其源码结构(如下所示),发现在CachingSecurityManager中存在一个CacheManager类型的成员变量1234567891011121314151617181920212223public abstract class CachingSecurityManager implements SecurityManager, Destroyable, CacheManagerAware, EventBusAware &#123; /** * The CacheManager to use to perform caching operations to enhance performance. Can be null. */ private CacheManager cacheManager; /** * The EventBus to use to use to publish and receive events of interest during Shiro's lifecycle. * @since 1.3 */ private EventBus eventBus; /** * Default no-arg constructor that will automatically attempt to initialize a default cacheManager */ public CachingSecurityManager() &#123; //use a default event bus: setEventBus(new DefaultEventBus()); &#125; // ······&#125; 另外,接口org.apache.shiro.realm.Realm定义了权限数据的存储方式,其类图如下所示 : 显然,org.apache.shiro.realm.CachingRealm是Shiro中Realm接口的基础实现类,我们同样来看一下其源码结构(如下所示),发现同样在CachingRealm也存在一个CacheManager类型的成员变量123456789101112131415161718192021222324252627282930public abstract class CachingRealm implements Realm, Nameable, CacheManagerAware, LogoutAware &#123; private static final Logger log = LoggerFactory.getLogger(CachingRealm.class); //TODO - complete JavaDoc private static final AtomicInteger INSTANCE_COUNT = new AtomicInteger(); /*-------------------------------------------- | I N S T A N C E V A R I A B L E S | ============================================*/ private String name; private boolean cachingEnabled; private CacheManager cacheManager; /** * Default no-argument constructor that defaults * &#123;@link #isCachingEnabled() cachingEnabled&#125; (for general caching) to &#123;@code true&#125; and sets a * default &#123;@link #getName() name&#125; based on the class name. * &lt;p/&gt; * Note that while in general, caching may be enabled by default, subclasses have control over * if specific caching is enabled. */ public CachingRealm() &#123; this.cachingEnabled = true; this.name = getClass().getName() + \"_\" + INSTANCE_COUNT.getAndIncrement(); &#125; // ······&#125; 总结从以上分析我们知道Shiro支持在2个地方定义缓存管理器,既可以在SecurityManager中定义,也可以在Realm中定义,任选其一即可. 通常我们都会自定义Realm实现,例如将权限数据存放在数据库中,那么在Realm实现中定义缓存管理器再合适不过了 那么我们不禁要问了 : 第一 : 为什么Shiro要设计成既可以在Realm,也可以在SecurityManager中设置缓存管理器呢 ? 第二 : 分别在Realm和SecurityManager定义的缓存管理器,他们有什么区别或联系吗 ? 怀着种种疑问让我们追踪一下org.apache.shiro.mgt.RealmSecurityManae的源码实现,如下所示 :12345678910111213141516171819202122232425262728public abstract class RealmSecurityManager extends CachingSecurityManager &#123; /** * Sets the internal &#123;@link #getCacheManager CacheManager&#125; on any internal configured * &#123;@link #getRealms Realms&#125; that implement the &#123;@link org.apache.shiro.cache.CacheManagerAware CacheManagerAware&#125; interface. * &lt;p/&gt; * This method is called after setting a cacheManager on this securityManager via the * &#123;@link #setCacheManager(org.apache.shiro.cache.CacheManager) setCacheManager&#125; method to allow it to be propagated * down to all the internal Realms that would need to use it. * &lt;p/&gt; * It is also called after setting one or more realms via the &#123;@link #setRealm setRealm&#125; or * &#123;@link #setRealms setRealms&#125; methods to allow these newly available realms to be given the cache manager * already in use. */ protected void applyCacheManagerToRealms() &#123; CacheManager cacheManager = getCacheManager(); Collection&lt;Realm&gt; realms = getRealms(); if (cacheManager != null &amp;&amp; realms != null &amp;&amp; !realms.isEmpty()) &#123; for (Realm realm : realms) &#123; if (realm instanceof CacheManagerAware) &#123; ((CacheManagerAware) realm).setCacheManager(cacheManager); &#125; &#125; &#125; &#125; // ······&#125; 这下恍然大悟了吧 ! 从源码可以分析出其实在SecurityManager中设置的CacheManager都会给Realm使用,即真正使用CacheManager的组件是Realm 🙏摘自(获益匪浅,非常感谢) : https://www.cnblogs.com/nuccch/p/8044226.html","categories":[],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"SpringBoot中Shiro集成EhCache","slug":"SpringBoot中Shiro集成EhCache","date":"2019-08-07T04:10:32.000Z","updated":"2019-08-25T06:31:01.059Z","comments":true,"path":"2019/08/07/SpringBoot中Shiro集成EhCache/","link":"","permalink":"http://yoursite.com/2019/08/07/SpringBoot中Shiro集成EhCache/","excerpt":"","text":"学习笔记 : SpringBoot项目中Shiro集成EhCache示例程序摘自 : 一个简单的SpringBoot整合Shiro的权限管理案例 添加依赖Shiro-learning/spring boot project with shiro/springboot-shiro/pom.xml1234567891011121314&lt;dependencies&gt; &lt;!-- Shiro --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Ehcache --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建EhCache缓存配置文件Shiro-learning/spring boot project with shiro/springboot-shiro/src/main/resources/ehcache-shiro.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\" name=\"myEhcache\"&gt; &lt;diskStore path=\"java.io.tmpdir\"/&gt; &lt;!-- 授权信息缓存 --&gt; &lt;cache name=\"authorizationCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- 身份信息缓存 --&gt; &lt;cache name=\"authenticationCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- Session缓存 --&gt; &lt;cache name=\"activeSessionCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- 缓存半小时 --&gt; &lt;cache name=\"halfHour\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- 缓存一小时 --&gt; &lt;cache name=\"hour\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"3600\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- 缓存一天 --&gt; &lt;cache name=\"oneDay\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"86400\" timeToLiveSeconds=\"86400\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- name: 缓存名称。 maxElementsInMemory: 缓存最大个数 eternal: 对象是否永久有效,一但设置了,timeout将不起作用 timeToIdleSeconds: 设置对象在失效前的允许闲置时间(单位：秒). 仅当eternal=false对象不是永久有效时使用,可选属性,默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds: 设置对象在失效前允许存活时间(单位：秒). 最大时间介于创建时间和失效时间之间. 仅当eternal=false对象不是永久有效时使用,默认是0,也就是对象存活时间无穷大 overflowToDisk: 当内存中对象数量达到maxElementsInMemory时,Ehcache将会对象写到磁盘中 diskSpoolBufferSizeMB: 这个参数设置DiskStore(磁盘缓存)的缓存区大小,默认是30MB. 每个Cache都应该有自己的一个缓冲区 maxElementsOnDisk: 硬盘最大缓存个数 diskPersistent: 是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskExpiryThreadIntervalSeconds: 磁盘失效线程运行时间间隔,默认是120秒 memoryStoreEvictionPolicy: 当达到maxElementsInMemory限制时,Ehcache将会根据指定的策略去清理内存. 默认策略是LRU(最近最少使用). 你可以设置为FIFO(先进先出)或是LFU(较少使用) clearOnFlush: 内存数量最大时是否清除 --&gt; &lt;defaultCache name=\"defaultCache\" maxElementsInMemory=\"10000\" timeToIdleSeconds=\"600\" timeToLiveSeconds=\"600\" overflowToDisk=\"false\" maxElementsOnDisk=\"100000\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 配置Shiro缓存Shiro-learning/spring boot project with shiro/springboot-shiro/src/main/java/pers/huangyuhui/ss/shiro/ShiroConfig.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @project: springboot-shiro * @description: Shiro配置信息 * @author: 黄宇辉 * @date: 8/5/2019-7:41 AM * @version: 1.1 * @website: https://yubuntu0109.github.io/ */@Configurationpublic class ShiroConfig &#123; /** * @description: 安全事务管理器 * @param: credentialsMatcher * @date: 2019-08-05 7:53 AM * @return: org.apache.shiro.web.mgt.DefaultWebSecurityManager */ @Bean public SecurityManager securityManager(UserRealm userRealm, EhCacheManager ehCacheManager) &#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); //关联自定义realm defaultWebSecurityManager.setRealm(userRealm); //关联缓存管理 defaultWebSecurityManager.setCacheManager(ehCacheManager); return defaultWebSecurityManager; &#125; /** * @description: 设置缓存管理器, 缓存用户及其权限信息 * @date: 2019-08-07 7:51 AM * @return: org.apache.shiro.cache.ehcache.EhCacheManager */ @Bean public EhCacheManager ehCacheManager() &#123; //注意:myEhcache对应ehcache-shiro.xml中的'&lt;ehcache name=\"myEhcache\"&gt;' CacheManager cacheManager = CacheManager.getCacheManager(\"myEhcache\"); if (cacheManager == null) &#123; cacheManager = CacheManager.create(); &#125; EhCacheManager ehCacheManager = new EhCacheManager(); ehCacheManager.setCacheManager(cacheManager); return ehCacheManager; &#125; // ······&#125; 注意事项如果使用的EhCache版本超过了2.5.0,那么&lt;ehcache name=&quot;myEhcache&quot;&gt;的配置就显得非常重要了,不然EhCache会自动加载默认的名字 : _default_,且EhCache2.5以后只允许创建单例的CacheManager(缓存管理器),所以应注意避免重复加载CacheManager哟 : 创建ehCacheManager的时先判断是否已存在cacheManager,没有的情况下再进行创建,判断的关键为ehcache-shiro.xml(缓存配置文件)中配置的name属性,可通过该属性来判断cacheManager是否加载了,示例代码如下 : 1234CacheManager cacheManager = CacheManager.getCacheManager(\"myEhcache\"); if (cacheManager == null) &#123; cacheManager = CacheManager.create(); &#125; 借鉴(非常感谢) : https://blog.csdn.net/Maslii/article/details/82380568","categories":[],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"EhCache","slug":"EhCache","permalink":"http://yoursite.com/tags/EhCache/"}]},{"title":"详解Intellij IDEA中的DEBUG功能","slug":"详解Intellij-IDEA中的DEBUG功能","date":"2019-08-06T07:21:34.000Z","updated":"2019-08-25T06:31:01.208Z","comments":true,"path":"2019/08/06/详解Intellij-IDEA中的DEBUG功能/","link":"","permalink":"http://yoursite.com/2019/08/06/详解Intellij-IDEA中的DEBUG功能/","excerpt":"","text":"学习笔记 : 详解Intellij IDEA中的DEBUG功能Debug用于追踪代码的执行流程,其主要用途如下 : 若程序运行过程中出现异常,可通过启用Debug模式来分析程序运行过程中各个参数的变化,继而定位到异常发生的位置 通过启用Debug模式来跟踪代码的运行流程,继而去学习一些第三方框架的源码 基本用法&amp;快捷键IDEA版本 : Intellij IDEA 2019.1.3-UItimate Edition 如上debug视图,从上到下依次讲解 : Show Execution Point (Alt + F10) : 如果你的光标在其它行或其它页面,点击这个按钮可跳转到当前代码执行的行 Step Over (F6) : 步过,一行一行地往下走,如果这一行上有方法,并不会进入 Step Into (F5) : 步入,如果当前行有方法,可以进入方法内部,一般用于进入自定义方法内,不会进入官方类库的方法 Force Step Into (Alt + Shift + F7) : 强制步入,能进入任何方法,查看底层源码的时候可以用这个进入官方类库的方法 Step Out (F7) : 步出,从步入的方法内退出到方法调用处,此时方法已执行完毕,只是还没有完成赋值 Drop Frame (默认无) : 回退断点,后面章节详细说明 Run to Cursor (Ctrl + R) : 运行到光标处,你可以将光标定位到你需要查看的那一行,然后使用这个功能,代码会运行至光标行,而不需要打断点哟 Evaluate Expression (Ctrl + U) : 计算表达式,后面章节详细说明 从左到右依次讲解 : 如上debug视图,从左到右依次讲解 : Rerun &#39;xxx&#39;(Ctrl + F11) : 重新运行程序,会关闭服务后重新启动程序 Update &#39;xxx&#39; application (Ctrl + F10) : 更新程序,一般在你的代码有改动后可执行这个功能. 而这个功能对应的操作则是在服务配置里,一般配合热部署插件会更好用,如JRebel,这样就不用每次更改代码后还要去重新启动服务啦 Resume Program (F8) : 恢复程序,比如你在第20行和25行有两个断点,当前运行至第20行时按F9,则运行到下一个断点(即第25行),再按F9则运行完整个流程,因为后面已经没有断点咯 Pause Program : 暂停程序,启用Debug Stop &#39;xxx&#39; (Ctrl + F2) : 连续按两下会关闭程序,有时候你会发现关闭服务再启动时,报端口被占用,这是因为没完全关闭服务的原因,这时就需要你查杀指定的JVM进程啦 View Breakpoints (Ctrl + Shift + F8) : 查看所有断点,后面章节会涉及到 Mute Breakpoints : 哑的断点,既选择这个后,所有断点变为灰色,断点失效,按F9则可以直接运行完程序. 再次点击,断点变为红色,有效. 如果只想使某一个断点失效,则可以在断点上右键,然后取消Enabled 更多内容请参考(老版本哟,无碍啦~) : https://www.cnblogs.com/nihaorz/p/7613967.html .","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}]},{"title":"Thymeleaf整合Shiro标签","slug":"Thymeleaf整合Shiro标签","date":"2019-08-06T07:16:26.000Z","updated":"2019-08-25T06:31:01.063Z","comments":true,"path":"2019/08/06/Thymeleaf整合Shiro标签/","link":"","permalink":"http://yoursite.com/2019/08/06/Thymeleaf整合Shiro标签/","excerpt":"","text":"学习笔记 : Thymeleaf整合Shiro标签详情请参考 : 一个简单的SpringBoot整合Shiro的权限管理案例 引入依赖添加Thymeleaf及其对Shiro扩展的依赖1234567891011&lt;!-- Thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Thymeleaf对shiro的扩展 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 配置在Shiro的配置类中配置ShiroDialect123456789 /** * @description: 配置ShiroDialect, 用于thymeleaf和shiro标签配合使用 * @date: 2019-08-05 6:37 PM * @return: at.pollux.thymeleaf.shiro.dialect.ShiroDialect */ @Bean public ShiroDialect shiroDialect() &#123; return new ShiroDialect();&#125; 添加HTML命令空间1&lt;html lang=\"zh_CN\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:shiro=\"http://www.pollix.at/thymeleaf/shiro\"&gt; Thymealf+Shiro标签123456789101112131415161718192021222324252627282930&lt;!-- guest标签:用户没有身份验证时显示相应信息,即游客访问信息 --&gt;&lt;shiro:guest&gt;&lt;/shiro:guest&gt;&lt;!-- user标签:用户已经身份验证/记住我登录后显示相应的信息 --&gt;&lt;shiro:user&gt;&lt;/shiro:user&gt;&lt;!-- authenticated标签:用户已经身份验证通过,即Subject.login登录成功,不是记住我登录的 --&gt;&lt;shiro:authenticated&gt;&lt;/shiro:authenticated&gt;&lt;!-- notAuthenticated标签:用户已经身份验证通过,即没有调用Subject.login进行登录,包括记住我,自动登录的也属于未进行身份验证 --&gt;&lt;shiro:notAuthenticated&gt;&lt;/shiro:notAuthenticated&gt;&lt;!-- principal标签:相当于((User)Subject.getPrincipals()).getUsername() --&gt;&lt;shiro: principal/&gt;&lt;shiro:principal property=\"username\"/&gt; &lt;!-- lacksPermission标签:如果当前Subject没有权限将显示body体内容 --&gt;&lt;shiro:lacksPermission name=\"org:create\"&gt;&lt;/shiro:lacksPermission&gt;&lt;!-- hasRole标签:如果当前Subject有角色将显示body体内容 --&gt;&lt;shiro:hasRole name=\"admin\"&gt;&lt;/shiro:hasRole&gt;&lt;!-- hasAnyRoles标签:如果当前Subject有任意一个角色（或的关系）将显示body体内容 --&gt;&lt;shiro:hasAnyRoles name=\"admin,user\"&gt;&lt;/shiro:hasAnyRoles&gt;&lt;!-- lacksRole标签:如果当前Subject没有角色将显示body体内容 --&gt;&lt;shiro:lacksRole name=\"abc\"&gt;&lt;/shiro:lacksRole&gt; &lt;!-- hasPermission标签:如果当前Subject有权限将显示body体内容 --&gt;&lt;shiro:hasPermission name=\"user:create\"&gt;&lt;/shiro:hasPermission&gt; 🙂参考(非常感谢) : https://www.jianshu.com/p/c8b53445cbb0","categories":[],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://yoursite.com/tags/Thymeleaf/"}]},{"title":"SpringBoot集成Shiro的基本配置","slug":"SpringBoot集成Shiro的基本配置","date":"2019-08-06T07:13:51.000Z","updated":"2019-08-25T06:31:01.062Z","comments":true,"path":"2019/08/06/SpringBoot集成Shiro的基本配置/","link":"","permalink":"http://yoursite.com/2019/08/06/SpringBoot集成Shiro的基本配置/","excerpt":"","text":"学习笔记 : SpringBoot集成Shiro的基本配置Spring集成Shiro一般通过的 xml 配置,比较繁琐,而Spring Boot集成Shiro相对简单,只需要配置两个类 : ShiroConfiguration类及继承AuthorizingRealm的Realm类,如下所示 : ShiroConfig : 顾名思义就是对Shiro的一些配置,相对于Spring中的xml配置. 包括 : 包括过滤器(ShiroFilter)、安全事务管理器(SecurityManager)、密码凭证匹配器(CredentialsMatcher)、缓冲管理器(EhCacheManager)、aop注解支持(authorizationAttributeSourceAdvisor)、等等 CustomRealm : 自定义的CustomRealm继承自AuthorizingRealm,重写了父类中的doGetAuthorizationInfo(授权认证)、doGetAuthenticationInfo(登陆认证)这两个方法 基本的配置以下示例代码摘自 : 一个简单的SpringBoot集成Shiro的权限管理案例 Shiro的基本配置信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package pers.huangyuhui.ss.shiro;import at.pollux.thymeleaf.shiro.dialect.ShiroDialect;import net.sf.ehcache.CacheManager;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.cache.ehcache.EhCacheManager;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.LinkedHashMap;import java.util.Map;/** * @project: springboot-shiro * @description: Shiro配置信息 * @author: 黄宇辉 * @date: 8/5/2019-7:41 AM * @version: 1.1 * @website: https://yubuntu0109.github.io/ */@Configurationpublic class ShiroConfig &#123; /** * @description: 配置过滤器 * @param: securityManager * @date: 2019-08-05 7:59 AM * @return: org.apache.shiro.spring.web.ShiroFilterFactoryBean */ @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //设置自定义过滤器 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap()); //设置用户登录页,默认: http://localhost:8080/login.jsp shiroFilterFactoryBean.setLoginUrl(\"/loginView\"); //设置用户未授权操作提示页 shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorizedView\"); return shiroFilterFactoryBean; &#125; /** * @description: 初始化自定义Realm * @param: credentialsMatcher * @date: 2019-08-05 7:50 AM * @return: pers.huangyuhui.ss.shiro.UserRealm */ @Bean public UserRealm userRealm(HashedCredentialsMatcher hashedCredentialsMatcher) &#123; UserRealm userRealm = new UserRealm(); //设置凭证匹配器 userRealm.setCredentialsMatcher(hashedCredentialsMatcher); return userRealm; &#125; /** * @description: 安全事务管理器 * @param: credentialsMatcher * @date: 2019-08-05 7:53 AM * @return: org.apache.shiro.web.mgt.DefaultWebSecurityManager */ @Bean public SecurityManager securityManager(UserRealm userRealm, EhCacheManager ehCacheManager) &#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); //关联自定义realm defaultWebSecurityManager.setRealm(userRealm); //关联缓存管理 defaultWebSecurityManager.setCacheManager(ehCacheManager); return defaultWebSecurityManager; &#125; /** * @description: 哈希密码匹配器:比较用户登录时输入的密码,跟数据库密码配合盐值salt解密后是否一致 * @date: 2019-08-05 9:01 PM * @return: org.apache.shiro.authc.credential.HashedCredentialsMatcher */ @Bean public HashedCredentialsMatcher hashedCredentialsMatcher() &#123; HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName(\"md5\"); //散列算法 hashedCredentialsMatcher.setHashIterations(3); //散列的次数 hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true); //默认是true:Hex编码.false:Base64编码 return hashedCredentialsMatcher; &#125; /** * @description: 设置缓存管理, 缓存用户及其权限信息 * @date: 2019-08-07 7:51 AM * @return: org.apache.shiro.cache.ehcache.EhCacheManager */ @Bean public EhCacheManager ehCacheManager() &#123; //注意:myEhcache对应ehcache-shiro.xml中的'&lt;ehcache name=\"myEhcache\"&gt;' CacheManager cacheManager = CacheManager.getCacheManager(\"myEhcache\"); if (cacheManager == null) &#123; cacheManager = CacheManager.create(); &#125; EhCacheManager ehCacheManager = new EhCacheManager(); ehCacheManager.setCacheManager(cacheManager); return ehCacheManager; &#125; /** * @description: 设置资源的权限控制 * @date: 2019-08-05 8:31 AM * @return: java.util.Map */ private Map&lt;String, String&gt; filterChainDefinitionMap() &#123; Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); //需身份认证 filterMap.put(\"/stuListView\", \"authc\"); filterMap.put(\"/teaListView\", \"authc\"); //无需身份认证:防止验证用户登录信息操作被'filterMap.put(\"/**\", \"authc\")'拦截 filterMap.put(\"/login\", \"anon\"); //注销过滤器:其具体的注销逻辑代码Shiro已经替我们实现了哟 filterMap.put(\"/logout\", \"logout\"); //角色过滤:需要用户拥有'admin'角色 filterMap.put(\"/teaListView\", \"roles[admin]\"); //权限过滤:除身份认证外,还需要用户拥有对stuListView资源的view权限 filterMap.put(\"/stuListView\", \"perms[stuListView:view]\"); filterMap.put(\"/teaListView\", \"perms[teaListView:view]\"); //拦截需要登录(用户认证)方可访问的资源(一般将/**放在最下边,不然会导致所有url都被拦截哟) filterMap.put(\"/**\", \"authc\"); return filterMap; &#125; /** * @description: 配置ShiroDialect, 用于thymeleaf和shiro标签配合使用 * @date: 2019-08-05 6:37 PM * @return: at.pollux.thymeleaf.shiro.dialect.ShiroDialect */ @Bean public ShiroDialect shiroDialect() &#123; return new ShiroDialect(); &#125;&#125; ehcache-shiro.xml : EhCache缓存框架的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\" name=\"myEhcache\"&gt; &lt;diskStore path=\"java.io.tmpdir\"/&gt; &lt;!-- 授权信息缓存 --&gt; &lt;cache name=\"authorizationCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- 身份信息缓存 --&gt; &lt;cache name=\"authenticationCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- Session缓存 --&gt; &lt;cache name=\"activeSessionCache\" maxEntriesLocalHeap=\"2000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" statistics=\"true\"&gt; &lt;/cache&gt; &lt;!-- 缓存半小时 --&gt; &lt;cache name=\"halfHour\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- 缓存一小时 --&gt; &lt;cache name=\"hour\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"3600\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- 缓存一天 --&gt; &lt;cache name=\"oneDay\" maxElementsInMemory=\"10000\" maxElementsOnDisk=\"100000\" timeToIdleSeconds=\"86400\" timeToLiveSeconds=\"86400\" overflowToDisk=\"false\" diskPersistent=\"false\"/&gt; &lt;!-- name: 缓存名称。 maxElementsInMemory: 缓存最大个数 eternal: 对象是否永久有效,一但设置了,timeout将不起作用 timeToIdleSeconds: 设置对象在失效前的允许闲置时间(单位：秒). 仅当eternal=false对象不是永久有效时使用,可选属性,默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds: 设置对象在失效前允许存活时间(单位：秒). 最大时间介于创建时间和失效时间之间. 仅当eternal=false对象不是永久有效时使用,默认是0,也就是对象存活时间无穷大 overflowToDisk: 当内存中对象数量达到maxElementsInMemory时,Ehcache将会对象写到磁盘中 diskSpoolBufferSizeMB: 这个参数设置DiskStore(磁盘缓存)的缓存区大小,默认是30MB. 每个Cache都应该有自己的一个缓冲区 maxElementsOnDisk: 硬盘最大缓存个数 diskPersistent: 是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskExpiryThreadIntervalSeconds: 磁盘失效线程运行时间间隔,默认是120秒 memoryStoreEvictionPolicy: 当达到maxElementsInMemory限制时,Ehcache将会根据指定的策略去清理内存. 默认策略是LRU(最近最少使用). 你可以设置为FIFO(先进先出)或是LFU(较少使用) clearOnFlush: 内存数量最大时是否清除 --&gt; &lt;defaultCache name=\"defaultCache\" maxElementsInMemory=\"10000\" timeToIdleSeconds=\"600\" timeToLiveSeconds=\"600\" overflowToDisk=\"false\" maxElementsOnDisk=\"100000\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 自定义Realm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package pers.huangyuhui.ss.shiro;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.ByteSource;import org.springframework.beans.factory.annotation.Autowired;import pers.huangyuhui.ss.bean.Permission;import pers.huangyuhui.ss.bean.Role;import pers.huangyuhui.ss.bean.User;import pers.huangyuhui.ss.service.UserService;import java.util.Collection;import java.util.HashSet;import java.util.Set;/** * @project: springboot-shiro * @description: 配置自定义Realm * @author: 黄宇辉 * @date: 8/5/2019-7:45 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class UserRealm extends AuthorizingRealm &#123; @Autowired private UserService userService; /** * @description: 授权认证:提供用户信息,返回权限信息 * @param: principalCollection * @date: 2019-08-06 6:02 PM * @return: org.apache.shiro.authz.AuthorizationInfo */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.err.println(\"------------&gt; 授权认证 ------------&gt;\"); //获取当前登录的用户信息 Subject currentUser = SecurityUtils.getSubject(); User u = (User) currentUser.getPrincipal(); //从数据库中获取用户所拥有的角色及权限信息 User user = userService.findByName(u.getUsername()); if (user != null) &#123; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //用于存储用户的角色及权限信息 Collection&lt;String&gt; rolesCollection = new HashSet&lt;&gt;(); Collection&lt;String&gt; permissionsCollection = new HashSet&lt;&gt;(); Set&lt;Role&gt; roles = user.getRoles(); //获取用户Role的Set集合 //通过遍历用户所拥有的角色,来获取其对应的权限信息 for (Role role : roles) &#123; rolesCollection.add(role.getName()); //将每一个role的name封装到集合中 Set&lt;Permission&gt; permissionSet = role.getPermissions(); //获取每一个role所对应的permission的set集合 //遍历用户所拥有的权限信息 for (Permission permission : permissionSet) &#123; permissionsCollection.add(permission.getName()); //将每一个permission的name封装到集合中 &#125; info.addStringPermissions(permissionsCollection); //为用户授权 &#125; info.addRoles(rolesCollection); //为用户授予角色 System.out.println(\"[roles]------------&gt;\" + rolesCollection.toString()); System.out.println(\"[permissions]------------&gt;\" + permissionsCollection.toString()); return info; &#125; return null; &#125; /** * @description: 登录认证:提供帐户信息,返回认证信息 * @param: authenticationToken * @date: 2019-08-06 6:12 PM * @return: org.apache.shiro.authc.AuthenticationInfo */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.err.println(\"------------&gt; 开始认证 ------------&gt;\"); UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; //从数据库中获取用户信息 User user = userService.findByName(token.getUsername()); //验证账户信息 if (user == null) &#123; return null; //it's will be throw a UnknownAccountException &#125; //验证密码信息 return new SimpleAuthenticationInfo(user, user.getPassword(), ByteSource.Util.bytes(user.getUsername()), this.getName()); &#125;&#125;","categories":[],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"一个基础的Web整合Shiro案例","slug":"一个基础的Web整合Shiro案例","date":"2019-08-04T05:15:15.000Z","updated":"2019-08-25T06:31:01.122Z","comments":true,"path":"2019/08/04/一个基础的Web整合Shiro案例/","link":"","permalink":"http://yoursite.com/2019/08/04/一个基础的Web整合Shiro案例/","excerpt":"","text":"学习笔记 : 一个基础的Web整合Shiro案例总结前面Shiro的基本学习笔记,继而尝试整合web,来写一个基础的Web整合Shiro案例( Java web ),用户权限划分如下,该案例的代码仓库 : https://github.com/YUbuntu0109/Shiro-learning/tree/master/basic%20web%20project%20with%20shiro 管理员(admin) : 具有操控部门/员工信息管理页的所有权限 用户(yuhui) : 仅具有部门信息的view权限 环境配置 baseWebShiro\\pom.xml : Maven依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;pers.huangyuhui&lt;/groupId&gt; &lt;artifactId&gt;baseWebShiro&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;description&gt;a simple web program for Shiro&lt;/description&gt; &lt;dependencies&gt; &lt;!-- Serlvet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Shiro core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Shiro web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- logging --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; baseWebShiro\\src\\main\\resources\\shiro.ini : 用户身份及权限信息 1234567891011121314151617181920212223242526272829[main]# 默认登录页为:/login.jspauthc.loginUrl = /login# 用户没有访问指定资源的角色时所跳转的页面roles.unauthorizedUrl = /nopermission.jsp# 用户没有访问指定资源的权限时所跳转的页面perms.unauthorizedUrl = /nopermission.jsp# 登出之后重定向的页面logout.redirectUrl = /login[users]admin = 666,adminyuhui = 777,deptManager[roles ]admin = employee:*,department:*deptManager = department:view[urls]# 静态资源可以匿名访问/static/** = anon# 访问员工列表需要身份认证及需要用户拥有'admin'角色/employee = authc,roles[admin]# 访问部门列表需要身份认证及需要用户拥有'department:view'的权限/department = authc,perms[\"department:view\"]# 当请求loginOut时,会被logout捕获并清除session/logout = logout# 所有的请求都需要身份认证/** = authc baseWebShiro\\src\\main\\webapp\\WEB-INF\\web.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;!-- Shiro 1.2引入了Environmnet/WebEnvironment的概念,既由它们接口提供相应的SecurityManager及其相应的依赖. ShiroFilter会自动找到Environment,然后获取相应的依赖. 底层实现:返回反射创建shiroEnvironmentClass对象,调用其init方法,既通过shiroEnvironmnetClass中的init方法 创建SecurityManager实例,并将其绑定到当前运行环境 --&gt; &lt;!-- 配置ShiroFilter环境 --&gt; &lt;context-param&gt; &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt; &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;shiroCConfigLocations&lt;/param-name&gt; &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Shiro监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Shiro拦截器 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 前端页面 baseWebShiro\\src\\main\\webapp\\static\\js\\jquery.js : 嘿嘿,代码量你懂得,自行下载吧~ 123456789101112131415161718192021222324/*! * jQuery JavaScript Library v1.7.1 * http://jquery.com/ * * Copyright 2011, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2011, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Mon Nov 21 21:11:03 2011 -0500 */(function (window, undefined) &#123;// Use the correct document accordingly with window argument (sandbox) var document = window.document, navigator = window.navigator, location = window.location; var jQuery = (function () &#123; // ······ baseWebShiro\\src\\main\\webapp\\static\\js\\main.js : 切换用户主页中的信息管理页面 12345$(function () &#123; $(\".changePage\").click(function () &#123; $(\"#rightMain\").prop(\"src\", $(this).data(\"url\")); &#125;);&#125;); baseWebShiro\\src\\main\\webapp\\static\\style\\main_css.css : 用户主页样式 123456789101112131415161718192021222324252627282930313233343536373839.top &#123; height: 50px; width: 99%; float: left; border: solid 1px black;&#125;.logo &#123; float: left; line-height: 20px;&#125;.userinfo &#123; float: right; line-height: 50px; font-size: 13px; margin-right: 100px;&#125;.center &#123; width: 100%; float: left; height: 500px;&#125;.center_left &#123; width: 10%; border: solid 1px black; height: 100%; float: left;&#125;.center_content &#123; width: 89%; border: solid 1px black; height: 100%; float: left; margin-left: -1px;&#125; baseWebShiro\\src\\main\\webapp\\WEB-INF\\views\\login.jsp : 用户登录页 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;style type=\"text/css\"&gt; h3 &#123; text-align: center; &#125; #main &#123; width: 600px; margin-left: 480px; &#125; #main tr &#123; height: 40px; &#125; #main tr td &#123; width: 20px; &#125; #main tr td input &#123; width: 200px; &#125; span &#123; font-size: 13px; color: red; &#125; .buttom &#123; text-align: center; padding-top: 25px; &#125; .buttom .login &#123; margin-right: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;用户登录页&lt;/h3&gt;&lt;hr/&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/login\" method=\"post\"&gt; &lt;table id=\"main\"&gt; &lt;tr&gt; &lt;td&gt;账号&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" name=\"password\"/&gt; &lt;span&gt;$&#123;errorMsg&#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=\"buttom\"&gt; &lt;input class=\"login\" type=\"submit\" value=\"登录\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; baseWebShiro\\src\\main\\webapp\\WEB-INF\\views\\main.jsp : 用户主页 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!-- 引入Shiro标签 --&gt;&lt;%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;main&lt;/title&gt; &lt;link type=\"text/css\" href=\"$&#123;pageContext.request.contextPath&#125;/static/style/main_css.css\" rel=\"stylesheet\"/&gt; &lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath&#125;/static/js/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath&#125;/static/js/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"top\"&gt; &lt;div class=\"logo\"&gt; &lt;h3 style=\"margin-left: 15px\"&gt;Shiro整合基本web | 一个基础的Web整合Shiro案例&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"userinfo\"&gt; 当前登录用户 : &lt;shiro:principal/&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/logout\"&gt;注销&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"center\"&gt; &lt;div class=\"center_left\"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"javascript:;\" class=\"changePage\" data-url=\"/employee\"&gt;员工管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:;\" class=\"changePage\" data-url=\"/department\"&gt;部门管理&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"center_content\"&gt; &lt;iframe name=\"right\" id=\"rightMain\" src=\"$&#123;pageContext.request.contextPath&#125;/welcome.jsp\" frameborder=\"no\" scrolling=\"auto\" width=\"100%\" height=\"100%\" allowtransparency=\"true\"&gt; &lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; baseWebShiro\\src\\main\\webapp\\welcome.jsp : 用户欢迎页 1234567891011&lt;%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;用户首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=\"center\"&gt;（づ￣3￣）づ╭❤～ 用户欢迎页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; baseWebShiro\\src\\main\\webapp\\WEB-INF\\views\\department\\list.jsp : 部门信息管理页 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!-- 引入Shiro标签 --&gt;&lt;%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;部门列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h2&gt;部门列表&lt;/h2&gt; &lt;!-- 当用户具有department模块的‘add’权限时才显示此按钮 --&gt; &lt;shiro:hasPermission name=\"department:add\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/department?cmd=input\"&gt;新增&lt;/a&gt; &lt;/shiro:hasPermission&gt; &lt;br&gt; &lt;table border=\"1\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;部门编号&lt;/th&gt; &lt;th&gt;部门名称&lt;/th&gt; &lt;th&gt;部门人数&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;负责人&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;研发部&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;2019-8-3&lt;/td&gt; &lt;td&gt;yubuntu0109&lt;/td&gt; &lt;td&gt; &lt;!-- 当用户具有department模块的‘edit’权限时才显示此按钮 --&gt; &lt;shiro:hasPermission name=\"department:edit\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/department?cmd=input&amp;id=1\"&gt;编辑&lt;/a&gt; &lt;/shiro:hasPermission&gt; &lt;!-- 当用户具有department模块的‘del’权限时才显示此按钮 --&gt; &lt;shiro:hasPermission name=\"department:del\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/department?cmd=delete\"&gt;删除&lt;/a&gt; &lt;/shiro:hasPermission&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; baseWebShiro\\src\\main\\webapp\\WEB-INF\\views\\employee\\list.jsp : 员工信息管理页 123456789101112131415161718192021222324252627282930313233343536&lt;%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;员工列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h1&gt;员工列表&lt;/h1&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/employee?cmd=input\"&gt;新增&lt;/a&gt; &lt;br&gt; &lt;table border=\"1\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;yubuntu0109&lt;/td&gt; &lt;td&gt;3083968068@qq.com&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/employee?cmd=input&amp;id=1\"&gt;编辑&lt;/a&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/employee?cmd=delete\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; baseWebShiro\\src\\main\\webapp\\nopermission.jsp : 无角色/权限提示页 1234567891011&lt;%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;无角色/权限提示界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=\"center\"&gt;(ಥ_ಥ) 抱歉,你无权限操作该模块 !&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 后端控制器 baseWebShiro\\src\\main\\java\\pers\\huangyuhui\\shiro\\web\\LoginServlet.java : 用户登录控制器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.shiro.web;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"loginServlet\", urlPatterns = \"/login\")public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //如果登录失败,则从request中获取认证异常信息,shiro异常类的全限定名为:shiroLoginFailure String exceptionClassName = (String) req.getAttribute(\"shiroLoginFailure\"); //根据Shiro返回的异常类,抛出指定的异常信息 if (exceptionClassName != null) &#123; if (UnknownAccountException.class.getName().equals(exceptionClassName)) &#123; req.setAttribute(\"errorMsg\", \"账号不存在 !\"); &#125; else if (IncorrectCredentialsException.class.getName().equals(exceptionClassName)) &#123; req.setAttribute(\"errorMsg\", \"账号/密码信息错误 !\"); &#125; else &#123; req.setAttribute(\"errorMsg\", \"其它异常信息 ...\"); &#125; &#125; req.getRequestDispatcher(\"/WEB-INF/views/login.jsp\").forward(req, resp); &#125;&#125; baseWebShiro\\src\\main\\java\\pers\\huangyuhui\\shiro\\web\\MainAction.java : 用户主页面控制器 12345678910111213141516171819202122package pers.huangyuhui.shiro.web;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = \"mainServlet\", urlPatterns = \"/main\")public class MainAction extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher(\"/WEB-INF/views/main.jsp\").forward(req, resp); &#125;&#125; baseWebShiro\\src\\main\\java\\pers\\huangyuhui\\shiro\\web\\DepartmentServlet.java : 部门信息管理页控制器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.shiro.web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"departmentServlet\", urlPatterns = \"/department\")public class DepartmentServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String cmd = req.getParameter(\"cmd\"); if (\"input\".equals(cmd)) &#123; if (req.getParameter(\"id\") != null) &#123; req.setAttribute(\"name\", \"Shiro研发部\"); req.setAttribute(\"cmdType\", \"编辑\"); &#125; else &#123; req.setAttribute(\"cmdType\", \"新增\"); &#125; req.getRequestDispatcher(\"/WEB-INF/views/department/input.jsp\").forward(req, resp); &#125; else if (\"savaOrUpdate\".equals(cmd)) &#123; // ··· &#125; else if (\"delete\".equals(cmd)) &#123; // ··· &#125; else &#123; req.getRequestDispatcher(\"/WEB-INF/views/department/list.jsp\").forward(req, resp); &#125; &#125;&#125; baseWebShiro\\src\\main\\java\\pers\\huangyuhui\\shiro\\web\\EmployeeServlet.java : 员工信息管理页控制器 123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.shiro.web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"employeeServlet\", urlPatterns = \"/employee\")public class EmployeeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String cmd = req.getParameter(\"cmd\"); if (\"input\".equals(cmd)) &#123; if (req.getParameter(\"id\") != null) &#123; req.setAttribute(\"name\", \"yubuntu0109\"); req.setAttribute(\"age\", \"21\"); req.setAttribute(\"email\", \"3083968068@qq.com\"); req.setAttribute(\"cmdType\", \"编辑\"); &#125; else &#123; req.setAttribute(\"cmdType\", \"新增\"); &#125; req.getRequestDispatcher(\"/WEB-INF/views/employee/input.jsp\").forward(req, resp); &#125; else if (\"savaOrUpdate\".equals(cmd)) &#123; // ······ &#125; else if (\"delete\".equals(cmd)) &#123; // ······ &#125; else &#123; req.getRequestDispatcher(\"/WEB-INF/views/employee/list.jsp\").forward(req, resp); &#125; &#125;&#125; 案例截屏用户登录页面 : 用户主页面 : 管理员(admin)身份登录 : 部门信息管理页( 该用户拥有操控部门信息管理页的所有权限 ) 管理员(admin)身份登录 : 员工信息管理页( 该用户拥有操控员工信息管理页的所有权限 ) 普通用户(yuhui)身份登录 : 部门信息管理页( 该用户只具有部门信息管理页的view权限 ) 普通用户(yuhui)身份登录 : 员工信息管理页( 该用户并没有操控员工信息管理页的权限 )","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"Hi Layui ~","slug":"Hi-Layui","date":"2019-08-04T02:16:22.000Z","updated":"2019-08-25T06:31:00.961Z","comments":true,"path":"2019/08/04/Hi-Layui/","link":"","permalink":"http://yoursite.com/2019/08/04/Hi-Layui/","excerpt":"","text":"学习笔记 : 拥抱前端框架Layuilayui 的出发点很简单 : 满足服务端程序员的需求,因此可以毫不保留地说,layui 并非面向于前端开发者,所以在组织形式上毅然采用了几年前的以浏览器为宿主的类 AMD 模块管理方式. 对比EasyUI,Layui的作者贤心写出了如下评语,一直用EasyUI写小项目前端的我看后内心波涛汹涌,特么太生动了趴ヾ(=･ω･=)o12Layui : 一个是邻家女孩，尚处芳龄，简而纯EasyUI : 一个是彪悍妇女，昨日黄花，强而丑 官方简介官方简介 : layui(谐音:类UI)是一款采用自身模块规范编写的前端 UI 框架,遵循原生 HTML/CSS/JS 的书写与组织形式,门槛极低,拿来即用. 其外在极简,却又不失饱满的内在,体积轻盈,组件丰盈,从核心代码到 API 的每一处细节都经过精心雕琢,非常适合界面的快速开发. layui 首个版本发布于2016年金秋,她区别于那些基于 MVVM 底层的 UI 框架,却并非逆道而行,而是信奉返璞归真之道. 准确地说,她更多是为服务端程序员量身定做,你无需涉足各种前端工具的复杂配置,只需面对浏览器本身,让一切你所需要的元素与交互,从这里信手拈来~ 兼容性和面向场景layui 兼容人类正在使用的全部浏览器(IE6/7除外),可作为 PC 端后台系统与前台界面的速成开发方案 主要模块layui 提供了丰富的内置模块,他们皆可通过模块化的方式按需加载,其中包括 : layer、layDate、layPage、laytpl、table、form、upload、element、tree、layeditor、rate、carousel、flow、util、code等.. 第一个Layui页面接下来通过Layui的表单模块,来快速写地一个简洁的用户登录页面 !ヾ(◍°∇°◍)ﾉﾞ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../resources/layui/layui-v2.5.4/layui/layui.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"../resources/layui/layui-v2.5.4/layui/css/layui.css\"&gt; &lt;title&gt;layui表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form style=\"margin-left: 400px;padding-top: 100px;\" class=\"layui-form\" action=\"\"&gt; &lt;div class=\"layui-form-item\"&gt; &lt;label class=\"layui-form-label\"&gt;输入框&lt;/label&gt; &lt;div class=\"layui-input-inline\"&gt; &lt;input type=\"text\" name=\"title\" style=\"width: 300px;\" required lay-verify=\"required\" placeholder=\"请输入账号\" autocomplete=\"off\" class=\"layui-input\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-form-item\"&gt; &lt;label class=\"layui-form-label\"&gt;密码框&lt;/label&gt; &lt;div class=\"layui-input-inline\"&gt; &lt;input type=\"password\" name=\"password\" style=\"width: 300px;\" required lay-verify=\"required\" placeholder=\"请输入密码\" autocomplete=\"off\" class=\"layui-input\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-form-item\"&gt; &lt;label class=\"layui-form-label\"&gt;复选框&lt;/label&gt; &lt;div class=\"layui-input-block\"&gt; &lt;input type=\"checkbox\" name=\"like[student]\" title=\"学生\"&gt; &lt;input type=\"checkbox\" name=\"like[teacher]\" title=\"教师\" checked&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-form-item\"&gt; &lt;div class=\"layui-input-block\"&gt; &lt;button class=\"layui-btn\" lay-submit lay-filter=\"formDemo\"&gt;提交&lt;/button&gt; &lt;button type=\"reset\" class=\"layui-btn layui-btn-primary\"&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;script&gt; //Demo layui.use('form', function() &#123; var form = layui.form; //监听提交 form.on('submit(formDemo)', function(data) &#123; layer.msg(JSON.stringify(data.field)); return false; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 程序运行结果如下所示,是不是感觉瞬间爱上Layui了呢 ! ✨ Layui官方使用文档 : https://www.layui.com/doc/","categories":[],"tags":[{"name":"Layui","slug":"Layui","permalink":"http://yoursite.com/tags/Layui/"}]},{"title":"Shiro的拦截器机制","slug":"Shiro的拦截器机制","date":"2019-08-03T00:01:57.000Z","updated":"2019-08-25T06:31:01.030Z","comments":true,"path":"2019/08/03/Shiro的拦截器机制/","link":"","permalink":"http://yoursite.com/2019/08/03/Shiro的拦截器机制/","excerpt":"","text":"学习笔记 : Shiro的拦截机制默认拦截器Shiro内置了很多默认的拦截器,比如身份验证、授权等相关的.更多默认拦截器可以参考 org.apache.shiro.web.filter.mgt.DefaultFilter中的枚举拦截器,如下所示 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Enum representing all of the default Shiro Filter instances available to web applications. * Each filter instance is typically accessible * in configuration the &#123;@link #name() name&#125; of the enum constant. * * @since 1.0 */public enum DefaultFilter &#123; anon(AnonymousFilter.class), authc(FormAuthenticationFilter.class), authcBasic(BasicHttpAuthenticationFilter.class), logout(LogoutFilter.class), noSessionCreation(NoSessionCreationFilter.class), perms(PermissionsAuthorizationFilter.class), port(PortFilter.class), rest(HttpMethodPermissionFilter.class), roles(RolesAuthorizationFilter.class), ssl(SslFilter.class), user(UserFilter.class); private final Class&lt;? extends Filter&gt; filterClass; private DefaultFilter(Class&lt;? extends Filter&gt; filterClass) &#123; this.filterClass = filterClass; &#125; public Filter newInstance() &#123; return (Filter) ClassUtils.newInstance(this.filterClass); &#125; public Class&lt;? extends Filter&gt; getFilterClass() &#123; return this.filterClass; &#125; public static Map&lt;String, Filter&gt; createInstanceMap(FilterConfig config) &#123; Map&lt;String, Filter&gt; filters = new LinkedHashMap&lt;String, Filter&gt;(values().length); for (DefaultFilter defaultFilter : values()) &#123; Filter filter = defaultFilter.newInstance(); if (config != null) &#123; try &#123; filter.init(config); &#125; catch (ServletException e) &#123; String msg = \"Unable to correctly init default filter instance of type \" + filter.getClass().getName(); throw new IllegalStateException(msg, e); &#125; &#125; filters.put(defaultFilter.name(), filter); &#125; return filters; &#125;&#125; 过滤器简称 对应的java类 anon org.apache.shiro.web.filter.authc.AnonymousFilter authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter user org.apache.shiro.web.filter.authc.UserFilter logout org.apache.shiro.web.filter.authc.LogoutFilter port org.apache.shiro.web.filter.authz.PortFilter rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter ssl org.apache.shiro.web.filter.authz.SslFilter anon : 匿名拦截器,即不需要登录即可访问. 一般用于静态资源过滤,示例”/static/**=anon” authc : 表示需要认证(登录)才能使用,示例”/**=authc”,主要属性有 : usernameParam : 表单提交的用户名参数名(username) passwordParam : 表单提交的密码参数名(password) rememberMeParam : 表单提交的密码参数名(rememberMe) loginUrl : 登录请求地址(/login.jsp) successUrl : 登录成功后的默认重定向地址 failureKeyAttribute : 登录失败后错误信息存储key(shiroLoginFailure) authcBasic : Basic HTTP身份验证拦截器,主要属性 : applicationName:弹出登录框显示的信息(application) roles : 角色授权拦截器,验证用户是否拥有资源角色. 示例”/admin/**=roles[admin]” perms : 权限授权拦截器,验证用户是否拥有资源权限. 示例”/user/create=perms[“user:create”]” user : 用户拦截器,用户已经身份验证/记住我的登录. 示例”/index=user” logout : 退出拦截器,主要属性 : redirectUrl:退出成功后重定向的地址(/). 示例”/logout=logout” port : 端口拦截器,主要属性 : port(80):可以通过的端口. 示例”/test= port[80]”,如果用户访问该页面是非80,将自动将请求端口改为80并重定向到该80端口,其他路径/参数等相同 rest : rest风格拦截器,自动根据请求方法构建权限字符串(GET=read,POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create)构建权限字符串. 示例”/users=rest[user]”,会自动拼出”user:read,user:create,user:update,user:delete”权限字符串进行权限匹配(所有都得匹配:isPermittedAll) ssl : SSL拦截器,只有请求协议是https才能通过. 否则自动跳转会https端口(443). 其他和port拦截器一样 注 : anon,authcBasic,auchc,user是认证过滤器. perms,roles,ssl,rest,port是授权过滤器","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"Shiro之用户授权","slug":"Shiro之用户授权","date":"2019-08-02T00:28:58.000Z","updated":"2019-08-25T06:31:01.029Z","comments":true,"path":"2019/08/02/Shiro之用户授权/","link":"","permalink":"http://yoursite.com/2019/08/02/Shiro之用户授权/","excerpt":"","text":"学习笔记 : 详解Shiro的用户授权简介 : 授权,也叫访问控制,即在应用中控制谁能访问哪些资源(如访问页面/编辑数据/页面操作等). 在授权中需了解的几个关键对象 : 主体(Subject)、资源(Resource)、权限(Permission)、角色(Role),其解析如下所示 : 主体 : 主体,即访问应用的用户,在Shiro中使用Subject代表该用户. 用户只有授权后才允许访问相应的资源 资源 : 在应用中用户可以访问的任何资源,比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等..用户需要授权后方可访问 权限 : 安全策略中的原子授权单位,可用权限控制用户在应用中是否能访问某个资源,如访问用户列表页面,查看/新增/修改/删除用户数据(基本为CRUD式权限控制).. 角色 : 角色代表了操作集合,可以理解为权限的集合,一般情况下我们会赋予用户角色而不是权限,即这样用户可以拥有一组权限,不同的角色拥有一组不同的权限 隐式角色 : 即直接通过角色来验证用户有没有操作权限,即粒度是以角色为单位进行访问控制的,粒度较粗. 若进行变更可能需要多处代码的修改 显示角色 : 在程序中通过权限控制谁能访问某个资源,角色聚合一组权限集合. 这样若需要哪个角色不能访问某个资源,只需要从角色代表的权限集合中移除指定的访问权限即可,无须修改多处代码 授权方式Shiro 支持三种方式的授权,如下所示 : 编程式 : 通过写if/else授权代码块完成 123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole(\"admin\")) &#123; //有权限&#125; else &#123; //无权限&#125; 注解式 : 通过在执行的Java方法上放置相应的注解完成 1234@RequiresRoles(\"admin\")public void hello() &#123; //有权限&#125; JSP/GSP 标签 : 在JSP/GSP页面通过相应的标签完成 123&lt;shiro:hasRole name=\"admin\"&gt;&lt;!— 有权限 —&gt;&lt;/shiro:hasRole&gt; 授权流程 首先调用`Subject.isPermitted/hasRole`接口,其会委托给SecurityManager,而SecurityManager接着会委托给Authorizer Authorizer是真正的授权者,如果我们调用如isPermitted(“user:create”),其首先会通过PermissionResolver把字符串转换成相应的Permission实例 在进行授权之前,其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限 Authorizer会判断Realm的角色/权限是否和传入的匹配,如果有多个Realm,则会委托给ModularRealmAuthorizer进行循环判断,如果匹配如`isPermitted/hasRole`会返回true,否则返回false以表示授权失败 ini方式检查用户拥有的角色通过加载ini配置文件的方式,来实现一个用于检查用户是否拥有指定角色的程序~ pom.xml : Maven依赖 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Shiro核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j的接口实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; per-shiro.ini : 用户身份及权限配置信息 1234567891011#权限表达式的定义:首先根据用户名查找角色,再根据角色查找权限,角色是权限的集合[users]#用户hunagyuhui的密码为loveyourself,且具有student和programmer两个角色huangyuhui = loveyourself,student,programmer[roles]#角色student对资源'user'拥有create,update权限student = user:create,user:update#角色programmer对资源'user'具有insert,delete权限programmer = user:read,user:delete RolesTest.java : 验证用户角色信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package pers.huangyuhui.permission;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.UnauthorizedException;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import java.util.Arrays;import java.util.List;public class RolesTest &#123; public static void main(String[] args) &#123; //1:加载配置文件,创建SecurityManager工厂对象 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:per-shiro.ini\"); //2:获得securityManager实例对象 SecurityManager securityManager = factory.getInstance(); //3:将securityManger实例绑定到当前运行环境中,便于访问 SecurityUtils.setSecurityManager(securityManager); //4:创建当前登录的主体 Subject currentUser = SecurityUtils.getSubject(); //5:绑定主体登录的身份/凭证,既账户及密码 UsernamePasswordToken token = new UsernamePasswordToken(\"huangyuhui\", \"loveyourself\"); //6:主体登录 try &#123; currentUser.login(token); System.out.println(\"用户身份是否验证成功 :\" + currentUser.isAuthenticated()); //7:进行用户角色判断 System.out.println(\"判断当前登录用户是否拥有'student'角色 : \" + currentUser.hasRole(\"student\")); System.out.println(\"判断当前登录用户是否同时拥有'student'与'programmer'角色 : \" + currentUser.hasAllRoles(List.of(\"student\", \"programmer\"))); System.out.println(\"判断当前登录用户是否拥有'student','programmer','singer'角色 : \" + Arrays.toString(currentUser.hasRoles(List.of(\"student\", \"programmer\", \"singer\")))); //判断当前用户是否拥有某个角色,若拥有该角色则不做任何操作(无返回值),反之则抛出:UnauthorizedException currentUser.checkRole(\"singer\"); &#125; catch (UnknownAccountException e) &#123; System.err.println(\"用户账户错误 !\"); &#125; catch (IncorrectCredentialsException e) &#123; System.err.println(\"用户密码错误 !\"); &#125; catch (UnauthorizedException e) &#123; System.err.println(\"用户并不拥有'singer'角色 !\"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //8:注销登录 currentUser.logout(); System.out.println(\"用户信息是否注销成功 :\" + !currentUser.isAuthenticated()); &#125;&#125; 程序运行结果如下所示 : 123456789101112// ······用户身份是否验证成功 :true// ······判断当前登录用户是否拥有'student'角色 : true// ······判断当前登录用户是否同时拥有'student'与'programmer'角色 : true// ······判断当前登录用户是否拥有'student','programmer','singer'角色 : [true, true, false]// ······用户并不拥有'singer'角色 !// ······用户信息是否注销成功 :true ini方式检查用户拥有的权限通过加载ini配置文件的方式,来实现一个用于检查用户是否拥有指定权限的程序~ pom.xml : Maven依赖(同上) per-shiro.ini : 用户身份及权限配置信息(同上) PermissionTest.java : 验证用户权限信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pers.huangyuhui.permission;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.UnauthorizedException;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import java.util.Arrays;public class PermissionsTest &#123; public static void main(String[] args) &#123; //1:加载配置文件,创建SecurityManager工厂对象 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:per-shiro.ini\"); //2:获得securityManager实例对象 SecurityManager securityManager = factory.getInstance(); //3:将securityManger实例绑定到当前运行环境中,便于访问 SecurityUtils.setSecurityManager(securityManager); //4:创建当前登录的主体 Subject currentUser = SecurityUtils.getSubject(); //5:绑定主体登录的身份/凭证,既账户及密码 UsernamePasswordToken token = new UsernamePasswordToken(\"huangyuhui\", \"loveyourself\"); //6:主体登录 try &#123; currentUser.login(token); System.out.println(\"用户身份是否验证成功 :\" + currentUser.isAuthenticated()); //7:进行用户权限判断 System.out.println(\"当前用户是否拥有对资源'user'的'create'与'read'权限 : \" + Arrays.toString(currentUser.isPermitted(\"user:create\", \"user:read\"))); System.out.println(\"当前用户是否拥有对资源'user'的'update'与'delete'权限 : \" + Arrays.toString(currentUser.isPermitted(\"user:update\", \"user:delete\"))); System.out.println(\"当前用户是否拥有对资源'user'的'import'与'export'权限 : \" + Arrays.toString(currentUser.isPermitted(\"user:import\", \"user:export\"))); //判断当前用户是否拥有某个权限,若有则不做任何操作(无返回值),反之抛出:UnauthorizedException currentUser.checkPermission(\"user:getUserList\"); &#125; catch (UnknownAccountException e) &#123; System.err.println(\"用户账户错误 !\"); &#125; catch (IncorrectCredentialsException e) &#123; System.err.println(\"用户密码错误 !\"); &#125; catch (UnauthorizedException e) &#123; System.err.println(\"当前用户并未拥有对资源'user'的'getUserList'权限 !\"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //8:注销登录 currentUser.logout(); System.out.println(\"用户信息是否注销成功 :\" + !currentUser.isAuthenticated()); &#125;&#125; 程序运行结果如下所示 : 123456789101112// ······用户身份是否验证成功 :true// ······当前用户是否拥有对资源'user'的'create'与'read'权限 : [true, true]// ······当前用户是否拥有对资源'user'的'update'与'delete'权限 : [true, true]// ······当前用户是否拥有对资源'user'的'import'与'export'权限 : [false, false]// ······当前用户并未拥有对资源'user'的'getUserList'权限 !// ······用户信息是否注销成功 :true 自定义Realm检查用户拥有的权限通过配置自定义Realm的方式,来实现一个用于验证用于角色及权限的程序~ pom.xml : Maven依赖(同上) per-my-shiro.ini : 配置自定义Realm 1234#指定自定义realmmyRealm = pers.huangyuhui.permission.realm.PermissRealm#指定SecurityManager的realms实现securityManager.realm = $myRealm PermissionRealm.java : 自定义Realm,并配置用户角色及权限信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package pers.huangyuhui.permission.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import java.util.ArrayList;import java.util.List;/** * @project: shiro-learning * @description: 自定义Realm, 配置用户角色及权限信息 * @author: 黄宇辉 * @date: 8/2/2019-10:52 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class PermissRealm extends AuthorizingRealm &#123; @Override public String getName() &#123; return \"permissRealm\"; &#125; @Override //授权:其principals存储着用户认证的凭证信息 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //获取当前登录的用户名信息,既用户凭证 //Object username = principals.getPrimaryPrincipal(); //模拟查询数据库操作:查询用户所拥有的的角色及权限信息 List&lt;String&gt; roles = new ArrayList&lt;&gt;(); List&lt;String&gt; permiss = new ArrayList&lt;&gt;(); //假设该用户拥有'student'与'programmer'角色 roles.add(\"student\"); roles.add(\"programmer\"); //假设该用户拥有对资源'user'的'read'与'update'权限 permiss.add(\"user:create\"); permiss.add(\"user:update\"); //封装用户的角色与权限信息并返回 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles(roles); info.addStringPermissions(permiss); return info; &#125; @Override //认证:其token存储着传入的用户身份信息(usernamePasswordToken) protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取用户的账户信息并验证 String username = (String) token.getPrincipal(); if (!\"github\".equals(username)) &#123; return null; &#125; //模拟用户密码信息 String password = \"yubuntu0109\"; //SimpleAuthenticationInfo(Object principal, Object credentials, String realmName) return new SimpleAuthenticationInfo(username, password, getName()); &#125;&#125; PermissTest.java : 验证用户角色及权限信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.huangyuhui.permission.realm;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.UnauthorizedException;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import java.util.Arrays;import java.util.List;public class PermissTest &#123; public static void main(String[] args) &#123; //1:加载配置文件,创建SecurityManager工厂对象 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:my-per-shiro.ini\"); //2:获得securityManager实例对象 SecurityManager securityManager = factory.getInstance(); //3:将securityManger实例绑定到当前运行环境中,便于访问 SecurityUtils.setSecurityManager(securityManager); //4:创建当前登录的主体 Subject currentUser = SecurityUtils.getSubject(); //5:绑定主体登录的身份/凭证,既账户及密码 UsernamePasswordToken token = new UsernamePasswordToken(\"github\", \"yubuntu0109\"); //6:主体登录 try &#123; currentUser.login(token); System.out.println(\"用户身份是否验证成功 :\" + currentUser.isAuthenticated()); //7:验证用户角色 System.out.println(\"判断当前登录用户是否拥有'student','programmer','singer'角色 : \" + Arrays.toString(currentUser.hasRoles(List.of(\"student\", \"programmer\", \"singer\")))); //8:验证用户权限 System.out.println(\"当前用户是否拥有对'user'资源的'create','update','read','delete'权限 : \" + Arrays.toString(currentUser.isPermitted(\"user:create\", \"user:update\", \"user:read\", \"user:delete\"))); &#125; catch (UnknownAccountException e) &#123; System.err.println(\"用户账户错误 !\"); &#125; catch (IncorrectCredentialsException e) &#123; System.err.println(\"用户密码错误 !\"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //8:注销登录 currentUser.logout(); System.out.println(\"用户信息是否注销成功 :\" + !currentUser.isAuthenticated()); &#125;&#125; 程序运行结果如下所示 : 12345678// ······用户身份是否验证成功 :true// ······判断当前登录用户是否拥有'student','programmer','singer'角色 : [true, true, false]// ······当前用户是否拥有对'user'资源的'create','update','read','delete'权限 : [true, true, false, false]// ······用户信息是否注销成功 :true","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"Shiro之自定义realm及其加密","slug":"Shiro之自定义realm及其加密","date":"2019-08-01T10:49:46.000Z","updated":"2019-08-25T06:31:01.030Z","comments":true,"path":"2019/08/01/Shiro之自定义realm及其加密/","link":"","permalink":"http://yoursite.com/2019/08/01/Shiro之自定义realm及其加密/","excerpt":"","text":"学习笔记 : Shiro之自定义realm及其加密自定义RealmRealm : 域,Shiro从Realm获取安全数据(如用户、角色、权限),就是说SecurityManager要验证用户身份,那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法. 也需要从Realm得到用户相应的角色 / 权限进行验证用户是否能进行操作,可以把Realm看成 DataSource,即安全数据源. 如我们之前的ini配置方式使用的是org.apache.shiro.realm.text.IniRealm接口 org.apache.shiro.realm.Realm接口如下所示 :123456//返回一个唯一的Realm名字String getName(); //判断此Realm是否支持此Tokenboolean supports(AuthenticationToken token); //根据Token获取认证信息AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; 下面通过自定义Realm来实现一个简单的用户身份验证程序~ pom.xml : Maven依赖 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Shiro核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j的接口实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; my-shiro.ini : 存储用户身份信息(账户=密码) 1234#自定义realmmyRealm = pers.huangyuhui.realm.MyRealm#指定SecurityManager的realms实现securityManager.realm = $myRealm MyRealm.java : 自定义Realm,模拟从数据库中获取用户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pers.huangyuhui.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @project: shiro-learning * @description: 自定义Realm * @author: 黄宇辉 * @date: 8/1/2019-5:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class MyRealm extends AuthorizingRealm &#123; @Override public String getName() &#123; return \"myRealm\"; //区分不同的Realm &#125; @Override //授权操作 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; return null; &#125; @Override //认证操作:其token存储着传入的用户登录信息(usernamePasswordToken) protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取并验证用户账号信息 String username = (String) token.getPrincipal(); if (!\"root\".equals(username)) &#123; return null; &#125; //假设用户密码信息 String password = \"yubuntu0109\"; //SimpleAuthenticationInfo(Object principal, Object credentials, String realmName) SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, password, getName()); return info; &#125;&#125; LoginByMyRealm.java : 验证用户登录信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.realm;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;/** * Shiro认证测试:验证用户登录信息 */public class loginByMyRealm &#123; public static void main(String[] args) &#123; //1:加载配置文件,创建SecurityManager工厂对象 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:my-shiro.ini\"); //2:获得securityManager实例对象 SecurityManager securityManager = factory.getInstance(); //3:将securityManger实例绑定到当前运行环境中,便于访问 SecurityUtils.setSecurityManager(securityManager); //4:创建当前登录的主体 Subject currentUser = SecurityUtils.getSubject(); //5:绑定主体登录的身份/凭证,既账户及密码 UsernamePasswordToken token = new UsernamePasswordToken(\"root\", \"yubuntu0109\"); //6:主体登录 try &#123; currentUser.login(token); System.out.println(\"用户身份是否验证成功 :\" + currentUser.isAuthenticated()); &#125; catch (UnknownAccountException e) &#123; System.err.println(\"用户账户错误 !\"); &#125; catch (IncorrectCredentialsException e) &#123; System.err.println(\"用户密码错误 !\"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //8:注销登录 currentUser.logout(); System.out.println(\"身份身份是否注销成功 :\" + !currentUser.isAuthenticated()); &#125;&#125; 程序运行结果如下所示 : 1234// ······用户身份是否验证成功 :true// ······身份身份是否注销成功 :true 加密RealmShiro提供了base64和16进制字符串编码 / 解码的API支持,方便一些编码解码操作. Shiro内部的一些数据的存储及表示都使用了 base64和16进制字符串 散列算法散列算法一般用于生成数据的摘要信息,是一种不可逆的算法,一般适合存储密码之类的数据,常见的散列算法如MD5、SHA等. 一般进行散列时最好提供一个salt(盐),比密码”admin”加密后产生的散列值是”21232f297a57a5a743894a0e4a801fc3”,其可以到一些MD5解密网站很容易的通过散列值得到密码”admin”,即如果直接对密码进行散列相对来说破解更容易,此时我们可以加一些只有系统知道的干扰数据,如在密码中混入用户ID及用户名(加盐操作),既而这样生成的散列值相对来说更难破解哟! 加密自定义Realm接下来通过使用MD5加密自定义Realm,来完成一个简单的用户身份验证程序~ pom.xml : Maven依赖(同上) en-shiro.ini : 存储用户身份及加密配置信息 1234567891011[main]#定义凭证匹配器credentialsMatcher = org.apache.shiro.authc.credential.HashedCredentialsMatcher#散列算法credentialsMatcher.hashAlgorithmName = md5#散列次数credentialsMatcher.hashIterations = 10#将凭证匹配器设置到realmmyRealm = pers.huangyuhui.encryption.EncryRealmmyRealm.credentialsMatcher = $credentialsMatchersecurityManager.realms = $myRealm EncryRealm.java : 自定义Realm,模拟从数据库中获取用户信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.encryption;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;/** * @project: shiro-learning * @description: 加密Realm * @author: 黄宇辉 * @date: 8/1/2019-7:58 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class EncryRealm extends AuthorizingRealm &#123; @Override public String getName() &#123; return \"pwdRealm\"; //区分不同的Realm &#125; @Override //授权操作 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; return null; &#125; @Override //认证操作 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取用户账户信息 String username = token.getPrincipal().toString(); if (!\"root\".equals(username)) &#123; return null; &#125; //MD5加密后的用户密码信息 String password = \"f3005f7acf36cec973498845460b0c33\";//password + username + 10 //指定盐值:ByteSource.Util.bytes(username) return new SimpleAuthenticationInfo(username, password, ByteSource.Util.bytes(username), getName()); &#125;&#125; LoginByMyRealm.java : 验证用户登录信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.encryption;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;/** * Shiro认证测试:验证用户登录信息 */public class loginByMyRealm &#123; public static void main(String[] args) &#123; //1:加载配置文件,创建SecurityManager工厂对象 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:en-shiro.ini\"); //2:获得securityManager实例对象 SecurityManager securityManager = factory.getInstance(); //3:将securityManger实例绑定到当前运行环境中,便于访问 SecurityUtils.setSecurityManager(securityManager); //4:创建当前登录的主体 Subject currentUser = SecurityUtils.getSubject(); //5:绑定主体登录的身份/凭证,既账户及密码 UsernamePasswordToken token = new UsernamePasswordToken(\"root\", \"yubuntu0109\"); //6:主体登录 try &#123; currentUser.login(token); System.out.println(\"用户身份是否验证成功 :\" + currentUser.isAuthenticated()); &#125; catch (UnknownAccountException e) &#123; System.err.println(\"用户账户错误 !\"); &#125; catch (IncorrectCredentialsException e) &#123; System.err.println(\"用户密码错误 !\"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //8:注销登录 currentUser.logout(); System.out.println(\"身份身份是否注销成功 :\" + !currentUser.isAuthenticated()); &#125;&#125; 程序运行结果如下所示 : 1234// ······用户身份是否验证成功 :true// ······身份身份是否注销成功 :true","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"详解Shiro登录登出的操作流程","slug":"详解Shiro登录登出的操作流程","date":"2019-08-01T05:48:07.000Z","updated":"2019-08-25T06:31:01.211Z","comments":true,"path":"2019/08/01/详解Shiro登录登出的操作流程/","link":"","permalink":"http://yoursite.com/2019/08/01/详解Shiro登录登出的操作流程/","excerpt":"","text":"学习笔记 : 详解Shiro登录登出的操作流程在shiro中,用户需要提供principals(身份)和credentials(证明)给shiro,继而来验证用户的身份信息,最常见的princpals和 credentials组合就是用户名 / 密码啦~ principals : 身份,即主体的标识属性,如用户名、邮箱等,需唯一. 一个主体可以有多个principals,但只有一个Primary principals,一般是用户名 / 密码 / 手机号 credentials : 证明 / 凭证,即只有主体知道的安全值,如密码 / 数字证书等 登录登出案例接下来通过一个模拟验证用户登录信息的示例程序,来探究并分析一下Shiro的验证用户身份信息的流程 pom.xml : Maven依赖 123456789101112131415161718192021&lt;dependencies&gt; &lt;!--Junit 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Shiro核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j的接口实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; shiro.ini : 存储用户身份信息(账户=密码) 12[users]root=yubuntu0109 ShiroTest.java : 模拟验证用户登录信息(把断点打在currentUser.login(token)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Test;/** * Shiro认证测试:验证用户登录信息 */public class ShiroTest &#123; @Test public void testLogin() &#123; //1:加载配置文件,创建SecurityManager工厂对象 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); //2:获得securityManager实例对象 SecurityManager securityManager = factory.getInstance(); //3:将securityManger实例绑定到当前运行环境中,便于访问 SecurityUtils.setSecurityManager(securityManager); //4:创建当前登录的主体 Subject currentUser = SecurityUtils.getSubject(); //5:绑定主体登录的身份/凭证,既账户及密码 UsernamePasswordToken token = new UsernamePasswordToken(\"root\", \"yubuntu0109\"); //6:主体登录 try &#123; currentUser.login(token); System.out.println(\"用户身份是否验证成功 :\" + currentUser.isAuthenticated()); &#125; catch (UnknownAccountException e) &#123; System.err.println(\"用户账户信息错误 !\"); &#125; catch (IncorrectCredentialsException e) &#123; System.err.println(\"用户密码信息错误 !\"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //8:注销登录 currentUser.logout(); System.out.println(\"身份身份是否注销成功 :\" + !currentUser.isAuthenticated()); &#125;&#125; 程序运行效果如下所示 : 1234// ······用户身份是否验证成功 :true// ······身份身份是否注销成功 :true 案例源码流程图在分析源码之前,先看一下该案例的源码流程图吧,也便于后面对源码分析的理解~ 调用subject.login(AuthenticationToken token)方法进行用户登录,其会自动委托给securityManager.login(Subject subject, AuthenticationToken token)方法进行登录 securityManager(安全管理器)通过Authenticator(认证器)进行认证 Authenticator的实现类ModularRealmAuthenticator通过调用realm从shiro.ini配置文件中获取用户真实的信息(账户和密码),这里的Realm(域)可以看成DataSource,即安全数据源 IniRealm(可通过加载.ini文件生成reaml对象)先根据token中的账号去shiro.ini配置文件中去匹配该账号,如果找不到则ModularRealmAuthenticator返回null,如果找到则继续匹配密码,若匹配成功则认证通过,反之不通过哟~ 最后可以使用Subject.logout()进行退出操作 案例源码流程分析 运行上述程序,首先debug(Step into)进入currentUser.login(token)内部,既DelegatingSubject.java. 从源码可以看出 : 与Subject的所有交互都会委托给SecurityManager. 可以把Subject认为是一个门面,SecurityManager才是实际的执行者哟~1234public void login(AuthenticationToken token) throws AuthenticationException &#123; this.clearRunAsIdentitiesInternal(); Subject subject = this.securityManager.login(this, token); // ······ 继续(Step into)进入this.securityManager.login(this, token);,既DefaultSecurityManager.java. 此时验证用户身份的的操作正式开始123456public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException &#123; AuthenticationInfo info; try &#123; info = this.authenticate(token); &#125; catch (AuthenticationException var7) &#123; // ······ 继续(Step into)进入this.authenticate(token),既AuthenticatingSecurityManager.java. 从源码可以看出SecurityManager将token委托给了Authenticator(认证器)去执行用户身份的认证操作 123public AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException &#123; return this.authenticator.authenticate(token); &#125; 继续(Step into)进入this.authenticator.authenticate(token),既AbstractAuthenticator.java. 由info = this.doAuthenticate(token);获取一个AuthenticationInfo对象 1234567891011121314public final AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException &#123; if (token == null) &#123; throw new IllegalArgumentException(\"Method argument (authentication token) cannot be null.\"); &#125; else &#123; log.trace(\"Authentication attempt received for token [&#123;&#125;]\", token); AuthenticationInfo info; try &#123; info = this.doAuthenticate(token); if (info == null) &#123; String msg = \"No account information found for authentication token [\" + token + \"] by this Authenticator instance. Please check that it is configured correctly.\"; throw new AuthenticationException(msg); &#125; // ······ 继续(Step into)进入info = this.doAuthenticate(token),既ModularRealmAuthenticator.java. 然后从系统所加载配置文件所对应的Realms的值中获取(this.getRealms())一个realms对象,该对象中包含一个users属性,其中包含着用户的身份及凭证信息,例如账号为root,密码为yubuntu0109的用户信息 12345678910protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException &#123; assertRealmsConfigured(); Collection&lt;Realm&gt; realms = getRealms(); if (realms.size() == 1) &#123; return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken); &#125; else &#123; return doMultiRealmAuthentication(realms, authenticationToken); &#125; &#125; // ······ 继续(Step into)进入this.doSingleRealmAuthentication((Realm)realms.iterator().next(), authenticationToken). 发现其通过realm.getAuthenticationInfo(token)获取一个AuthenticationInfo对象(其中存储着从Realm中获取的用户身份信息)123456789101112131415protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token) &#123; if (!realm.supports(token)) &#123; String msg = \"Realm [\" + realm + \"] does not support authentication token [\" + token + \"]. Please ensure that the appropriate Realm implementation is \" + \"configured correctly or that the realm accepts AuthenticationTokens of this type.\"; throw new UnsupportedTokenException(msg); &#125; AuthenticationInfo info = realm.getAuthenticationInfo(token); if (info == null) &#123; String msg = \"Realm [\" + realm + \"] was unable to find account data for the \" + \"submitted AuthenticationToken [\" + token + \"].\"; throw new UnknownAccountException(msg); &#125; return info; &#125; 继续(Step into)进入realm.getAuthenticationInfo(token),既AuthenticatingRealm.java1234567891011121314151617181920212223public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; AuthenticationInfo info = getCachedAuthenticationInfo(token); if (info == null) &#123; //otherwise not cached, perform the lookup: info = doGetAuthenticationInfo(token); log.debug(\"Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo\", info); if (token != null &amp;&amp; info != null) &#123; cacheAuthenticationInfoIfPossible(token, info); &#125; &#125; else &#123; log.debug(\"Using cached authentication info [&#123;&#125;] to perform credentials matching.\", info); &#125; if (info != null) &#123; assertCredentialsMatch(token, info); &#125; else &#123; log.debug(\"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;]. Returning null.\", token); &#125; return info; &#125; // ······ (Step into)进入doGetAuthenticationInfo(token),既SimpleAccountRealm.java. 通过getUser(upToken.getUsername())进行验证用户账户信息(稍后验证密码信息),然后返回一个SimpleAccount对象(account,如root),其中包含了凭证信息(credentials,如yubuntu0109)12345678910111213141516171819protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; UsernamePasswordToken upToken = (UsernamePasswordToken) token; SimpleAccount account = getUser(upToken.getUsername()); if (account != null) &#123; if (account.isLocked()) &#123; throw new LockedAccountException(\"Account [\" + account + \"] is locked.\"); &#125; if (account.isCredentialsExpired()) &#123; String msg = \"The credentials for account [\" + account + \"] are expired\"; throw new ExpiredCredentialsException(msg); &#125; &#125; return account; &#125; // ······ getUser(String username)的源码如下所示 :123456789protected SimpleAccount getUser(String username) &#123; USERS_LOCK.readLock().lock(); try &#123; return this.users.get(username); &#125; finally &#123; USERS_LOCK.readLock().unlock(); &#125; &#125; // ······ (step out)退出doGetAuthenticationInfo(AuthenticationToken token)方法,然后(step into)进入assertCredentialsMatch(token, info)方法,其属于AuthenticatingRealm.java. 继而执行验证用户密码信息的操作1234567891011121314protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException &#123; CredentialsMatcher cm = getCredentialsMatcher(); if (cm != null) &#123; if (!cm.doCredentialsMatch(token, info)) &#123; //not successful - throw an exception to indicate this: String msg = \"Submitted credentials for token [\" + token + \"] did not match the expected credentials.\"; throw new IncorrectCredentialsException(msg); &#125; &#125; else &#123; throw new AuthenticationException(\"A CredentialsMatcher must be configured in order to verify \" + \"credentials during authentication. If you do not wish for credentials to be examined, you \" + \"can configure an \" + AllowAllCredentialsMatcher.class.getName() + \" instance.\"); &#125; &#125; (step into)进入cm.doCredentialsMatch(token, info),其属于SimpleCredentialsMatcher.java. 观察Shiro是如何验证密码的 : 比较AuthenticationToken(token)与AuthenticationInfo(info)中的用户密码是否相同12345public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; Object tokenCredentials = getCredentials(token); Object accountCredentials = getCredentials(info); return equals(tokenCredentials, accountCredentials); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"Hi Shiro ~","slug":"Hi-Shiro","date":"2019-07-31T06:23:55.000Z","updated":"2019-08-25T06:31:00.965Z","comments":true,"path":"2019/07/31/Hi-Shiro/","link":"","permalink":"http://yoursite.com/2019/07/31/Hi-Shiro/","excerpt":"","text":"学习笔记 : 初识Shiro ~简介 : Apache Shiro是一个强大易用的Java安全框架,提供了认证、授权、加密和会话管理等功能，对于任何一个应用程序,Shiro都可以提供全面的安全管理服务 权限管理包括用户身份认证和授权两个部分,简称认证授权 身份认证 : 为判断用户是否为合法用户的过程,最常用的身份认证方式就是系统通过核对用户输入的用户名和口令,将其与系统中存储的该用户信息相对比,继而来判断用户身份是否正确 授权 : 既访问权限,控制用户访问资源的权限. 主体(subject)进行身份认证后需要分配权限方可访问系统的资源 架构解析Shiro可以非常容易的开发出足够好的应用,其不仅可以用在JavaSE环境,也可以用在JavaEE环境. Shiro可以帮助我们完成 : 认证、授权、加密、会话管理、与Web集成、缓存等. 其基本功能点及其解析如下所示 : Authentication : 身份认证 / 登录,验证用户是不是拥有相应的身份 Authorization : 授权,即权限验证,验证某个已认证的用户是否拥有某个权限. 即判断用户是否能做事情,常见的如 : 验证某个用户是否拥有某个角色,或者细粒度的验证某个用户对某个资源是否具有某个权限 Session Manager : 会话管理,即用户登录后就是一次会话,在没有退出之前,它的所有信息都在会话中. 会话可以是普通JavaSE环境的,也可以是如Web环境的 Cryptography : 加密,保护数据的安全性,如密码加密存储到数据库,而不是明文存储 Web Support : Web支持,可以非常容易的集成到Web环境中 Caching : 缓存,比如用户登录后,其用户信息、拥有的角色 / 权限不必每次去查,这样可以提高效率 Concurrency : shiro支持多线程应用的并发验证,即如在一个线程中开启另一个线程,能把权限自动传播过去 Testing : 提供测试支持 Run As : 允许一个用户假装为另一个用户(在他们允许的情况下)的身份进行访问 Remember Me : 记住我,这个是非常常见的功能,即一次登录后,下次不用重复登录了 外部结构外部架构图,即从应用程序角度的来观察如何使用Shiro完成工作 : 可以看到,应用代码直接交互的对象是Subject,也就是说Shiro的对外API核心就是Subject. 其每个API的含义如下所示 : Subject : 主体,代表了当前”用户”,这个用户不一定是一个具体的人,与当前应用交互的任何东西都是Subject,如网络爬虫,机器人等,即为一个抽象概念. 所有Subject都绑定到SecurityManager,与Subject的所有交互都会委托给SecurityManager. 可以把Subject认为是一个门面,SecurityManager才是实际的执行者 SecurityManager : 安全管理器,即所有与安全有关的操作都会与SecurityManager交互,且它管理着所有Subject. 可以看出它是Shiro的核心,它负责与后边介绍的其他组件进行交互,如果学习过SpringMVC,你可以把它看成DispatcherServlet前端控制器 Realm : 域,Shiro从Realm获取安全数据(如用户、角色、权限),就是说SecurityManager要验证用户身份,那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法,也需要从Realm得到用户相应的角色 / 权限进行验证用户是否能进行操作. 可以把Realm看成 DataSource,即安全数据源 也就是说,最简单的一个Shiro应用可以基本分为以下两个步骤 : 应用代码通过Subject来进行认证和授权,而Subject又将所有的互交都委托给了SecurityManager 我们需要给Shiro的SecurityManager注入Realm,从而让SecurityManager能得到合法的用户及其权限进行判断 从以上也可以看出,Shiro不提供维护用户 / 权限,而是通过Realm让开发人员自己注入 内部结构接下来我们来从Shiro内部来看下Shiro的架构,如下图所示 : Subject : 主体,可以看到主体可以是任何可以与应用交互的”用户” SecurityManager : 相当于SpringMVC中的DispatcherServlet或Struts2中的FilterDispatcher; 是Shiro的心脏. 所有具体的交互都通过SecurityManager进行控制,它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理 Authenticator : 认证器,负责主体认证的,这是一个扩展点,如果用户觉得Shiro默认的不好,可以自定义实现. 其需要认证策略(Authentication Strategy),即什么情况下算用户认证通过了 Authrizer : 授权器,或者访问控制器,用来决定主体是否有权限进行相应的操作,即控制着用户能访问应用中的哪些功能 Realm : 可以有1个或多个Realm,可以认为是安全实体数据源,即用于获取安全实体. 可以是JDBC实现,也可以是LDAP实现,或者内存实现等,由用户提供. 注意 : Shiro不知道你的用户 / 权限存储在哪及以何种格式存储,所以我们一般在应用中都需要实现自己的Realm SessionManager : 如果写过Servlet就应该知道Session的概念,Session需要有人去管理它的生命周期,这个组件就是SessionManager,而Shiro并不仅仅可以用在Web环境,也可以用在如普通的JavaSE环境、EJB等环境. 所以Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据. 这样的话,比如我们在Web环境用,刚开始是一台Web服务器,接着又上了台EJB服务器,这时想把两台服务器的会话数据放到一个地方,这个时候就可以实现自己的分布式会话(如把数据放到Memcached服务器) SessionDAO : DAO大家都用过,数据访问对象,用于会话的CRUD,比如我们想把Session保存到数据库,那么可以实现自己的 SessionDAO,通过如JDBC写到数据库. 比如想把Session放到Memcached中,可以实现自己的Memcached SessionDAO. 另外SessionDAO中可以使用Cache进行缓存,以提高性能 CacheManager : 缓存控制器,来管理如用户、角色、权限等的缓存的. 因为这些数据基本上很少去改变,放到缓存中后可以提高访问的性能 Cryptography : 密码模块,Shiro提高了一些常见的加密组件用于如密码加密 / 解密 案例第一个Shiro程序接下来通过一个简单的用户身份验证程序,来感受一下Shiro的魅力吧 ! pom.xml : Maven依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Shiro核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j的接口实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; log4j.properties : 日志配置信息 12345678910111213log4j.rootLogger=INFO, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n# General Apache librarieslog4j.logger.org.apache=WARN# Springlog4j.logger.org.springframework=WARN# Default Shiro logginglog4j.logger.org.apache.shiro=TRACE# Disable verbose logginglog4j.logger.org.apache.shiro.util.ThreadContext=WARNlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN shiro.ini : 存储用户身份信息(账户=密码) 12[users]root=yubuntu0109 ShiroTest.java : 验证用户登录信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Test;/** * Shiro认证测试:验证用户登录信息 */public class ShiroTest &#123; @Test public void testLogin() &#123; //1:加载配置文件,创建SecurityManager工厂对象 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); //2:获得securityManager实例对象 SecurityManager securityManager = factory.getInstance(); //3:将securityManger实例绑定到当前运行环境中,便于访问 SecurityUtils.setSecurityManager(securityManager); //4:创建当前登录的主体 Subject currentUser = SecurityUtils.getSubject(); //5:绑定主体登录的身份/凭证,既账户及密码 UsernamePasswordToken token = new UsernamePasswordToken(\"root\", \"yubuntu0109\"); //6:主体登录 try &#123; currentUser.login(token); System.out.println(\"用户身份是否验证成功 :\" + currentUser.isAuthenticated()); &#125; catch (UnknownAccountException e) &#123; System.err.println(\"账户信息错误 !\"); &#125; catch (IncorrectCredentialsException e) &#123; System.err.println(\"密码信息错误 !\"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //8:注销登录 currentUser.logout(); System.out.println(\"身份身份是否注销成功 :\" + !currentUser.isAuthenticated()); &#125;&#125; 程序运行结果如下所示 : 1234// ·····用户身份是否验证成功 :true// ·····身份身份是否注销成功 :true 官方入门案例 pom.xml : Maven依赖(同上) log4.properties : 日志配置信息(同上) shiro.ini : 存储具有指定权限的,不同身份的用户信息 12345678910111213141516171819202122232425262728293031323334353637383940# =============================================================================# Quickstart INI Realm configuration## For those that might not understand the references in this file, the# definitions are all based on the classic Mel Brooks' film \"Spaceballs\". ;)# =============================================================================# -----------------------------------------------------------------------------# Users and their assigned roles## Each line conforms to the format defined in the# org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc# -----------------------------------------------------------------------------[users]# user 'root' with password 'secret' and the 'admin' roleroot = secret, admin# user 'guest' with the password 'guest' and the 'guest' roleguest = guest, guest# user 'presidentskroob' with password '12345' (\"That's the same combination on# my luggage!!!\" ;)), and role 'president'presidentskroob = 12345, president# user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'darkhelmet = ludicrousspeed, darklord, schwartz# user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'lonestarr = vespa, goodguy, schwartz# -----------------------------------------------------------------------------# Roles with assigned permissions# # Each line conforms to the format defined in the# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc# -----------------------------------------------------------------------------[roles]# 'admin' role has all permissions, indicated by the wildcard '*'admin = *# The 'schwartz' role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with# license plate 'eagle5' (instance specific id)goodguy = winnebago:drive:eagle5 Quickstart.java : 一个简单的入门级程序,教你如何使用Shiro的API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package pers.huangyuhui;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.session.Session;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Simple Quickstart application showing how to use Shiro's API. * * @since 0.9 RC2 */public class Quickstart &#123; private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) &#123; // The easiest way to create a Shiro SecurityManager with configured // realms, users, roles and permissions is to use the simple INI config. // We'll do that by using a factory that can ingest a .ini file and // return a SecurityManager instance: // Use the shiro.ini file at the root of the classpath // (file: and url: prefixes load from files and urls respectively): Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); SecurityManager securityManager = factory.getInstance(); // for this simple example quickstart, make the SecurityManager // accessible as a JVM singleton. Most applications wouldn't do this // and instead rely on their container configuration or web.xml for // webapps. That is outside the scope of this simple quickstart, so // we'll just do the bare minimum so you can continue to get a feel // for things. SecurityUtils.setSecurityManager(securityManager); // Now that a simple Shiro environment is set up, let's see what you can do: // get the currently executing user: Subject currentUser = SecurityUtils.getSubject(); // Do some stuff with a Session (no need for a web or EJB container!!!) Session session = currentUser.getSession(); session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); if (value.equals(\"aValue\")) &#123; log.info(\"Retrieved the correct value! [\" + value + \"]\"); &#125; // let's login the current user so we can check against roles and permissions: if (!currentUser.isAuthenticated()) &#123; UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\"); token.setRememberMe(true); try &#123; currentUser.login(token); &#125; catch (UnknownAccountException uae) &#123; log.info(\"There is no user with username of \" + token.getPrincipal()); &#125; catch (IncorrectCredentialsException ice) &#123; log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\"); &#125; catch (LockedAccountException lae) &#123; log.info(\"The account for username \" + token.getPrincipal() + \" is locked. \" + \"Please contact your administrator to unlock it.\"); &#125; // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) &#123; //unexpected condition? error? &#125; &#125; //say who they are: //print their identifying principal (in this case, a username): log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\"); //test a role: if (currentUser.hasRole(\"schwartz\")) &#123; log.info(\"May the Schwartz be with you!\"); &#125; else &#123; log.info(\"Hello, mere mortal.\"); &#125; //test a typed permission (not instance-level) if (currentUser.isPermitted(\"lightsaber:wield\")) &#123; log.info(\"You may use a lightsaber ring. Use it wisely.\"); &#125; else &#123; log.info(\"Sorry, lightsaber rings are for schwartz masters only.\"); &#125; //a (very powerful) Instance Level permission: if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) &#123; log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. \" + \"Here are the keys - have fun!\"); &#125; else &#123; log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\"); &#125; //all done - log out! currentUser.logout(); System.exit(0); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"How to create a pull request from a fork","slug":"How-to-create-a-pull-request-from-a-fork","date":"2019-07-29T10:03:07.000Z","updated":"2019-08-25T06:31:00.974Z","comments":true,"path":"2019/07/29/How-to-create-a-pull-request-from-a-fork/","link":"","permalink":"http://yoursite.com/2019/07/29/How-to-create-a-pull-request-from-a-fork/","excerpt":"","text":"学习笔记 : 如何在fork的仓库中创建一个pull request请求如果你创建了仓库的分叉并对分叉进行了更改,你可以创建一个拉取请求来请求上游仓库接受你的更改. 至于说如何正确使用分支请参阅官方文档 : https://help.github.com/en/articles/working-with-forks 详细步骤 导航到从其中创建分叉的原始仓库 在Branch(分支)菜单的右侧,单击New pull request(新建拉取请求) 在Compare(比较)页面上,单击compare across forks(跨分叉比较) 确认基本分叉是您要向其合并更改的仓库. 使用base branch(基本分支)下拉菜单,选择要向其合并更改的上游仓库分支 使用head fork(头部分叉)下拉菜单选择您的分叉,然后使用compare branch(比较分支)下拉菜单选择进行了更改的分支 键入拉取请求的标题和说明 如果您不希望对上游仓库具有推送权限的任何人更改您的拉取请求,请取消选中Allow edits from maintainers(允许维护员编辑) 要创建可供审查的拉取请求,请单击 Create Pull Request(创建拉取请求). 要创建拉取请求草稿,请使用下拉菜单选择Create Draft Pull Request(创建拉取请求草稿),然后单击Draft Pull Request(拉取请求草稿) 👍 摘自GiHub帮助文档(推荐将其作为GitHub学习参考,内容真心超级详细哟 ~) : https://help.github.com/en","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"A simple comment component for Vue","slug":"A-simple-comment-component-for-Vue","date":"2019-07-25T03:11:04.000Z","updated":"2019-08-25T06:31:00.955Z","comments":true,"path":"2019/07/25/A-simple-comment-component-for-Vue/","link":"","permalink":"http://yoursite.com/2019/07/25/A-simple-comment-component-for-Vue/","excerpt":"","text":"案例笔记 : 一个简单的Vue评论框组件在写完案例 : 一个基于Vue.js的简单信息管理页后,小哥又初步学习了Vue.js组件的定义及基本用法,来为此再写一个小总结案例吧~ 这是一个简单的评论框组件 : 发表评论(将其存储到Local Storage)~ 该程序其它版本见 : https://github.com/YUbuntu0109/vue-learning (simple component for comment v1.0/comment-component-1.0.html)程序如下所示 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../../resources/vue.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"../../resources/bootstrap.css\" /&gt; &lt;title&gt;the comment component v.10&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- use the comment component --&gt; &lt;comm-component @fun-init=\"initComments\" @fun-clear=\"clearLocalStorage\"&gt;&lt;/comm-component&gt; &lt;!-- comments --&gt; &lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\" v-for=\"comment in comments\" :key=\"comment.id\"&gt; &lt;span class=\"badge\"&gt;commenter : &#123;&#123;comment.commenter&#125;&#125;&lt;/span&gt; contents : &#123;&#123;comment.content&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- the template of the component --&gt; &lt;template id=\"commTemplate\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;A SIMPLE COMMENT COMPONENT FOR VUE&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"label label-default\" style=\"font-size: 17px;\"&gt;commenter&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" style=\"width: 180px;\" v-model=\"commenter\" v-focus v-color=\"'#777'\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"padding-left: 15px;\"&gt; &lt;label class=\"label label-default\" style=\"font-size: 17px;\"&gt;content&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" style=\"width: 500px;\" v-model=\"content\" v-color=\"'#777'\" @keyup.enter=\"commit\" /&gt; &lt;/div&gt; &lt;label style=\"padding-left: 5px;\"&gt; &lt;button class=\"btn btn-success\" @click=\"commit\"&gt;COMMIT&lt;/button&gt; &lt;button class=\"btn btn-warning\" style=\"margin-left: 10px;\" @click=\"reset\"&gt;RESET&lt;/button&gt; &lt;button class=\"btn btn-danger\" style=\"margin-left: 10px;\" @click=\"delAll\"&gt;CLEAR STORAGE&lt;/button&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //declare the comment component var commComponent = &#123; template: '#commTemplate', data() &#123; return &#123; commenter: '', content: '' &#125; &#125;, methods: &#123; commit() &#123; var comment = &#123; id: Date.now(), commenter: this.commenter, content: this.content &#125; var commentList = JSON.parse(localStorage.getItem('cmts') || '[]') //get all of comments from the local storage commentList.unshift(comment) localStorage.setItem('cmts', JSON.stringify(commentList)) //save the new comment list this.$emit('fun-init') this.commenter = '' this.content = '' &#125;, reset() &#123; this.commenter = '' this.content = '' &#125;, delAll() &#123; this.$emit('fun-clear') this.$emit('fun-init') &#125; &#125; &#125; //custom directive Vue.directive('focus', &#123; inserted: function(el) &#123; el.focus() &#125; &#125;); Vue.directive('color', &#123; bind: function(el, colorStr) &#123; el.style.color = colorStr.value &#125; &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; idStr: [], comments: [&#123; id: '', commenter: '', content: '' &#125;] &#125;, methods: &#123; //initializes the list of comments on the page initComments() &#123; var commentList = JSON.parse(localStorage.getItem('cmts') || '[]') this.comments = commentList &#125;, //delete all of comments from the local storage clearLocalStorage() &#123; localStorage.clear() &#125; &#125;, components: &#123; commComponent &#125;, created() &#123; this.initComments() //(reflush)reload comments &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果如下图所示 :","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"一个基于Vue的简单信息管理页","slug":"一个基于Vue的简单信息管理页","date":"2019-07-24T12:02:22.000Z","updated":"2019-08-25T06:31:01.114Z","comments":true,"path":"2019/07/24/一个基于Vue的简单信息管理页/","link":"","permalink":"http://yoursite.com/2019/07/24/一个基于Vue的简单信息管理页/","excerpt":"","text":"案例笔记 : 一个基于Vue.js的简单信息管理页初步学习完Vue.js的基本语法、数据绑定视图机制、事件绑定、自定义指令、过滤器后,来尝试写一个总结案例吧~ 该案例的主要功能是一个简单的信息管理 : 增加,删除,查找. 该程序其它版本见 : https://github.com/YUbuntu0109/vue-learning (simple demo program v1.2/demo-1.2.html)程序如下所示 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../vue.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"../simple%20demo%20program%20v1.0/resources/bootstrap.css\" /&gt; &lt;title&gt;a simple demo program v1.2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;SIMPLE DEMO PROGRAM FOR VUE&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label&gt; ID : &lt;input type=\"text\" class=\"form-control\" v-model=\"id\" /&gt; &lt;/label&gt; &lt;label style=\"padding-left: 20px;\"&gt; NAME : &lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.enter=\"add()\" /&gt; &lt;/label&gt; &lt;label&gt; &lt;button class=\"btn btn-primary\" style=\"margin-left:20px ;\" @click=\"add()\"&gt;ADD&lt;/button&gt; &lt;/label&gt; &lt;label style=\"padding-left: 213px;\"&gt; &lt;button class=\"btn btn-info\"&gt;SEARCH BY NAME&lt;/button&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"keyword\" v-focus v-color=\"'blueviolet'\" /&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th style=\"width: 328px;\"&gt;CTIME&lt;/th&gt; &lt;th&gt;OPERATION&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"user in search(keyword)\" v-bind:key=\"user.id\"&gt; &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user.ctime | dateStrFilter('')&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;button class=\"btn btn-danger\" @click=\"del(user.id)\"&gt;DELETE&lt;/buttom&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; Vue.filter('dateStrFilter', function(dateStr, datePattern = \"\") &#123; //the default is null var newDateStr = new Date(dateStr) var year = newDateStr.getFullYear() var month = (newDateStr.getMonth() + 1).toString().padStart(2, '0') //padStart():complete the length of the string var date = newDateStr.getDate().toString().padStart(2, '0') var hour = newDateStr.getHours().toString().padStart(2, '0') var m = newDateStr.getMinutes().toString().padStart(2, '0') var s = newDateStr.getSeconds().toString().padStart(2, '0') if (datePattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125;` &#125; else &#123; return `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125; $&#123;hour&#125;:$&#123;m&#125;:$&#123;s&#125;` &#125; &#125;); Vue.directive('focus', &#123; inserted: function(el) &#123; el.focus() &#125; &#125;); Vue.directive('color', &#123; bind: function(el, colorStr) &#123; el.style.color = colorStr.value &#125; &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', keyword: '', users: [&#123; id: 1, name: 'YUHUI001', ctime: new Date() &#125;, &#123; id: 2, name: 'YUHUI002', ctime: new Date() &#125;, &#123; id: 3, name: 'YUHUI003', ctime: new Date() &#125; ] &#125;, methods: &#123; add() &#123; var user = &#123; id: this.id, name: this.name, ctime: new Date() &#125; //The elements to add to the end of the array. this.users.push(user) this.id = this.name = '' &#125;, del(id) &#123; var index = this.users.findIndex(user =&gt; &#123; if (user.id == id) &#123; return true; &#125; &#125;); //The elements to add to the array. //If you don't specify any elements, splice simply removes elements from the array. this.users.splice(index, 1) &#125;, search(keyword) &#123; var newUsers = [] this.users.forEach(user =&gt; &#123; //If the keyword is null, it returns 0. if (user.name.indexOf(keyword) != -1) &#123; newUsers.push(user) &#125; &#125;); return newUsers; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果示例图如下 :","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue组件的定义及基本用法","slug":"Vue组件的定义及基本用法","date":"2019-07-24T11:57:46.000Z","updated":"2019-08-25T06:31:01.107Z","comments":true,"path":"2019/07/24/Vue组件的定义及基本用法/","link":"","permalink":"http://yoursite.com/2019/07/24/Vue组件的定义及基本用法/","excerpt":"","text":"学习笔记 : Vue组件的定义及基本的使用方法组件的出现,是为了拆分实例的代码量的,继而能够让我们以不同的组件来划分不同功能模块. 组件是可复用的Vue实例,所以它们与new Vue接收相同的选项,例如 data、computed、watch、methods以及生命周期钩子等 .. 组件化 : 从代码逻辑的角度进行划分,保证每个功能模块的职能单一 模块化 : 从UI设计的角度进行划分,保证前端方便UI组件的重用 组件的注册全局组件注册方式方式一 : 使用Vue.extend,及其简化模式123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;simple-my-component1&gt;&lt;/simple-my-component1&gt; &lt;simple-my-component2&gt;&lt;/simple-my-component2&gt;&lt;/div&gt;&lt;script&gt; //注册组件 var component = Vue.extend(&#123; template: '&lt;h2&gt;Stay hungray,Stay foolish&lt;/h2&gt;' &#125;); Vue.component('myComponent', component) //简化模式1 Vue.component('simpleMyComponent1', Vue.extend(&#123; template: '&lt;h3&gt;Stay hungray,Stay foolish&lt;/h3&gt;' &#125;)); //简化模式2 Vue.component('simpleMyComponent2', &#123; template: '&lt;div&gt;&lt;h4&gt;Stay hungray,Stay foolish&lt;/h4&gt;&lt;span&gt;data&lt;/span&gt;&lt;/div&gt;' &#125;); var vm = new Vue(&#123; el: '#app', data: &#123;&#125; &#125;);&lt;/script&gt; 方式二 : 将template定义为独立标签,提高代码可读性1234567891011121314151617&lt;template id=\"myTemplate\"&gt; &lt;h2&gt;Stay hungray,Stay foolish&lt;/h2&gt;&lt;/template&gt;&lt;div id=\"app\"&gt; &lt;simple-my-component&gt;&lt;/simple-my-component&gt;&lt;/div&gt;&lt;script&gt; //注册组件 Vue.component('simpleMyComponent', Vue.extend(&#123; template: '#myTemplate' &#125;)); var vm = new Vue(&#123; el: '#app', data: &#123;&#125; &#125;);&lt;/script&gt; 局部组件注册方式方式一 : components选项用于为组件注册从外部引入的组件1234567891011121314151617&lt;template id=\"myTemplate\"&gt; &lt;h2&gt;this is my component&lt;/h2&gt;&lt;/template&gt;&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var myComponent = &#123; template: '#myTemplate' &#125; var vm = new Vue(&#123; el: '#app', components: &#123; myComponent &#125; &#125;);&lt;/script&gt; 方式二123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;my-title1&gt;&lt;/my-title1&gt; &lt;my-title2&gt;&lt;/my-title2&gt;&lt;/div&gt;&lt;script&gt; let myTitle1 = &#123; name: 'myTitle', template: '&lt;h2&gt;Stdy hungry,Stdy foolish&lt;/h2&gt;' &#125; let myTitle2 = &#123; name: 'myTitle2', template: '&lt;h3&gt;Stdy hungry,Stdy foolish&lt;/h3&gt;' &#125; var vm = new Vue(&#123; el: '#app', components: &#123; myTitle1, myTitle2 &#125; &#125;);&lt;/script&gt; Prop父组件在引用子组件的同时,可以通过属性绑定(v-bind)的形式把需要传递给子组件的数据,以属性绑定的形式,传递到子组件内部,供子组件使用,示例程序如下 :1234567891011121314151617&lt;div id=\"app\"&gt; &lt;son-component v-bind:parentmsg=\"msg\"&gt;&lt;/son-component&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的数据' &#125;, components: &#123; sonComponent: &#123; props: ['parentmsg'], //只读 template: '&lt;h3&gt;这是子组件---&gt;&#123;&#123;parentmsg&#125;&#125;&lt;/h3&gt;', &#125; &#125; &#125;);&lt;/script&gt; 自定义事件父组件向子组件传递方法,使用的是事件绑定机制,示例程序如下 :123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;my-component @func=\"show\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var myComponent = &#123; template: '#myTemplate', methods: &#123; getMethods() &#123; this.$emit('func', '你好,我是子组件!') &#125; &#125; &#125; var vm = new Vue(&#123; el: '#app', methods: &#123; show(data) &#123; window.alert('这是父组件中的方法,子组件传递过来的数据为:' + data) &#125; &#125;, components: &#123; myComponent &#125; &#125;);&lt;/script&gt; 动态组件组件间的切换,方式一 : 使用if-else,示例程序如下 :1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;button @click=\"flag=true\"&gt;登录&lt;/button&gt; &lt;button @click=\"flag=false\"&gt;注册&lt;/button&gt; &lt;login v-if=\"flag\"&gt;&lt;/login&gt; &lt;regist v-else=\"flag\"&gt;&lt;/regist&gt;&lt;/div&gt;&lt;script&gt; Vue.component('login', &#123; template: '&lt;h3&gt;这是登录组件&lt;/h3&gt;' &#125;); Vue.component('regist', &#123; template: '&lt;h3&gt;这是注册组件&lt;/h3&gt;' &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125; &#125;);&lt;/script&gt; 组件间的切换,方式二 : 使用component元素,示例程序如下 :1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;button @click=\"componentName='login'\"&gt;登录&lt;/button&gt; &lt;button @click=\"componentName='regist'\"&gt;注册&lt;/button&gt; &lt;button @click=\"componentName='logout'\"&gt;注销&lt;/button&gt; &lt;component :is=\"componentName\"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('login', &#123; template: '&lt;h3&gt;这是登录组件&lt;/h3&gt;' &#125;); Vue.component('regist', &#123; template: '&lt;h3&gt;这是注册组件&lt;/h3&gt;' &#125;); Vue.component('logout', &#123; template: '&lt;h3&gt;这是注销组件&lt;/h3&gt;' &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; componentName: 'login' //default &#125; &#125;);&lt;/script&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue.js的自定义指令与过滤器","slug":"Vue-js的自定义指令与过滤器","date":"2019-07-23T07:45:39.000Z","updated":"2019-08-25T06:31:01.105Z","comments":true,"path":"2019/07/23/Vue-js的自定义指令与过滤器/","link":"","permalink":"http://yoursite.com/2019/07/23/Vue-js的自定义指令与过滤器/","excerpt":"","text":"学习笔记 : Vue的自定义指令及过滤器的使用指令先前我们接触过Vue提供的’开箱即用的’指令,如v-bind,v-on,v-model等 . .除了这些指令外,Vue也允许我们使用一些自定义的指令哟~ 一个指令定义对象可以提供如下几个钩子函数 (均为可选) : bind : 只调用一次,指令第一次绑定到元素时调用. 在这里可以进行一次性的初始化设置 inserted : 被绑定元素插入父节点时调用(仅保证父节点存在,但不一定已被插入文档中) update : 所在组件的VNode更新时调用,但是可能发生在其子VNode更新之前. 指令的值可能发生了改变,也可能没有. 但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见 : https://cn.vuejs.org/v2/guide/custom-directive.html) componentUpdated : 指令所在组件的VNode及其子VNode全部更新后调用 unbind : 只调用一次,指令与元素解绑时调用 自定义全局指令自定义一个全局的指令,用于自定义字体颜色,示例程序如下 :1234567891011121314151617&lt;div id=\"app\"&gt; &lt;p v-color=\"'blueviolet'\"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; Vue.directive('color', &#123; bind: function(el, colorStr) &#123; el.style.color = colorStr.value &#125; &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hi Vue !' &#125; &#125;);&lt;/script&gt; 大多情况下,我们可能只想在bind和update钩子上作重复动作,并不想关心其它的钩子,那么就可以这样简写哟 :123456789101112131415&lt;div id=\"app\"&gt; &lt;p v-color=\"'blueviolet'\"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; Vue.directive('color', function(el, colorStr) &#123; el.style.color = colorStr.value &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hi Vue !' &#125; &#125;);&lt;/script&gt; 自定义私有指令自定义一个私有的指令,用于自定义字体颜色,其示例程序如下 :123456789101112131415161718&lt;div id=\"app\"&gt; &lt;p v-color=\"'blueviolet'\"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hi Vue !' &#125;, directives: &#123; 'color': &#123; bind: function(el, colorStr) &#123; el.style.color = colorStr.value &#125; &#125; &#125; &#125;);&lt;/script&gt; (同上)可简写为 :12345678910111213141516&lt;div id=\"app\"&gt; &lt;p v-color=\"'blueviolet'\"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hi Vue !' &#125;, directives: &#123; 'color': function(el, colorStr) &#123; el.style.color = colorStr.value &#125; &#125; &#125;);&lt;/script&gt; 过滤器Vue.js允许你自定义过滤器,可被用于一些常见的文本格式化,过滤器可以用在两个地方 : 双花括号插值和v-bind表达式 (后者从 2.1.0+ 开始支持). 过滤器应该被添加在JavaScript表达式的尾部,由管道符 : | 指示,表达式的值将作为形参传入到filter中,示例代码如下 :123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;title | titleFilter1&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;title | titleFilter1 | titleFilter2&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; title: 'Demo#%Program#%For#%Filter' &#125;, filters: &#123; titleFilter1(value) &#123; return value.replace(/#/g, ' ') &#125;, titleFilter2(value) &#123; return value.replace(/%/g, '') &#125; &#125; &#125;);&lt;/script&gt; 除在组件中定义filter外,Vue还允许在开发者在全局定义filter,与选项filter不同的是,全局filter可以在任何组件和实例中起作用哟,示例程序如下 :1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;title | titleFilter1&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;title | titleFilter1 | titleFilter2&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; Vue.filter('titleFilter1', value =&gt; &#123; return value.replace(/#/g, ' ') &#125;); Vue.filter('titleFilter2', value =&gt; &#123; return value.replace(/%/g, '') &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; title: 'Demo#%Program#%For#%Filter' &#125; &#125;);&lt;/script&gt; 程序运行效果如下 : 全局过滤器定义一个全局filter,用于格式化指定字符,其示例程序如下 :12345678910111213&lt;div id=\"app\"&gt;&#123;&#123;msg | msgFilter('Keep')&#125;&#125;&lt;/div&gt;&lt;script&gt; Vue.filter('msgFilter', function(msg, filterStr) &#123; return msg.replace(/Stay/g, filterStr) //使用正则表达式匹配字符 &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'Stay hungry,Stay foolish ~' &#125; &#125;);&lt;/script&gt; 私有过滤器定义一个选项filter,用于格式化指定字符,其示例程序如下 :1234567891011121314&lt;div id=\"app\"&gt;&#123;&#123;msg | msgFilter('keep')&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'Stay hungry,Stay foolish ~' &#125;, filters: &#123; msgFilter: function(msg, filterStr) &#123; return msg.replace(/Stay/g, filterStr) &#125; &#125; &#125;);&lt;/script&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue.js的数据响应式原理","slug":"Vue-js的数据响应式原理","date":"2019-07-21T06:32:26.000Z","updated":"2019-08-25T06:31:01.096Z","comments":true,"path":"2019/07/21/Vue-js的数据响应式原理/","link":"","permalink":"http://yoursite.com/2019/07/21/Vue-js的数据响应式原理/","excerpt":"","text":"学习笔记 : Vue.js对的数据响应式原理简介 : Vue中最重要的概念就是响应式数据,一方面是指衍生和元数据之间的响应,通过数据链来实现. 另一方面是指视图与数据之间的绑定 . 初始数据链数据链在学术上被定义为连通数据的链路,在这条链路上有一到多个数据起点(元数据),并通过改点不断衍生扩展新的节点(衍生数据),形成 一个庞大的网状结构. 当你修改数据起点时, 所有存在网上的节点值都将会同步更新,如下图所示 : Vue中的数据链Vue实例提供了computed计算属性选项,以供开发者生成衍生数据对象. 虽然计算属性以函数形式声明,却并不接受参数,也只能以属性的方式调用. 由于计算属性的this指向Vue实例,所以它可以获取实例上所有已挂载的可见属性,如下示例此程序 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Vue中的数据链&lt;/title&gt; &lt;style&gt; #app&#123; font-family: \"lucida console\",sans-serif; color: #67B168; &#125; .data-label&#123; display: inline-block; width: 160px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&lt;strong class=\"data-label\"&gt;A&lt;/strong&gt;&lt;input type=\"text\" v-model=\"a\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;strong class=\"data-label\"&gt;B&lt;/strong&gt;&lt;input type=\"text\" v-model=\"b\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;strong class=\"data-label\"&gt;C=A*2+2&lt;/strong&gt;&#123;&#123;c&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;strong class=\"data-label\"&gt;D=A+B*2&lt;/strong&gt;&#123;&#123;d&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;strong class=\"data-label\"&gt;E=B/2&lt;/strong&gt;&#123;&#123;e&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;strong class=\"data-label\"&gt;F=C+D&lt;/strong&gt;&#123;&#123;f&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;strong class=\"data-label\"&gt;G=D-E&lt;/strong&gt;&#123;&#123;g&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data() &#123; return &#123; a: 3, b: 4 &#125; &#125;, //计算属性将被混入到Vue实例中. //所有getter和setter的this上下文自动地绑定为Vue实例. computed: &#123; c() &#123; return this.a * 2 + 2 &#125;, d() &#123; return Number(this.a) + this.b * 2 &#125;, e() &#123; return this.b / 2 &#125;, f() &#123; return Number(this.c) + Number(this.d) &#125;, g() &#123; return this.d - this.e &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果如下图所示 : 数据绑定视图下面通过一个示例程序,事实现数据与视图之间的双向绑定 : 在对象函数的setter函数中修改文本节点的值,所以当obj.profile被重新赋值时,节点视图也会同步更新; 然后对输入框添加事件监听(addEventListener),当用户事件触发时,输入值将被赋予obj.profile. 以此方式,我们实现了数据与视图之间的双向绑定,这也就是Vue数据与视图绑定的实现原理 .123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue.js数据绑定视图的实现原理&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;span id=\"harry\" style=\"line-height: 32px;\"&gt;&amp;nbsp;&lt;/span&gt; &lt;input id=\"trigger\" type=\"text\" /&gt; &lt;script&gt; let harry = document.getElementById(\"harry\") let trigger = document.getElementById(\"trigger\") let key = 'profile' //对象属性键名 let store = &#123;&#125; //辅助get取值 let obj = &#123; //对象 profile: '' &#125; Object.defineProperty(obj, key, &#123; set(value) &#123; harry.innerText = value //重点:修改DOM节点视图 store[key] = value &#125;, get() &#123; return store[key] &#125; &#125;) trigger.addEventListener('keyup', function() &#123; obj[key] = this.value console.log(obj[key]) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果如下图所示 : 在Vue中,当我们把普通的JavaScript对象传给Vue实例的data选项时,Vue将遍历对象属性,并使用Object.defineProperty将其全部转换为getter/setter,并在组件渲染时将属性记录为依赖. 之后当依赖项的setter函数被调用时,会通知watcher重新计算并更新其关联的所有组件. 由于Object.definedProperty是ES5中一个无法shim(自定义扩展)的特性,所以Vue应用无法运行在不支持Objcet.defineProperty的IE8及其以下版本的浏览器上 .","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue.js的语法","slug":"Vue-js的语法","date":"2019-07-21T03:14:08.000Z","updated":"2019-08-25T06:31:01.106Z","comments":true,"path":"2019/07/21/Vue-js的语法/","link":"","permalink":"http://yoursite.com/2019/07/21/Vue-js的语法/","excerpt":"","text":"学习笔记 : Vue.js的语法数值绑定文本插值文本插值的方式十分简单,只需使用双括号(Mustache语法)将要绑定的变量,值,表达式括住即可,Vue将会获取计算后的值,并以文本的形式将其展示出来 .123456789&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;);&lt;/script&gt; HTML插值HTML插值是对文本插值的补充和扩展,其可以动态渲染DOM节点,常用于处理开发者无可预知和难以控制的DOM结构,如渲染用于随意书写的文档结构等 ..123456789&lt;div id=\"app\"&gt;&lt;p v-html=\"message\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var v = new Vue(&#123; el: '#app', data: &#123; message: '&lt;h1 style=\"color: red;\"&gt;v-html&lt;/h1&gt;' &#125; &#125;);&lt;/script&gt; 属性绑定指令-vindDOM节点的属性基本都可以用指令v-bind进行绑定,其简写为 ‘:‘,可绑定的属性可以是变量,表达式,执行函数等内容,不过最终的结果都应该满足属性自身的约束 .1234567891011&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"按钮\" v-bind:title=\"message+'可以拼接字符串哟 ~'\" /&gt;&lt;/div&gt;&lt;script&gt; var v = new Vue(&#123; el: '#app', data: &#123; message: 'v-bind' &#125; &#125;);&lt;/script&gt; 类名和样式绑定由于类名class,和样式style在节点属性中是两个比较奇怪对的存在,虽然他们可接收的类型都是字符串,但类名实际上是由数组拼接而成,而样式则是由对象属性键值对拼接而成的,所以Vue在绑定类名和样式时也采用不一样的机制哟 ! 通过字符串,数组,对象方式为节点动态绑定类名属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Vue为节点绑定类型属性&lt;/title&gt; &lt;style type=\"text/css\"&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 50px; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 0.5em; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2 :class=\"['red','italic']\"&gt;使用数组&lt;/h2&gt; &lt;h2 :class=\"['red','italic',flag?'active':'']\"&gt;数组中使用三元表达式&lt;/h2&gt; &lt;h2 :class=\"['red','italic',&#123;'active':flag&#125;]\"&gt;数组中使用对象代替三元表达式&lt;/h2&gt; &lt;h2 :class=\"&#123;red:true,thin:true,italic:false,active:true&#125;\"&gt;使用对象&lt;/h2&gt; &lt;h2 :class=\"classObj\"&gt;使用对象&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: true &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue绑定样式的方式和类名相似,不过样式是以键值对的形式,所以不能像类名一样使用数组进行绑定哟 ~ 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Vue样式绑定&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2 :style=\"&#123;color:'red'&#125;\"&gt;Vue样式绑定&lt;/h2&gt; &lt;h2 :style=\"styleObj\"&gt;Vue样式绑定&lt;/h2&gt; &lt;h2 :style=\"[styleObj,styleObj2]\"&gt;Vue样式绑定&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: \"#app\", data: &#123; styleObj: &#123; color: 'forestgreen', 'font-style': 'italic' &#125;, styleObj2: &#123; 'font-size': '30px' &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件绑定指令v-onVue使用v-on指令监听DOM事件,开发者可以将事件代码通过v-on指令绑定到DOM节点上,其简写为 @123456789101112131415161718&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"简写:鼠标点击事件\" @click=\"show\" /&gt; &lt;input type=\"button\" value=\"鼠标点击事件\" id=\"btn\" v-on:click=\"show\" /&gt; &lt;input type=\"button\" value=\"鼠标覆盖事件\" id=\"btn\" v-on:mouseover=\"show\" /&gt;&lt;/div&gt;&lt;script&gt; var v = new Vue(&#123; el: '#app', data: &#123; message: 'v-on', &#125;, methods: &#123; show: function() &#123; alert('Hi Vue!') &#125; &#125; &#125;);&lt;/script&gt; 常见修饰符常用的事件修饰符如下所示 : 名称 可用版本 可用事件 说明 .stop 所有 任意 当事件触发时,阻止事件冒泡 .prevent 所有 任意 当事件触发时,阻止元素的默认行为 .capture 所有 任意 当事件触发时,限制事件捕获 .self 所有 任意 限制事件仅作用于节点自身 .once 2.1.4以上 任意 事件被触发一次后既解除监听 .passive 2.1.4以上 滚动 移动端,限制事件永不调用preventDefault()方法 .stop事件修饰符示例程序如下 : 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;.stop&lt;/title&gt; &lt;style&gt; #app&#123; height: 60px; width: 60px; background-color: lightgray; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\" @click=\"divHandler\"&gt; &lt;input type=\"button\" value=\"Click\" @click.stop=\"btnHandler\" /&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; divHandler: function() &#123; console.log(\"触发'divHandler事件 !'\") &#125;, btnHandler: function() &#123; console.log(\"触发了'btnHandler事件 !'\") &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; .prevent事件修饰符示例程序如下 : 12345678910111213&lt;div id=\"app\"&gt; &lt;a href=\"https://yubuntu0109.github.io\" @click.prevent=\"linkClick\"&gt;my personal website ~&lt;/a&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; linkClick: function() &#123; console.log(\"触发了'linkClick'事件 !\") &#125; &#125; &#125;);&lt;/script&gt; .capture事件修饰符示例程序如下 : 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;.capture&lt;/title&gt; &lt;style&gt; #app&#123; background-color: lightcyan;; height: 60px; width: 60px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\" @click.capture=\"divHandler\"&gt; &lt;input type=\"button\" value=\"Click\" @click=\"btnHandler\" /&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; divHandler: function() &#123; console.log(\"触发'divHandler事件 !'\") &#125;, btnHandler: function() &#123; console.log(\"触发了'btnHandler事件 !'\") &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; .self事件修饰符示例程序如下 : 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"../resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;.self&lt;/title&gt; &lt;style&gt; #app&#123; height: 60px; width: 60px; background-color: lightgray; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\" @click=\"divHandler\"&gt; &lt;input type=\"button\" value=\"Click\" @click.stop=\"btnHandler\" /&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; divHandler: function() &#123; console.log(\"触发'divHandler事件 !'\") &#125;, btnHandler: function() &#123; console.log(\"触发了'btnHandler事件 !'\") &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; .once事件修饰符示例程序如下 : 12345678910111213&lt;div id=\"app\"&gt; &lt;a href=\"https://yubuntu0109.github.io\" @click.prevent.once=\"linkClick\"&gt;my personal website ~&lt;/a&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; linkClick: function() &#123; console.log(\"触发了'linkClick'事件 !\") &#125; &#125; &#125;);&lt;/script&gt; 按键修饰符略 · · · 组件修饰符略 · · · 双向绑定Vue实现数据绑定视图的基本原理可以参考我的这篇学习笔记哟 : demo.url 指令v-model可以使用v-model为可输入元素(input&amp;textarea)创建双向数据绑定(v-bind只能实现数据的单向绑定),它会根据元素类型自动选取正确的方法来更新元素哟 ~123456789101112&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt; v-model : &lt;input type=\"text\" v-model=\"msg\" /&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'stay hungray,stay foolish ~' &#125; &#125;);&lt;/script&gt; v-model与修饰符 修饰符 可用版本 说明 .lay 所有 将用户输入的数据赋值于变量的时机由输入时延迟到数据改变时 .number 所有 自动转换用户输入为数值类型 .trim 所有 自动过滤用户输入的首尾空白字符 v-model与自定义组件略 · · · 条件渲染和列表渲染指令v-if与v-showv-if的使用方法并不复杂,只需要为元素挂上v-if指令即可,与之配套的还有v-else-if和v-else. 而v-show指令也可以用于实现条件渲染,不过它只是简单地切换元素的CSS属性 : display. 根据它们实现的机制来说 : v-show有更高的初始渲染开销,而v-if有更高的切换开销 . v-if指令示例程序如下 : 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;h2 v-if=\"order===0\"&gt;v-if&lt;/h2&gt; &lt;h2 v-else-if=\"order===1\"&gt;v-else-if&lt;/h2&gt; &lt;h2 v-else&gt;v-else&lt;/h2&gt; &lt;button @click=\"toggleTitle\"&gt;change title&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; order: 0, &#125;, methods: &#123; toggleTitle() &#123; this.order = ++this.order % 3 console.log('order vaule : ', this.order) &#125; &#125; &#125;);&lt;/script&gt; v-show示例程序如下 : 123456789101112&lt;div id=\"app\"&gt; &lt;h2 v-show=\"flag\"&gt;v-show&lt;/h2&gt; &lt;button type=\"button\" @click=\"flag=!flag\"&gt;display(true) / display(false)&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125; &#125;);&lt;/script&gt; 指令v-forv-for用于实现列表渲染,可以使用item in items或item of items的语法 . 使用v-for遍历普通数组 : 123456789101112&lt;div id=\"app\"&gt; &lt;p&gt;array : &#123;&#123;list&#125;&#125;&lt;/p&gt;&lt;hr&gt; &lt;p v-for=\"(item,i) in list\"&gt;index:&#123;&#123;i&#125;&#125;---&gt;element:&#123;&#123;item&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3] &#125; &#125;);&lt;/script&gt; 使用v-for遍历对象 : 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;p v-for=\"(val,key,i) in user\"&gt;INDEX:&#123;&#123;i&#125;&#125;---&gt;&#123;&#123;key&#125;&#125;---&gt;&#123;&#123;val&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; user: &#123; id: 1, name: 'YUbuntu0109', gender: 'male', age: '21', email: '3083968068@qq.com' &#125; &#125; &#125;);&lt;/script&gt; 使用v-for遍历对象数组 : 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;p v-for=\"(user,i) in list\"&gt;INDEX:&#123;&#123;i&#125;&#125;---&gt;ID:&#123;&#123;user.id&#125;&#125;---&gt;NAME:&#123;&#123;user.name&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; list: [&#123; id: 1, name: 'demo-name-1' &#125;, &#123; id: 2, name: 'demo-name-2' &#125;, &#123; id: 3, name: 'demo-name-3' &#125; ] &#125; &#125;);&lt;/script&gt; 列表渲染中的key在使用v-for时,最好为每个迭代元素提供一个不重复的key. 因为当列表渲染被重新执行(数组内容发生变化)时,若不适用key,Vue会为数组成员就近复用已存在的DOM节点,如下图所示 : 当使用key时,Vue会根据key的变化重新排列节点顺序,并移除key不存在的节点 ! 其实质是 : key的存在是为DOM节点标注了一个身份信息,继而让Vue有迹可循地追踪到数据对应的节点 ! 示例程序如下 :12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"app\"&gt; &lt;div&gt; &lt;label&gt;ID : &lt;input type=\"text\" v-model=\"id\"&gt;&lt;/label&gt; &lt;label&gt;NAME : &lt;input type=\"text\" v-model=\"name\"&gt;&lt;/label&gt; &lt;button @click=\"add\"&gt;ADD&lt;/button&gt; &lt;/div&gt; &lt;!-- Avoid using non-primitive value as key, use string/number value instead. --&gt; &lt;p v-for=\"user in users\" v-bind:key=\"user.id\"&gt; &lt;input type=\"checkbox\" /&gt; &#123;&#123;user.id&#125;&#125;---&gt;&#123;&#123;user.name&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', users: [&#123; id: 1, name: 'demo-name-1' &#125;, &#123; id: 2, name: 'demo-name-2' &#125;, &#123; id: 3, name: 'demo-name-3' &#125; ] &#125;, methods: &#123; add() &#123; //the elements to add to the front of the array. this.users.unshift(&#123; id: this.id, name: this.name &#125;); &#125; &#125; &#125;);&lt;/script&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue.js的生命周期","slug":"Vue-js的生命周期","date":"2019-07-20T13:56:19.000Z","updated":"2019-08-25T06:31:01.099Z","comments":true,"path":"2019/07/20/Vue-js的生命周期/","link":"","permalink":"http://yoursite.com/2019/07/20/Vue-js的生命周期/","excerpt":"","text":"学习笔记 : 详解Vue.js的生命周期Vue实例的生命周期函数从Vue实例创建,运行,到销毁期间,总是伴随着各种各样的事件,这些事件统称为生命周期,至于生命周期钩子只不过是生命周期事件的别名而已. 其生命周期图如下所示 : 初始阶段 钩子函数 描述 数据 真实DOM 项目中的应用 beforeCreate 表示组件创建前的准备工作,为事件的发布订阅和生命周期的开始做初始化 无 无 项目中一般不使用 created 表示组件创建结束 有 无 异步数据请求,然后可以进行一次默认数据的修改 beforeMount 表示组件装载前的准备工作(VDOM) 有 无 数据请求,它也可以进行一次数据修改 mounted 组件挂载结束,真实DOM渲染完成 有 有 DOM操作,第三方库的实例化 beforeCreate : 在实例初始化之后,数据观测(data observer)和event/watcher事件配置之前被调用 created : 实例已经创建完成之后被调用. 在这一步,实例已完成以下的配置 : 数据观测(data observer)属性初始化和方法的运算,watch/event事件回调. 然而挂载阶段还没开始,$el属性目前不可见 beforeMount : 在挂载开始之前被调用,相关的render函数首次被调用 mounted : el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子. 如果root实例挂载了一个文档内元素,当mounted被调用时vm.$el也在文档内 运行阶段 钩子函数 描述 数据 真实DOM 项目中的应用 beforeUpdate 数据更新前的准备工作,数据修改才会执行 有(修改后的数据) 有 生成新的VDOM,然后通过diff算法进行两次VDOM对比,没有太多的操作意义 updated 数据更新结束,通过render函数渲染真实DOM 有 有(重新渲染后的真实DOM) 可以进行异步数据请求得到的DOM渲染的第三方库实例化 beforeUpdate : 数据更新时调用,发生在虚拟DOM重新渲染和打补丁之前. 你可以在这个钩子中进一步地更改状态,这不会触发附加的重渲染过程 updated : 由于数据更改导致的虚拟DOM重新渲染和打补丁,在这之后会调用该钩子. 当这个钩子被调用时,组件DOM已经更新,所以你现在可以执行依赖于DOM的操作 销毁阶段 钩子函数 描述 beforeDestroy 组件即将销毁,准备调用$destroy()方法 destroyed 组件销毁结束 beforeDestroy : 实例销毁之前调用. 在这一步,实例仍然完全可用 destroyed : Vue实例销毁后调用. 调用后,Vue实例指示的所有东西都会解绑定,所有的事件监听器会被移除,所有的子实例也会被销毁 生命周期函数程序示例可通过下面这个简单实例来观察这些生命周期函数执行的时机哟 ~1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;the life cycle of Vue&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;button @click=\"randomTitle()\"&gt;Change title&lt;/button&gt; &lt;button @click=\"destoryVm()\"&gt;destory VM&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; title: 'Hi Vue !' &#125; &#125;, //methods将被混入到Vue实例中.可以直接通过VM实例访问这些方法,或者在指令表达式中使用. //方法中的this自动绑定为Vue实例. methods: &#123; randomTitle: function() &#123; //floor:returns the largest integer less than or equal to a number. this.title = 'Hi ' + ['HTML', 'CSS', 'JS'][Math.floor(Math.random() * 2.99)] &#125;, destoryVm: function() &#123; this.$destroy() &#125; &#125;, //实例初始化后,数据观测和事件绑定之前 beforeCreate() &#123; //注:此时data和methods还未被初始化哟 console.log('before create') &#125;, //实例初始化完成,挂载尚未开始时 created() &#123; //注:此时data与methods已被初始化了哟 console.log('created') &#125;, //挂载之前,render函数首先被调用时 beforeMount() &#123; //注:此时模板已在内存中编译完成,但尚未把模板渲染到页面中 console.log('before mount') &#125;, //在实例挂载到DOM节点之后 mounted() &#123; //注:此时内存中的模板已真实挂载到页面中,继而完成页面的渲染 console.log('mounted') &#125;, //数据更新时,在虚拟DOM状态变化之前 beforeUpdate() &#123; //注:数据被修改时则触发该事件,但此时页面上的数据并未更新哟 console.log('before update') &#125;, //虚拟DOM被重新渲染之后 updated() &#123; //注:此时页面中的数据已经与data保持同步了哟 console.log('updated') &#125;, //实例销毁之前,此时实例依然可用 beforeDestroy() &#123; console.log('before destory') &#125;, //实例销毁后,此时Vue实例及其子实例将完全解绑 destroyed() &#123; console.log('destoryed') &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 刚打开页面,既Vue示例刚被创建并挂载到DOM上时,调用的钩子函数如下图所示 : 点击change title按钮来改变标题数据,继而会触发视图更新,调用的钩子函数如下图所示 : 点击destroy VM按钮来销毁Vue实例,调用的钩子函数如下图所示 : 之后,尝试多次点击chang title按钮,发现视图不再响应数据的变化,继而证明此时节点上绑定的Vue实例已被销毁 !","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Hi Vue ~","slug":"Hi-Vue","date":"2019-07-19T11:35:40.000Z","updated":"2019-08-25T06:31:00.972Z","comments":true,"path":"2019/07/19/Hi-Vue/","link":"","permalink":"http://yoursite.com/2019/07/19/Hi-Vue/","excerpt":"","text":"学习笔记 : 拥抱Vue ~传统的网站开发一般采用HTML,CSS,JS作为技术架构,而Vue立足于其上,并以模板语法为基础,数据绑定和组件化开发为核心,极大地简化了项目的开发流程 ~ Vue简介Vue.js是一套轻量级MVVM框架,由时任前Google工程师(现任阿里Week团队技术顾问)的尤雨溪创造并开源,与其它重量级的框架不同的是,Vue的核心库只关注视图层,并且提供尽可能简单的API以实现数据绑定,组件复用等机制,且非常容易学习并混入其它库. 其Github开源地址 : https://github.com/vuejs/vue MVVM介绍模型-视图-控制器(Model-View-Controller,MVC)模式,在Web 1.0时代曾被广泛应用于Web架构中,然而其诞生时间比Web早几年,最初,MVC被应用于桌面程序中,然而在PHP,JSP等脚本语言诞生后,也逐渐成为Web开发的主流模式 ! 其MVVM作为MVC的其中一个衍生版本,MVVM主要的目的是分离视图(View)和模型(Model),ViewModel层封装了界面展示和操作的属性的接口. 通过数据绑定,我们可以将View和ViewModel关联一起,当ViewModel中的数据发生变化时,View也会同步进行更新,View与ViewModel之间通过双向绑定(data-binding)建立联系,如下图所示 : View : 视图层主要负责展示视图 ViewModel : 视图-模型层起到桥梁的作用,一方面响应用户事件并向模型层发送请求,另一方面将模型层返回的数据通过数据数据绑定在视图层中展示 Model : 模型层主要负责处理交互请求并返回响应的数据 MVVM模式解耦了视图和模型 : 在模式中,每一个视图都对应一个ViewModel,同时ViewModel与模型建立关联系,当接收到用户请求时,ViewModel获取模型响应数据,并通过数据绑定将相应的视图页面重新渲染. 视图层的数据只需要传入ViewModel即可实现视图层的同步更新,从而实现了视图和模型之间的松散耦合 . 下面以我的第一个Vue实例为例(具体语法解析见下述哟),简单地解析一下MVVM的各个部分 :12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;first program for Vue&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; View 层 1&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; ViewModel 层 12345678&lt;script&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;);&lt;/script&gt; Model 层 12345&lt;script&gt;data: &#123; message: 'Hello Vue!'&#125;&lt;/script&gt; 第一个Vue实例在这个实例中,初始化了带有’message’数据的’vm’对象,并将其绑定到’id’为’app’的DOM节点上. 初始化时,在实例上绑定的常规数据对象会被Vue转换为被观察的拥有可响应行为的对象,简单点说,就是当数据发生改变时,会同步更新其数据链和作用域中所有的相关状态,例如当实例数据发生改变时,视图也随之变化. 下面就义这个简单的Vue实例为例,简单地解析一下其语法 :12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"resources/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;first program for Vue&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; vm : 通过构造函数Vue就可以创建一个Vue的根实例,并启动Vue应用,变量vm就代表这个Vue实例. 例如 : 12345&lt;script&gt;var vm = new Vue(&#123; &#125;);&lt;/script&gt; el : 实际上,所有代码都是一个对象写入Vue实例(vm)内的. 首先,必不可少的一个选项就是el,其用于指定一个页面中已存在的DOM元素来挂载Vue实例,它可以是HTMLElement,也可以是CSS选择器,挂载成功后继而可以通过vm.$el来访问该元素,例如 : 1234567&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el:document.getElementById('app') //或:'#app'&#125;);&lt;script/&gt; data : 通过Vue实例的data选项,继而配合v-model指令可以声明应用内需要双向绑定的数据,例如 : 12345678910&lt;input type=\"text\" v-model=\"msg\" /&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'stay hungray,stay foolish ~' &#125;&#125;);&lt;/script&gt; 双括号(Mustache语法)是最基本的文本插值方法,它会自动将我们双向绑定的数据实时显示出来,例如 : 12345678910&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;);&lt;/script&gt; 📖 参考,推荐书籍 : 《Vue.js实战》—— 梁灏 · 编著 《Vue.js从入门到项目实战》—— 刘汉伟 · 编著","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"小爬虫:JDBookCrawler-V3.0","slug":"小爬虫-JDBookCrawler-V3-0","date":"2019-07-17T12:34:24.000Z","updated":"2019-08-25T06:31:01.191Z","comments":true,"path":"2019/07/17/小爬虫-JDBookCrawler-V3-0/","link":"","permalink":"http://yoursite.com/2019/07/17/小爬虫-JDBookCrawler-V3-0/","excerpt":"","text":"爬虫项目笔记 : JDBookCrawler-V3.0简介 : JDBookCrawler 3.0的爬虫功能基于JDBookCrawler 2.0,前端设计参考项目SpringBoot-curd-memo,简单点说v3.0等于v2.0+Spring Boot,😅不尴尬嘻嘻~ 项目概述项目结构图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687├─bookcrawler-v3.0│ │ crawler.sql│ │ mvnw│ │ mvnw.cmd│ │ pom.xml│ ││ ││ └─src│ └─main│ ├─java│ │ └─pers│ │ └─huangyuhui│ │ └─bookcrawler│ │ │ BookcrawlerApplication.java│ │ ││ │ ├─controller│ │ │ BookController.java│ │ ││ │ ├─crawler│ │ │ │ BookCrawlerTest.java│ │ │ ││ │ │ ├─dao│ │ │ │ BookDao.java│ │ │ ││ │ │ ├─mapper│ │ │ │ BookMapper.xml│ │ │ ││ │ │ ├─pojo│ │ │ │ Book.java│ │ │ ││ │ │ ├─resources│ │ │ │ db.properties│ │ │ │ log4j.properties│ │ │ │ mybatis-config.xml│ │ │ ││ │ │ ├─task│ │ │ │ BookProcessor.java│ │ │ ││ │ │ └─util│ │ │ FileUtils.java│ │ │ HttpUtils.java│ │ │ MyBatisUtils.java│ │ ││ │ ├─dao│ │ │ BookMapper.java│ │ │ BookMapper.xml│ │ ││ │ ├─pojo│ │ │ Book.java│ │ ││ │ └─service│ │ │ BookService.java│ │ ││ │ └─impl│ │ BookServiceImpl.java│ ││ └─resources│ │ application.properties│ ││ ├─static│ │ │ exist.txt│ │ ││ │ └─easyui│ │ │ jquery.easyui.min.js│ │ │ jquery.min.js│ │ ││ │ ├─css│ │ │ default.css│ │ │ demo.css│ │ ││ │ ├─js│ │ │ outlook2.js│ │ │ validateExtends.js│ │ ││ │ └─themes| | |(略..)│ │ │ │| | │ └─templates│ bookList.html│ intro.html│ main.html│└─demonstration-images BookCrawler-V3.0-bookList.PNG BookCrawler-V3.0-Intro.PNG 程序运行指南 crawler.sql : 数据库文件 1BookCrawler-v3.0/bookcrawler-v3.0/crawler.sql BookCrawlerTest.java : 爬虫启动类(crawler包存放的是JDBookCrawler-v2.0哟 ~) 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.bookcrawler.crawler;import pers.huangyuhui.bookcrawler.crawler.task.BookProcessor;import pers.huangyuhui.bookcrawler.crawler.util.FileUtils;/** * @project: bookcrawler * @description: 爬虫测试程序 * @author: 黄宇辉 * @date: 7/11/2019-9:12 PM * @version: 2.0 * @website: https://yubuntu0109.github.io/ */public class BookCrawlerTest &#123; //自定义搜索关键字 private static final String KEY_WORD = \"网络爬虫\"; //自定义页码数,每页可爬取三十条数据(注:下一页的页码数为前一页的页码数加二) private static final int END_PAGE_NUM = 2; private static final int CURRENT_PAGE_NUM = 1; //获取项目下存储书籍图片的文件夹路径 private static final String IMAGE_PATH = FileUtils.getDirPath(\"/static/download/bookImage/\"); //书籍列表页面的链接 private static final String URL = \"https://search.jd.com/Search?keyword=\" + KEY_WORD + \"&amp;enc=utf-8&amp;page=\"; /** * @description: 🕷启动爬虫 * @date: 2019-07-15 4:09 PM */ public static void main(String[] args) &#123; new BookProcessor(URL, IMAGE_PATH, CURRENT_PAGE_NUM, END_PAGE_NUM).run(); &#125;&#125; 启动爬虫后其控制台输出的日志信息请参考JDBookCrawler-v2.0 : https://yubuntu0109.github.io/2019/07/15/%E5%B0%8F%E7%88%AC%E8%99%AB-JDBookCrawler-V2-0/ BookcrawlerApplication.java : 项目启动类(爬虫程序成功运行完成后,就可以启动该项目啦,这操作不尴尬哈哈哈 ~) 123456789101112131415161718192021package pers.huangyuhui.bookcrawler;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @project: bookcrawler * @description: 项目启动类 * @author: 黄宇辉 * @date: 7/11/2019-9:16 PM * @version: 3.0 * @website: https://yubuntu0109.github.io/ */@SpringBootApplication@MapperScan(\"pers.huangyuhui.bookcrawler.dao\") //扫描Mapper接口public class BookcrawlerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BookcrawlerApplication.class, args); &#125;&#125; 成功启动项目后,其项目主页,图书数据管理页如下图所示 :","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"WebMagic","slug":"WebMagic","permalink":"http://yoursite.com/tags/WebMagic/"},{"name":"Crawler","slug":"Crawler","permalink":"http://yoursite.com/tags/Crawler/"}]},{"title":"Understanding the GitHub flow","slug":"Understanding-the-GitHub-flow","date":"2019-07-15T23:45:10.000Z","updated":"2019-08-25T06:31:01.084Z","comments":true,"path":"2019/07/16/Understanding-the-GitHub-flow/","link":"","permalink":"http://yoursite.com/2019/07/16/Understanding-the-GitHub-flow/","excerpt":"","text":"学习笔记 : GitHub工作流程GitHub流程(Git flow的简化版)是一种轻量级,基于分支的工作流程,支持定期进行部署的团队和项目. 本篇文章诠释了GitHub流程的工作原理及流程 . GitHub工作流程可以简单地分为以下步骤 : 第一步 : 根据需求,从master拉出新分支(不区分功能分支或补丁分支) . 第二步 : 新分支开发完成后需要合并,谈论时,就需要向master发起一个pull request (PR) . 第三步 : Pull Request既是一个通知 : 让别人注意到你的请求,又是一种对话机制 : 让大家一起审核及讨论你的更改信息, 对话过程中可以不断修改提交信息并提交哟 . 第四步 : 当Pull Request通过审核后,继而可以与master合并啦 ! 成功重新部署后,原来你创建的那个分支就可以删除咯(先部署再合并也可以哟) . A Successful Git Branching Model Create a branch 当你在一个项目上工作时,你会在任何特定时间都有一堆不同的功能或想法,既而分支可以帮助你管理其工作流程. 在项目中创建分支等同于创建一个可以尝试新想法的环境. 你在新建分支上所做的更改并不会影响master分支(主分支),因此你可以自由地进行实验和提交更改信息,并且在你准备好与你正在协作的人进行审核此分支前,其并不会与master分支合并,既而也不会污染到主分支哟 ~ Tip : 分支是Git中的核心概念,整个GitHub流程都是基于它的. 注意点 : master分支中的任何内容始终都是可部署的. 因此,在处理或修复功能时,创建新分支是必要的操作,注意哟,分行名称应该是具有描述性的(如 : refactor-authentication,user-content-cache-key,make-retina-avatars),以便其他人理解正在进行的工作内容 . Add commits 创建分支后,就可以对其进行更改咯. 无论何时添加,编辑或删除文件,你最终都需要进行提交并将它们添加到你的分支,添加提交的过程会为你创建一份透明的工作历史记录,以便其他人可以了解你已完成的工作. 每个提交都有一个关联的提交信息描述,该信息是解释为何进行特定更改的描述. 此外,每个提交都被视为一个单独的变更单位,既而如果发现程序错误或想决定改变开发方向,你都可以回滚其更改的信息哟 . Tip : 提交时的描述消息很重要,因为Git会跟踪你的更改,然后在将它们推送到服务器后将其显示提交的描述信息. 通过编写清晰的提交描述信息,可以更轻松地让其他人跟进并提供反馈信息 . Open a Pull Request Pull Requests会启动有关你的提交的讨论. 任何人都可以确切地看到他们所接受的你的请求及将会合并哪些更改等信息. 你可以在开发过程中的任何时候使用拉取请求 : 如当你想要分享一些屏幕截图或一些想法,或遇到困难并需要帮助或建议时… 当你准备好想让某人审查你的工作时,可以通过在Pull Request消息中使用GitHub的@mention哟 ~ Tip : Pull Requests对于贡献开源项目和管理对共享存储库的更改非常有帮助. 如果你使用的是Fork＆Pull模式 : 则Pull Requests提供了一种可以通知项目维护者你希望他们考虑的更改的方法. 如果你使用的是共享存储库模式 : 则Pull Requests会在合并到主分支之前帮助启动代码审查和有关建议更改的对话 . Discuss and review your code 一旦Pull Request开始,审核你的更改信息的人员或团队可能会有问题或意见,其原因可能是因为编码风格与项目编码风格规定不符等等等 .. Pull Requests后的这个审核与探讨的过程是非常有意义的,如果有人评论你忘了做某事或代码中有错误,你可以在分支中修复它并继续推送其更改信息. GitHub将在统一的Pull Request视图中显示你的新提交及你可能收到的任何其他反馈信息 . Tip : Pull Request的评论是用Markdown编写的,因此你可以嵌入图片和表情符号,或使用预先格式化的文本块哟 ~ Deploy (实际开发中所需步骤) 一旦你的pull request请求被检查并且分支通过测试,你就可以通过重新部署继而在生产中验证它们. 若你发现你的分支出现了错误,则可以通过将现有的主服务器部署到生产环境中来回滚它 . Merge 现在你的更改已在生产中得到验证,是时候将代码合并到主分支中了啦. 合并后,Pull Requests会保留代码更改的记录,且它们是可被搜索到的,所以任何人都可以随时回头来查看,理解当初做出决定的解释信息 . Tip : 通过将某些关键字合并到Pull Request的文本中,可以将issues与代码相关联. 合并Pull Request请求后,相关问题也将关闭. 例如 : 输入关键字Closes #32后将关闭存储库中的第32个issue. 更多信息请查看帮助文章 : https://help.github.com/en/articles/closing-issues-using-keywords 🙂 refer to : https://guides.github.com/introduction/flow/","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"小爬虫:JDBookCrawler-V2.0","slug":"小爬虫-JDBookCrawler-V2-0","date":"2019-07-15T08:41:47.000Z","updated":"2019-08-25T06:31:01.177Z","comments":true,"path":"2019/07/15/小爬虫-JDBookCrawler-V2-0/","link":"","permalink":"http://yoursite.com/2019/07/15/小爬虫-JDBookCrawler-V2-0/","excerpt":"","text":"爬虫项目笔记 : JDBookCrawler-V2.0简介 : 最近在学习爬虫技术,学习HttpClient,Jsoup后,又浅薄地学习了WebMagic爬虫框架嘿嘿,为了总结知识点继而用其重写了JDBookCrawler-V1.0,其功能为 : 爬取京东商城书籍数据. 程序已Psuh到GitHub : https://github.com/YUbuntu0109/Crawler-learning/tree/master/BookCrawler-v2.0/bookcrawler-v2.0 项目概述项目结构图123456789101112131415161718192021222324252627282930313233└─bookcrawler-v2.0 │ │ crawler.sql │ pom.xml │ └─src └─main ├─java │ └─pers │ └─huangyuhui │ └─bookcrawler │ │ BookCrawlerTest.java │ │ │ ├─dao │ │ BookDao.java │ │ │ ├─mapper │ │ BookMapper.xml │ │ │ ├─pojo │ │ Book.java │ │ │ ├─task │ │ BookProcessor.java │ │ │ └─util │ HttpUtils.java │ MyBatisUtils.java │ └─resources db.properties log4j.properties mybatis-config.xml 程序运行指南 crawler.sql : 数据库文件 1BookCrawler-v2.0/bookcrawler-v2.0/crawler.sql db.properties : 连接数据库的配置文件 1234jdbc.driver.class=com.mysql.cj.jdbc.Driverjdbc.connection.url=jdbc:mysql://localhost/crawler?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.connection.username=x-x-x-x-x-xjdbc.connection.password=x-x-x-x-x-x BookCrawlerTest.java : 爬虫启动程序 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.bookcrawler;import pers.huangyuhui.bookcrawler.task.BookProcessor;/** * @project: bookcrawler * @description: 爬虫测试程序 * @author: 黄宇辉 * @date: 7/11/2019-9:12 PM * @version: 2.0 * @website: https://yubuntu0109.github.io/ */public class BookCrawlerTest &#123; //自定义搜索关键字 private static final String KEY_WORD = \"人工智能\"; //自定义页码数,每页可爬取三十条数据(注:下一页的页码数为前一页的页码数加二) private static final int END_PAGE_NUM = 6; private static final int CURRENT_PAGE_NUM = 1; //自定义存储书籍图片的文件夹路径 private static final String IMAGE_PATH = \"D:\\\\BookCrawler-V2.0\\\\download\\\\image\\\\\"; //书籍列表页面的链接 private static final String URL = \"https://search.jd.com/Search?keyword=\" + KEY_WORD + \"&amp;enc=utf-8&amp;page=\"; /** * @description: 🕷启动爬虫 * @date: 2019-07-15 4:09 PM */ public static void main(String[] args) &#123; new BookProcessor(URL, IMAGE_PATH, CURRENT_PAGE_NUM, END_PAGE_NUM).run(); &#125;&#125; 运行程序BookCrawlerTest.java,下载的图书图片如下图所示 : 数据库中存储的数据如下图所示 : 控制台输出的日志信息如下 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545get page: https://search.jd.com/Search?keyword=人工智能&amp;enc=utf-8&amp;page=\\\\\\\\\\\\\\\\\\\\第 [1] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12401871&apos;, name=&apos;人工智能（第2版）&apos;, price=0.0, author=&apos;[美] 史蒂芬·卢奇（Stephen Lucci），丹尼·科佩克（Danny Kopec） 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-09-01&apos;, imageName=&apos;a29ae3a5-2ea6-46ed-83d6-717b05d1f908.jpg&apos;, bookUrl=&apos;https://item.jd.com/12401871.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t23818/34/1331170269/317511/8366eaf6/5b5aafaeNde873b63.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12401871.html\\\\\\\\\\\\\\\\\\\\第 [2] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12207597&apos;, name=&apos;人工智能：国家人工智能战略行动抓手&apos;, price=0.0, author=&apos;腾讯研究院，中国信息通信研究院互联网法律研究中心，腾讯AI，Lab，腾讯开放平台 著&apos;, publishing=&apos;中国人民大学出版社&apos;, pubDate=&apos;出版时间：2017-11-01&apos;, imageName=&apos;282f2e3f-09c6-4d68-8d20-346fb72f19da.jpg&apos;, bookUrl=&apos;https://item.jd.com/12207597.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t19183/5/105179285/303911/1ef2b6a3/5a5daca0Nf703cf05.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12207597.html\\\\\\\\\\\\\\\\\\\\第 [3] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12479132&apos;, name=&apos;TensorFlow深度学习算法原理与编程实战 人工智能机器学习技术丛书&apos;, price=0.0, author=&apos;蒋子阳 著&apos;, publishing=&apos;中国水利水电出版社&apos;, pubDate=&apos;出版时间：2019-01-01&apos;, imageName=&apos;5790ed2b-842e-4072-84c3-3426c517a2f6.jpg&apos;, bookUrl=&apos;https://item.jd.com/12479132.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t27298/82/1695620691/335423/92fe36d4/5bea3c3eN4634df6a.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12479132.html\\\\\\\\\\\\\\\\\\\\第 [4] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12128543&apos;, name=&apos;深度学习 [deep learning]&apos;, price=0.0, author=&apos;[美] Ian，Goodfellow，[加] Yoshua，Bengio，[加] Aaron ... 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-08-01&apos;, imageName=&apos;0e672484-b3ee-4eb4-b6a0-c7894b6303c3.jpg&apos;, bookUrl=&apos;https://item.jd.com/12128543.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t5818/302/7804032226/900940/cf90b609/597564a7N18c7d131.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12128543.html\\\\\\\\\\\\\\\\\\\\第 [5] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12310899&apos;, name=&apos;极简人工智能：你一定爱读的AI通识书&apos;, price=0.0, author=&apos;[英] 理查德·温（Richard Urwin） 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-03-01&apos;, imageName=&apos;56cbb95e-b5fa-4bc5-831a-465a84f035ff.jpg&apos;, bookUrl=&apos;https://item.jd.com/12310899.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t19312/264/663214983/462154/11c8edb/5a9e359dN2d6ea39d.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12310899.html\\\\\\\\\\\\\\\\\\\\第 [6] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：29499577195&apos;, name=&apos;智能时代套装共8册 李彦宏，周鸿祎等著 人工智能技术发展 智能投资顾问 智能制造 科技热点书籍&apos;, price=0.0, author=&apos;吴军，李彦宏，周鸿祎 等 著&apos;, publishing=&apos;中信出版社&apos;, pubDate=&apos;null&apos;, imageName=&apos;6d9e866f-7aee-417c-9762-8beaadf11dc6.jpg&apos;, bookUrl=&apos;https://item.jd.com/29499577195.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t1/18121/1/12049/206600/5c933fa4Efe54f0f9/3ccfd31db5e42d3f.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/29499577195.html\\\\\\\\\\\\\\\\\\\\第 [7] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12376742&apos;, name=&apos;人工智能产品经理——AI时代PM修炼手册&apos;, price=0.0, author=&apos;张竞宇 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;82dde8bc-b1b4-4b49-adf3-53e59cc4ce92.jpg&apos;, bookUrl=&apos;https://item.jd.com/12376742.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t25759/277/1900967055/256770/5bfe2114/5bbd70a4N60a7e82b.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12376742.html\\\\\\\\\\\\\\\\\\\\第 [8] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：11343660&apos;, name=&apos;世界著名计算机教材精选·人工智能：一种现代的方法（第3版） [Artificial Intelligence: a Modern Approach, Third Edition]&apos;, price=0.0, author=&apos;[美] 罗素（Stuart J.Russell），[美] 诺维格（Peter Norvig） 著，殷建平，祝恩，刘越 等 译&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2013-11-01&apos;, imageName=&apos;324c5505-cd8f-4ae7-bc74-7bbb6a61cea0.jpg&apos;, bookUrl=&apos;https://item.jd.com/11343660.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t1954/1/2075046846/185487/e06242ac/56f0e486N4d4fc662.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/11343660.html\\\\\\\\\\\\\\\\\\\\第 [9] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12555992&apos;, name=&apos;统计之美：人工智能时代的科学思维&apos;, price=0.0, author=&apos;李舰，海恩 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2019-03-01&apos;, imageName=&apos;fc187f37-dcf3-48d6-81b1-fc5896d6bd55.jpg&apos;, bookUrl=&apos;https://item.jd.com/12555992.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t1/14601/16/9247/614702/5c7cdf8fEa48b2815/d11cef0c74cd75d3.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12555992.html\\\\\\\\\\\\\\\\\\\\第 [10] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12347925&apos;, name=&apos;人工智能基础（高中版）&apos;, price=0.0, author=&apos;陈玉琨，汤晓鸥 著&apos;, publishing=&apos;华东师范大学出版社&apos;, pubDate=&apos;出版时间：2018-04-01&apos;, imageName=&apos;0ff1d052-4fd5-4831-913c-efc3872ed0ec.jpg&apos;, bookUrl=&apos;https://item.jd.com/12347925.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t17326/266/2369121830/200016/13c83576/5af150b3N0eca610b.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12347925.html\\\\\\\\\\\\\\\\\\\\第 [11] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：11867803&apos;, name=&apos;机器学习&apos;, price=0.0, author=&apos;周志华 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2016-01-01&apos;, imageName=&apos;4de24b78-9154-49d8-80c0-9fab447d1851.jpg&apos;, bookUrl=&apos;https://item.jd.com/11867803.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t5734/69/3225502890/67466/5e3df388/5937d6d1Nef59fd04.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/11867803.html\\\\\\\\\\\\\\\\\\\\第 [12] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：1027475348&apos;, name=&apos;奇点临近：一部预测人工智能和科技未来的奇书&apos;, price=0.0, author=&apos;李庆诚 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2011-10-01&apos;, imageName=&apos;d6330795-f295-468b-875b-ed6118883349.jpg&apos;, bookUrl=&apos;https://item.jd.com/1027475348.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/15/24/14880/65264/5bd938ccE7ff69361/8d5a0f5ea748f4e2.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/1027475348.html\\\\\\\\\\\\\\\\\\\\第 [13] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12421469&apos;, name=&apos;人工智能导论&apos;, price=0.0, author=&apos;李德毅 著&apos;, publishing=&apos;中国科学技术出版社&apos;, pubDate=&apos;出版时间：2018-08-01&apos;, imageName=&apos;5df786d7-9ee6-48f5-a1e2-5d40c6cc55b8.jpg&apos;, bookUrl=&apos;https://item.jd.com/12421469.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t25630/88/1092255641/333588/fa8d3a62/5b88b001N90fb40c7.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12421469.html\\\\\\\\\\\\\\\\\\\\第 [14] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12409581&apos;, name=&apos;Python深度学习&apos;, price=0.0, author=&apos;[美] 弗朗索瓦·肖莱（Francois Chollet） 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-08-01&apos;, imageName=&apos;49c88f27-12ad-4e45-8155-c56a1ea7e610.jpg&apos;, bookUrl=&apos;https://item.jd.com/12409581.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t24052/162/1920127927/141357/8e47c812/5b6ce057Nb138b0da.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12409581.html\\\\\\\\\\\\\\\\\\\\第 [15] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12079958&apos;, name=&apos;终极算法：机器学习和人工智能如何重塑世界 [The Master Algorithm]&apos;, price=0.0, author=&apos;[美] 佩德罗·多明戈斯（Pedro Domingos） 著，黄芳萍 译&apos;, publishing=&apos;中信出版社&apos;, pubDate=&apos;出版时间：2017-01-01&apos;, imageName=&apos;aada6c0d-fced-4758-a662-a2ad1bdf703d.jpg&apos;, bookUrl=&apos;https://item.jd.com/12079958.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t3124/275/4762074370/372795/41aa80f7/585754eaN47abddcc.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12079958.html\\\\\\\\\\\\\\\\\\\\第 [16] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12520143&apos;, name=&apos;深度学习的数学&apos;, price=0.0, author=&apos;[日] 涌井良幸，涌井贞美 著，杨瑞龙 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-05-01&apos;, imageName=&apos;b40d0444-627f-4e73-b90a-3eecb50ef7ff.jpg&apos;, bookUrl=&apos;https://item.jd.com/12520143.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/40561/20/503/109626/5cc291d1E77ee1d01/290c656633cdd2be.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12520143.html\\\\\\\\\\\\\\\\\\\\第 [17] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12527061&apos;, name=&apos;动手学深度学习&apos;, price=0.0, author=&apos;阿斯顿·张（Aston Zhang），李沐（Mu Li），[美] 扎卡里·C. 立顿 等 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-06-01&apos;, imageName=&apos;d05e6eb8-6fb3-4b25-8e9b-fd00d9f39eb6.jpg&apos;, bookUrl=&apos;https://item.jd.com/12527061.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t30334/279/1310794156/401599/fdb3f65d/5cdd1807N26004689.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12527061.html\\\\\\\\\\\\\\\\\\\\第 [18] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：10162072033&apos;, name=&apos;人工智能的未来&apos;, price=0.0, author=&apos;[美] 雷·库兹韦尔（RayKurzweil）著盛杨 著&apos;, publishing=&apos;浙江人民出版社&apos;, pubDate=&apos;出版时间：2016-03-01&apos;, imageName=&apos;890ab968-c7a8-4729-ab98-52d8f8b82c7e.jpg&apos;, bookUrl=&apos;https://item.jd.com/10162072033.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t18769/208/1426843696/50030/fd76e42b/5acb3fdfN9e4cd865.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/10162072033.html\\\\\\\\\\\\\\\\\\\\第 [19] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12585016&apos;, name=&apos;Python 3破冰人工智能 从入门到实战&apos;, price=0.0, author=&apos;黄海涛 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-05-01&apos;, imageName=&apos;0894de29-1818-4110-b017-7e87b4317489.jpg&apos;, bookUrl=&apos;https://item.jd.com/12585016.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t1/22785/38/15135/164500/5cad9d63E39517812/f7ac0780624e101e.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12585016.html\\\\\\\\\\\\\\\\\\\\第 [20] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：14146012074&apos;, name=&apos;深度学习 DeepLearning中文版 AI经典图书 人工智能 机器学习 图灵奖&apos;, price=0.0, author=&apos;[美] IanGoodfellow（伊恩·古德费洛） 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-07-01&apos;, imageName=&apos;4219f971-3875-451d-89a3-5874a409f8a9.png&apos;, bookUrl=&apos;https://item.jd.com/14146012074.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t1/76228/36/790/832099/5cf094bdE9a14cffb/be38f68200b6264a.png&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/14146012074.html\\\\\\\\\\\\\\\\\\\\第 [21] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12413625&apos;, name=&apos;万物皆数:从史前时期到人工智能，跨越千年的数学之旅&apos;, price=0.0, author=&apos;米卡埃尔·洛奈 著&apos;, publishing=&apos;null&apos;, pubDate=&apos;出版时间：2018-09-01&apos;, imageName=&apos;dee2d70f-57ea-4422-a1df-d16c709ca8db.jpg&apos;, bookUrl=&apos;https://item.jd.com/12413625.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t23812/47/2264205641/461319/1250f367/5b7a578aN7f2d84d4.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12413625.html\\\\\\\\\\\\\\\\\\\\第 [22] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12274722&apos;, name=&apos;人工智能简史&apos;, price=0.0, author=&apos;尼克 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-12-01&apos;, imageName=&apos;7d129014-fd06-49b5-bcf4-31c740be1477.jpg&apos;, bookUrl=&apos;https://item.jd.com/12274722.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t11869/61/2218872612/272676/bb7efcc8/5a126dc9N9d314d66.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12274722.html\\\\\\\\\\\\\\\\\\\\第 [23] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12573542&apos;, name=&apos;大话自动化：从蒸汽机到人工智能&apos;, price=0.0, author=&apos;[加] 晨枫 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2019-03-01&apos;, imageName=&apos;a7962c70-b673-4d3a-98d6-ccaa2b41543b.jpg&apos;, bookUrl=&apos;https://item.jd.com/12573542.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t1/23336/25/13133/121361/5c9dc769Ee15853fc/f3b00959a8aad99c.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12573542.html\\\\\\\\\\\\\\\\\\\\第 [24] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：28415991981&apos;, name=&apos;2本 机器学习实战+机器学习 周志华 人工智能书籍&apos;, price=0.0, author=&apos;&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2013-06-01&apos;, imageName=&apos;1e9590f1-d0d3-4209-b8b7-4f1a8a643de1.jpg&apos;, bookUrl=&apos;https://item.jd.com/28415991981.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t21373/332/2230500781/133567/cce95104/5b4d54e1N30452686.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/28415991981.html\\\\\\\\\\\\\\\\\\\\第 [25] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12287533&apos;, name=&apos;TensorFlow：实战Google深度学习框架（第2版）&apos;, price=0.0, author=&apos;郑泽宇，梁博文，顾思宇 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-02-01&apos;, imageName=&apos;7e644876-72dc-47b7-88c3-52f09abf581c.jpg&apos;, bookUrl=&apos;https://item.jd.com/12287533.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t17434/195/261082690/187949/a78ad6ce/5a66f7e9Nab382d53.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12287533.html\\\\\\\\\\\\\\\\\\\\第 [26] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：41580610489&apos;, name=&apos;包邮 AI未来 人工智能科学家李开复博士新作 樊登读书官方正版&apos;, price=0.0, author=&apos;李开复 著&apos;, publishing=&apos;浙江人民出版社&apos;, pubDate=&apos;null&apos;, imageName=&apos;f4e8c7fa-b509-43f8-99d6-238da56727d0.jpg&apos;, bookUrl=&apos;https://item.jd.com/41580610489.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t1/32882/35/1948/108480/5c640a94E6b20f60e/46a24f502ab529e5.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/41580610489.html\\\\\\\\\\\\\\\\\\\\第 [27] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12169266&apos;, name=&apos;人工智能（李开复谈AI如何重塑个人、商业与社会的未来图谱）&apos;, price=0.0, author=&apos;李开复，王咏刚 著&apos;, publishing=&apos;文化发展出版社（原印刷工业出版社）&apos;, pubDate=&apos;出版时间：2017-05-01&apos;, imageName=&apos;2711101c-96c7-45e9-a11e-0ef7d97d0a7c.jpg&apos;, bookUrl=&apos;https://item.jd.com/12169266.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t4819/45/722250163/218339/bf654418/58e738b5Nd99cca9b.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12169266.html\\\\\\\\\\\\\\\\\\\\第 [28] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12409398&apos;, name=&apos;裂变：秒懂人工智能的基础课&apos;, price=0.0, author=&apos;王天一 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-07-01&apos;, imageName=&apos;8adc17cc-5467-41cf-8a23-2f0d997e9bf1.jpg&apos;, bookUrl=&apos;https://item.jd.com/12409398.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t22231/64/2466497209/102410/530a3e94/5b56d8ecNda8180f5.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12409398.html\\\\\\\\\\\\\\\\\\\\第 [29] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：11953641&apos;, name=&apos;智能时代 大数据与智能革命重新定义未来&apos;, price=0.0, author=&apos;吴军 著&apos;, publishing=&apos;null&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;dbf1cbdc-9ef1-42dd-af66-4344685412c0.jpg&apos;, bookUrl=&apos;https://item.jd.com/11953641.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t3184/193/3137981286/767624/7871f22a/57ec6c71Nbb8823e7.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/11953641.html\\\\\\\\\\\\\\\\\\\\第 [30] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：40430886437&apos;, name=&apos;共6册 人工智能时代+人工智能的未来+中国制造2025+工业大数据+机器人革命等 互联网经济书籍&apos;, price=0.0, author=&apos;杰瑞·卡普兰 等 著&apos;, publishing=&apos;浙江人民出版社&apos;, pubDate=&apos;null&apos;, imageName=&apos;13a2ee3f-5b3f-4198-8614-4a1cc32b1c4a.jpg&apos;, bookUrl=&apos;https://item.jd.com/40430886437.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t1/11421/39/4122/467706/5c25b836Ed6ba55f9/dab653e81edd02a7.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/40430886437.htmlget page: https://search.jd.com/Search?keyword=人工智能&amp;enc=utf-8&amp;page=1\\\\\\\\\\\\\\\\\\\\第 [31] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：31131395716&apos;, name=&apos;深度学习入门 基于Python的理论与实现 人工智能书籍&apos;, price=0.0, author=&apos;斋藤康毅 著，陆宇杰 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-07-01&apos;, imageName=&apos;5eb3be60-7b68-4ade-a90f-e1954190120f.jpg&apos;, bookUrl=&apos;https://item.jd.com/31131395716.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t23689/23/1691623418/161900/d1cc437/5b6685deN6123cd3d.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/31131395716.html\\\\\\\\\\\\\\\\\\\\第 [32] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：47757445942&apos;, name=&apos;包邮 南京大学人工智能本科专业教育培养体系 南京大学人工智能学院 计算机 |8059538&apos;, price=0.0, author=&apos;南京大学人工智能学院 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2019-05-07&apos;, imageName=&apos;d7e66db0-c8f0-4ede-ade2-4d9861af2ebd.jpg&apos;, bookUrl=&apos;https://item.jd.com/47757445942.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t10102/31/2933036607/67354/bdf4f3c/5cdb8ef7Ne5368d06.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/47757445942.htmlget page: https://search.jd.com/Search?keyword=人工智能&amp;enc=utf-8&amp;page=3\\\\\\\\\\\\\\\\\\\\第 [33] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12579168&apos;, name=&apos;健康医疗大数据与人工智能&apos;, price=0.0, author=&apos;谭志明 著&apos;, publishing=&apos;华南理工大学出版社&apos;, pubDate=&apos;出版时间：2019-03-01&apos;, imageName=&apos;095a3156-094a-468a-abd7-b7c7498fe9d8.jpg&apos;, bookUrl=&apos;https://item.jd.com/12579168.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/20585/13/15144/198804/5cad56b1Ede738536/ede39481252c81ac.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12579168.html\\\\\\\\\\\\\\\\\\\\第 [34] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12527869&apos;, name=&apos;人工智能入门(第三册)&apos;, price=0.0, author=&apos;陈玉琨 著&apos;, publishing=&apos;null&apos;, pubDate=&apos;出版时间：2019-05-01&apos;, imageName=&apos;25111045-a99f-4962-8ce3-76be0ba2ccf3.jpg&apos;, bookUrl=&apos;https://item.jd.com/12527869.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t29668/42/1478784140/141336/1c4a81ef/5ce22885N5bf34745.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12527869.html\\\\\\\\\\\\\\\\\\\\第 [35] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12527873&apos;, name=&apos;人工智能入门(第一册)&apos;, price=0.0, author=&apos;陈玉琨 著&apos;, publishing=&apos;null&apos;, pubDate=&apos;出版时间：2019-05-01&apos;, imageName=&apos;986fc1db-cda5-4b57-9cf3-afc86af38cf1.jpg&apos;, bookUrl=&apos;https://item.jd.com/12527873.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t30340/182/1490153552/121687/31237809/5ce22276N03e8db9a.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12527873.html\\\\\\\\\\\\\\\\\\\\第 [36] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12458274&apos;, name=&apos;Python编程从零基础到项目实战（微课视频版）&apos;, price=0.0, author=&apos;刘瑜 著&apos;, publishing=&apos;中国水利水电出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;26c0a845-de07-4b84-9e50-12d86a576121.jpg&apos;, bookUrl=&apos;https://item.jd.com/12458274.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t25480/244/1868364232/520985/20f28aea/5bbecce9N302f62c4.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12458274.html\\\\\\\\\\\\\\\\\\\\第 [37] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：11242112&apos;, name=&apos;机器学习实战 [Machine learning in action]&apos;, price=0.0, author=&apos;[美] Peter Harrington 著，李锐，李鹏，曲亚东 等 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2013-06-01&apos;, imageName=&apos;d3c1e1ec-eacc-424b-aff1-be2f2bf036e8.jpg&apos;, bookUrl=&apos;https://item.jd.com/11242112.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t6439/92/490417530/198884/3856b75/59408659N77e984ce.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/11242112.html\\\\\\\\\\\\\\\\\\\\第 [38] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：47283830071&apos;, name=&apos;包邮【新华书店旗舰店官网】5G时代 什么是5G，它将如何改变世界 科技新趋势 人工智能 互联网时代&apos;, price=0.0, author=&apos;项立刚 著&apos;, publishing=&apos;中国人民大学出版社&apos;, pubDate=&apos;出版时间：2019-04-01&apos;, imageName=&apos;5bf9f88c-cfc8-4a0b-ad5c-b832bc78d7da.jpg&apos;, bookUrl=&apos;https://item.jd.com/47283830071.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t1/42131/32/6014/193740/5cf71efcEc457673b/4151049b1c63e67c.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/47283830071.html\\\\\\\\\\\\\\\\\\\\第 [39] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12613010&apos;, name=&apos;人工智能入门(第四册)&apos;, price=0.0, author=&apos;陈玉琨 著&apos;, publishing=&apos;null&apos;, pubDate=&apos;出版时间：2019-05-01&apos;, imageName=&apos;e34ba1bd-4bb3-4ff2-84df-ce0dae698c64.jpg&apos;, bookUrl=&apos;https://item.jd.com/12613010.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t29926/364/1493483692/113740/5303f75e/5ce229aaNd55be9a4.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12613010.html\\\\\\\\\\\\\\\\\\\\第 [40] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：39745566142&apos;, name=&apos;【R】正版现货 百面机器学习 算法工程师带你去面试 人工智能时代程序员面试宝典&apos;, price=0.0, author=&apos;诸葛越葫芦娃 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-08-01&apos;, imageName=&apos;6c3027d5-e3cd-4303-8af5-2f8f977dae07.jpg&apos;, bookUrl=&apos;https://item.jd.com/39745566142.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t1/77366/37/1195/53583/5cf76ecdE5a2b6e0f/8eafd0b6e9a681d6.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/39745566142.html\\\\\\\\\\\\\\\\\\\\第 [41] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12375632&apos;, name=&apos;云计算系统与人工智能应用&apos;, price=0.0, author=&apos;[美] 黄铠（Kai Hwang） 著，杜瑞颖 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;5cf647eb-90a0-4a7b-a597-7287ef06e57a.jpg&apos;, bookUrl=&apos;https://item.jd.com/12375632.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t22126/93/748719129/144639/f197de6/5b17364bNdc4e7771.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12375632.html\\\\\\\\\\\\\\\\\\\\第 [42] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：33583164783&apos;, name=&apos;包邮正版【樊登推荐】 万物皆数-从史前时期到人工智能.跨越千年的数学之旅 科普读物 科学世界&apos;, price=0.0, author=&apos;[法] 米卡埃尔·洛奈 著&apos;, publishing=&apos;null&apos;, pubDate=&apos;出版时间：2018-09-01&apos;, imageName=&apos;c4ffae4b-312d-4f92-a9bf-66bd51e21775.jpg&apos;, bookUrl=&apos;https://item.jd.com/33583164783.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/32558/24/10496/350587/5cb04564E998f676c/05be706e03c2f1b4.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/33583164783.html\\\\\\\\\\\\\\\\\\\\第 [43] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：37830680848&apos;, name=&apos;5本 深度学习+深度学习入门+Python编程基础+神经网络编程+TensorFlow 人工智能书籍&apos;, price=0.0, author=&apos;刘瑜 著&apos;, publishing=&apos;中国水利水电出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;13b098ed-45a9-40c6-902f-39a5d3d11240.jpg&apos;, bookUrl=&apos;https://item.jd.com/37830680848.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t26230/260/2320028096/278322/a8dadd5f/5bff5dccNe37a5bc8.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/37830680848.html\\\\\\\\\\\\\\\\\\\\第 [44] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12588974&apos;, name=&apos;区块链+人工智能 下一个改变世界的经济新模式&apos;, price=0.0, author=&apos;曲强，林益民 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-04-01&apos;, imageName=&apos;24c9e8a4-a54c-4806-be57-948ae0dcf840.jpg&apos;, bookUrl=&apos;https://item.jd.com/12588974.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t1/35238/29/2148/150932/5cb562d0Ea66cfdfc/48ba6009a5988cb1.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12588974.html\\\\\\\\\\\\\\\\\\\\第 [45] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12397348&apos;, name=&apos;生命3.0 [Life 3.0: being human in the age of artificial int]&apos;, price=0.0, author=&apos;[美] 迈克斯·泰格马克（Max Tegmark） 著，汪婕舒 译&apos;, publishing=&apos;浙江教育出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;5414c386-b10a-4c3e-bb86-bf864cb0ce51.jpg&apos;, bookUrl=&apos;https://item.jd.com/12397348.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/36812/38/1755/245651/5cb417deE1a175690/3d4dff1819643ed0.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12397348.html\\\\\\\\\\\\\\\\\\\\第 [46] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12513593&apos;, name=&apos;PyTorch深度学习&apos;, price=0.0, author=&apos;[印度] 毗湿奴·布拉马尼亚（Vishnu Subramanian） 著，王海玲，刘江峰 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-04-01&apos;, imageName=&apos;f7f6c51f-b56a-48b7-96fd-80941678fe9a.jpg&apos;, bookUrl=&apos;https://item.jd.com/12513593.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/16110/24/15063/116962/5cad48bbEe6208291/9a4e129af3089764.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12513593.html\\\\\\\\\\\\\\\\\\\\第 [47] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12384073&apos;, name=&apos;密钥01：人工智能来了&apos;, price=0.0, author=&apos;马汝为 著&apos;, publishing=&apos;长江出版社&apos;, pubDate=&apos;出版时间：2018-05-01&apos;, imageName=&apos;287691d4-1392-41a2-baa8-f87f630b95e3.jpg&apos;, bookUrl=&apos;https://item.jd.com/12384073.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t20317/48/2489478552/219264/10cf390/5b584703Nb1d8e713.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12384073.html\\\\\\\\\\\\\\\\\\\\第 [48] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12456940&apos;, name=&apos;机器与人：埃森哲论新人工智能&apos;, price=0.0, author=&apos;【美】保罗·多尔蒂，詹姆斯·威尔逊 著&apos;, publishing=&apos;中信出版集团,中信出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;fc59beef-5e99-448f-ac72-c92756777234.jpg&apos;, bookUrl=&apos;https://item.jd.com/12456940.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t1/9513/17/3311/264090/5bd5bc71E44ecbe61/3745ae9f76cb8371.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12456940.html\\\\\\\\\\\\\\\\\\\\第 [49] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：31329707691&apos;, name=&apos;正版 Python深度学习 deep learning深度学习 python人工智能机器学习经典教程&apos;, price=0.0, author=&apos;[美] 弗朗索瓦·肖莱 著，张亮 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-08-10&apos;, imageName=&apos;cada2188-dfb7-4894-8280-42f8f7eac626.png&apos;, bookUrl=&apos;https://item.jd.com/31329707691.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/jfs/t23251/24/1899370591/458471/efa1bee/5b6cf792N40cbf9f0.png&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/31329707691.html\\\\\\\\\\\\\\\\\\\\第 [50] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12317613&apos;, name=&apos;被人工智能操控的金融业 [人工知能が金融を支配する日]&apos;, price=0.0, author=&apos;[日] 樱井丰（YUTAKA SAKURAI） 著，林华，沈美华 译&apos;, publishing=&apos;null&apos;, pubDate=&apos;出版时间：2018-03-01&apos;, imageName=&apos;9ec77966-58f6-43b2-96ec-12087f0a7a10.jpg&apos;, bookUrl=&apos;https://item.jd.com/12317613.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t19735/145/839074499/262009/7cfa56f4/5aab5cabN562ad687.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12317613.html\\\\\\\\\\\\\\\\\\\\第 [51] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：11998799&apos;, name=&apos;Unity人工智能游戏开发（第2版）&apos;, price=0.0, author=&apos;[美] Ray，Barrera 等 著，张颖 译&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2016-10-01&apos;, imageName=&apos;683e3111-7bcd-4c6c-9639-303de9ab4493.jpg&apos;, bookUrl=&apos;https://item.jd.com/11998799.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t3829/185/508491523/41097/836c5f98/5812b48bN6de62bad.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/11998799.html\\\\\\\\\\\\\\\\\\\\第 [52] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12210115&apos;, name=&apos;艾伦·图灵传：如谜的解谜者（套装共2册） [Alan Turing—The Enigma]&apos;, price=0.0, author=&apos;[英] 安德鲁·霍齐斯 著，孙天齐 译&apos;, publishing=&apos;湖南科学技术出版社&apos;, pubDate=&apos;出版时间：2017-10-01&apos;, imageName=&apos;ce359df1-c5e6-4807-88ff-653a3f2758e2.jpg&apos;, bookUrl=&apos;https://item.jd.com/12210115.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t7594/81/3287046833/126424/85b9ada/59e95808N729047fa.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12210115.html\\\\\\\\\\\\\\\\\\\\第 [53] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：1604640379&apos;, name=&apos;世界因你不同 纪念版 李开复自传 推荐做最好的自己 AI未来 向死而生 人工智能&apos;, price=0.0, author=&apos;李开复，范海涛著 著&apos;, publishing=&apos;中信出版社&apos;, pubDate=&apos;出版时间：2015-07-01&apos;, imageName=&apos;925fbba4-1873-497b-a40e-f0555acedf26.jpg&apos;, bookUrl=&apos;https://item.jd.com/1604640379.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n1/jfs/t26545/258/2005258212/136674/34686624/5bf3ab9bN16ac783a.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/1604640379.html\\\\\\\\\\\\\\\\\\\\第 [54] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12506430&apos;, name=&apos;教育的未来（人工智能时代的教育变革） [Robot-Proof Higher Education in the Age of Artificial Intelligence]&apos;, price=0.0, author=&apos;[美] 约瑟夫·E.奥恩（Joseph E.Aoun） 著，李海燕，王秦辉 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2019-01-01&apos;, imageName=&apos;fdd869da-108d-4ad4-855f-d20608437678.jpg&apos;, bookUrl=&apos;https://item.jd.com/12506430.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t1/15820/31/3091/153355/5c2438e6Ebeaa8fea/f8c0ab3e60c857c8.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12506430.html\\\\\\\\\\\\\\\\\\\\第 [55] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：30150952862&apos;, name=&apos;生命3.0 人工智能中文版图书 life 3.0 湛庐文化&apos;, price=0.0, author=&apos;[美] 迈克斯·泰格马克（MaxTegmark）著汪 著&apos;, publishing=&apos;浙江教育出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;c99efda0-8260-474d-bba7-2b1f191f3e5c.jpg&apos;, bookUrl=&apos;https://item.jd.com/30150952862.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n1/jfs/t1/44288/38/479/392293/5cc28988E637dae92/f7e686d68153ab35.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/30150952862.html\\\\\\\\\\\\\\\\\\\\第 [56] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：10809441&apos;, name=&apos;生物心理学（第10版，全彩）&apos;, price=0.0, author=&apos;詹姆斯·卡拉特 著，苏彦捷 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2011-08-01&apos;, imageName=&apos;f73b471d-13bd-47e3-9af8-4e7cc429ec11.jpg&apos;, bookUrl=&apos;https://item.jd.com/10809441.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n1/19306/e7a8bb7d-2f89-4f65-b042-ddc90cc39eb2.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/10809441.html\\\\\\\\\\\\\\\\\\\\第 [57] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12650548&apos;, name=&apos;大数据战争 人工智能时代不能不说的事&apos;, price=0.0, author=&apos;何渊 等 著&apos;, publishing=&apos;北京大学出版社&apos;, pubDate=&apos;出版时间：2019-06-01&apos;, imageName=&apos;71120140-0ec8-4e10-9694-be6fe8202ab3.jpg&apos;, bookUrl=&apos;https://item.jd.com/12650548.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/68570/16/3747/471144/5d1f08e7Ea807c910/b97a32d6629a7b66.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12650548.html\\\\\\\\\\\\\\\\\\\\第 [58] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：31507798685&apos;, name=&apos;AI·未来 人工智能未来趋势 李开复 著&apos;, price=0.0, author=&apos;李开复 著&apos;, publishing=&apos;浙江人民出版社&apos;, pubDate=&apos;出版时间：2018-09-01&apos;, imageName=&apos;50c5ec26-14c0-43ec-8a83-c6ddde3ca862.jpg&apos;, bookUrl=&apos;https://item.jd.com/31507798685.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n1/jfs/t1/38609/20/2770/84550/5cc2899fEd9b4d0cc/a6565b5072e093f7.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/31507798685.html\\\\\\\\\\\\\\\\\\\\第 [59] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：41004058588&apos;, name=&apos;侯世达：我是一个怪圈 英文原版 I Am A Strange Loop 思维哲学 认知科学 人工智能&apos;, price=0.0, author=&apos;&apos;, publishing=&apos;null&apos;, pubDate=&apos;null&apos;, imageName=&apos;6d70a689-e4a0-4e2f-bdce-bd48d8b954f0.jpg&apos;, bookUrl=&apos;https://item.jd.com/41004058588.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t1/45070/26/3886/276666/5d19968aE89d5e32e/d6f3ed1ccd43bc9e.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/41004058588.html\\\\\\\\\\\\\\\\\\\\第 [60] 本\\\\\\\\\\\\\\\\\\\\Book&#123;shCode=&apos;商品编码：12336003&apos;, name=&apos;万物简史&apos;, price=0.0, author=&apos;布森特 著&apos;, publishing=&apos;天津人民出版社&apos;, pubDate=&apos;出版时间：2018-04-01&apos;, imageName=&apos;3b50cda6-37fa-4fe6-b81a-21bf31f78502.jpg&apos;, bookUrl=&apos;https://item.jd.com/12336003.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n1/jfs/t19672/258/1704812465/244862/85222d3d/5ad58d5cN96a94fdb.jpg&apos;&#125;[success]:This book data was added into the database successfully\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\get page: https://item.jd.com/12336003.htmlProcess finished with exit code 0","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"WebMagic","slug":"WebMagic","permalink":"http://yoursite.com/tags/WebMagic/"},{"name":"Crawler","slug":"Crawler","permalink":"http://yoursite.com/tags/Crawler/"}]},{"title":"小爬虫:JDBookCrawler-V1.0","slug":"小爬虫-JDBookCrawler-V1-0","date":"2019-07-14T05:30:47.000Z","updated":"2019-08-25T06:31:01.164Z","comments":true,"path":"2019/07/14/小爬虫-JDBookCrawler-V1-0/","link":"","permalink":"http://yoursite.com/2019/07/14/小爬虫-JDBookCrawler-V1-0/","excerpt":"","text":"爬虫项目笔记 : JDBookCrawler-V1.0简介 : 最近在学习爬虫技术,浅薄学习HttpClient,Jsoup后,为了总结知识点既而写了这个小爬虫 : 爬取京东商城书籍数据. 程序已Psuh到GitHub : https://github.com/YUbuntu0109/Crawler-learning/tree/master/BookCrawler-v1.0/bookcrawler 项目概述项目结构图12345678910111213141516171819202122232425262728293031└─BookCrawler-v1.0 └─bookcrawler │ │ crawler.sql │ pom.xml │ └─src └─main ├─java │ └─pers │ └─huangyuhui │ └─bookcrawler │ │ BookCrawlerTest.java │ │ │ ├─dao │ │ BookDao.java │ │ │ ├─pojo │ │ Book.java │ │ HttpHeader.java │ │ │ ├─task │ │ BookCrawler.java │ │ │ └─util │ ConfigManager.java │ DBUtils.java │ HttpUtils.java │ └─resources db.properties 程序运行指南 crawler.sql : MySQL数据库文件 1BookCrawler-v1.0/bookcrawler/crawler.sql db.properties : 连接数据库的配置文件 1234jdbc.driver.class=com.mysql.cj.jdbc.Driverjdbc.connection.url=jdbc:mysql://localhost/crawler?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.connection.username=x-x-x-x-x-xjdbc.connection.password=x-x-x-x-x-x BookCrawlerTest.java : 爬虫启动程序 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.bookcrawler;import pers.huangyuhui.bookcrawler.pojo.HttpHeader;import pers.huangyuhui.bookcrawler.task.BookCrawler;/** * @project: BookCrawler * @description: 京东商城书籍爬虫v1.0-测试程序 * @author: 黄宇辉 * @date: 7/13/2019-5:57 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BookCrawlerTest &#123; //自定义搜索关键字 private static String KEY_WORD = \"Java\"; //自定义页码数,每页可爬取三十条书籍数据 private static int currentPageNum = 1; private static int endPageNum = 10; //自定义存储书籍图片的目录路径 private static final String IMAGE_PATH = \"D:\\\\BookCrawler\\\\download\\\\bookImage\\\\\"; //初始化书籍页面链接 private static final String URL = \"https://search.jd.com/Search?keyword=\" + KEY_WORD + \"&amp;enc=utf-8&amp;page=\"; //自定义请求头信息 private static HttpHeader httpHeader = new HttpHeader(); //Test public static void main(String[] args) &#123; httpHeader.setUserAgent(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36\");//需指定用户代理哟 new BookCrawler().parse(URL, IMAGE_PATH, httpHeader, currentPageNum, endPageNum); &#125;&#125; 运行程序BookCrawlerTest.java,下载的图书图片如下图所示 : 数据库中存储的数据如下图所示 : 控制台输出的日志信息如下 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221[message]------&gt;Begin to crawling this page : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=1]\\\\\\\\\\\\\\\\\\\\第 [1] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12602672&apos;, name=&apos;Java从入门到项目实战（全程视频版）&apos;, price=87.8, author=&apos;李兴华 著&apos;, publishing=&apos;中国水利水电出版社&apos;, pubDate=&apos;出版时间：2019-06-01&apos;, imageName=&apos;fdbbf41f-f01f-42ff-a643-4510a6f4c7c3.jpg&apos;, bookUrl=&apos;https://item.jd.com/12602672.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/37162/11/8870/130954/5ccfe770E9ce31151/74a5a5dcd83ecc09.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [2] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12555860&apos;, name=&apos;Java从入门到精通（第5版）&apos;, price=61.4, author=&apos;明日科技 著，javascript:void（0）; 注&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2019-02-01&apos;, imageName=&apos;41a6c90b-a216-4927-9e3e-86fd0f61b0b1.jpg&apos;, bookUrl=&apos;https://item.jd.com/12555860.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/26339/8/10661/124305/5c8af829E4470835f/99742c91174d3d7a.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [3] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10058164&apos;, name=&apos;Java编程思想（第4版） [thinking in java]&apos;, price=71.3, author=&apos;[美] Bruce Eckel 著，陈昊鹏 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2007-06-01&apos;, imageName=&apos;b492c81a-2c88-4941-bc16-3949ecdd75a4.jpg&apos;, bookUrl=&apos;https://item.jd.com/10058164.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t2191/111/699154754/198998/32d7bfe0/5624b582Nbc01af5b.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [4] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12037418&apos;, name=&apos;Java核心技术 卷I：基础知识（原书第10版）&apos;, price=95.2, author=&apos;[美] 凯 S.霍斯特曼（Cay S.Horstmann） 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;9617963d-b39b-4599-9089-7ffa845c842d.jpg&apos;, bookUrl=&apos;https://item.jd.com/12037418.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t3214/126/2309313357/292133/6c038027/57e09a03Nc57334e1.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [5] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12507084&apos;, name=&apos;Effective Java中文版（原书第3版）&apos;, price=94.0, author=&apos;约书亚·布洛克（Joshua Bloch） 著，俞黎敏 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2019-01-01&apos;, imageName=&apos;8532dc5b-e0f0-4a71-918a-36e59383dd96.jpg&apos;, bookUrl=&apos;https://item.jd.com/12507084.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/28526/24/4598/165510/5c3433c7Ea1da5694/eb0bb43a326e8709.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [6] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11252778&apos;, name=&apos;深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）&apos;, price=52.1, author=&apos;周志明 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2013-05-01&apos;, imageName=&apos;1d7bb79e-9d6a-46b6-a61b-0569422aacf3.jpg&apos;, bookUrl=&apos;https://item.jd.com/11252778.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t6130/167/771989293/235186/608d0264/592bf167Naf49f7f6.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [7] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12163151&apos;, name=&apos;JavaWeb项目开发实战入门（全彩版）&apos;, price=49.4, author=&apos;明日科技（MingRi Soft） 著，明日科技 编&apos;, publishing=&apos;吉林大学出版社&apos;, pubDate=&apos;出版时间：2017-04-01&apos;, imageName=&apos;9920e677-10e8-47be-8c1c-2ddcbcb2730b.jpg&apos;, bookUrl=&apos;https://item.jd.com/12163151.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/37054/1/12327/313637/5d036a5fE35f26e20/f365f2357456269f.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [8] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12185501&apos;, name=&apos;零基础学Java（全彩版）&apos;, price=49.4, author=&apos;明日科技（MingRi Soft） 著，明日科技 编&apos;, publishing=&apos;吉林大学出版社&apos;, pubDate=&apos;出版时间：2017-09-01&apos;, imageName=&apos;0f308d89-e600-493e-a0fa-03e07860293c.jpg&apos;, bookUrl=&apos;https://item.jd.com/12185501.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/57972/5/2455/276693/5d036b6cEbb183907/b8c1845431ba6753.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [9] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12284606&apos;, name=&apos;阿里巴巴Java开发手册&apos;, price=33.3, author=&apos;杨冠宝 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-01-01&apos;, imageName=&apos;3c6099c0-4ade-4122-abdd-a0dc7f8dcdd4.png&apos;, bookUrl=&apos;https://item.jd.com/12284606.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t15166/324/2041049880/267178/69de6aaa/5a693fa1Nf13ae221.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [10] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12518025&apos;, name=&apos;疯狂Java讲义（第5版）（含DVD光盘一张）&apos;, price=132.1, author=&apos;李刚 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2019-04-01&apos;, imageName=&apos;86e78e7e-8fa1-4d88-95e4-15074a4498fd.jpg&apos;, bookUrl=&apos;https://item.jd.com/12518025.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/41570/5/1180/179278/5cc54479E7522cee3/d5b50e571ccc926e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [11] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10100190&apos;, name=&apos;O&apos;Reilly：Head First Java（中文版 第2版 涵盖Java5.0）&apos;, price=54.3, author=&apos;[美] 塞若（Sierra K.），[美] 贝茨（Bates B.） 著，O&apos;Reilly Taiwan公司 译&apos;, publishing=&apos;中国电力出版社&apos;, pubDate=&apos;出版时间：2007-02-01&apos;, imageName=&apos;17a129cb-1bde-4bec-b7c1-500ba689b447.jpg&apos;, bookUrl=&apos;https://item.jd.com/10100190.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t2680/274/3707696254/120035/6281369a/57986bbdN27e0e4fe.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [12] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11886254&apos;, name=&apos;数据结构与算法分析：Java语言描述（原书第3版）&apos;, price=54.5, author=&apos;[美] 马克·艾伦·维斯 著，陈越 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2016-03-01&apos;, imageName=&apos;3f3c402b-cd3b-4213-8e87-630d3e511069.jpg&apos;, bookUrl=&apos;https://item.jd.com/11886254.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1897/55/2837612294/467469/83cd5b6/56f25c46Nc3b3c506.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [13] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12163091&apos;, name=&apos;Java项目开发实战入门（全彩版）&apos;, price=36.5, author=&apos;明日科技（MingRi Soft） 著&apos;, publishing=&apos;吉林大学出版社&apos;, pubDate=&apos;出版时间：2017-03-01&apos;, imageName=&apos;944f9dc8-c987-4c15-a866-5519f299ae97.jpg&apos;, bookUrl=&apos;https://item.jd.com/12163091.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/78351/5/3554/283954/5d1c4d52E697fb1ee/53f88bb9ebbca1af.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [14] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12198563&apos;, name=&apos;Java核心技术卷II：高级特性（原书第10版）&apos;, price=111.2, author=&apos;[美] 凯 S. 霍斯特曼（Cay S. Horstmann） 著，陈昊鹏 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2017-09-01&apos;, imageName=&apos;4280a987-84d7-421a-97b0-b3274b3a406b.jpg&apos;, bookUrl=&apos;https://item.jd.com/12198563.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t8485/264/2434696739/100200/71e2437/59ccb6efN0d20c052.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [15] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12185937&apos;, name=&apos;Java精彩编程200例（全彩版）&apos;, price=56.4, author=&apos;明日科技（MingRi Soft） 著，明日科技 编&apos;, publishing=&apos;吉林大学出版社&apos;, pubDate=&apos;出版时间：2017-09-01&apos;, imageName=&apos;90314ef8-fc59-450d-9aa1-092f91dd2143.jpg&apos;, bookUrl=&apos;https://item.jd.com/12185937.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/59101/8/2360/278076/5d03691aE30d418cf/ccc877ab66ae0b5e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [16] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12445838&apos;, name=&apos;码出高效：Java开发手册&apos;, price=94.1, author=&apos;杨冠宝，高海慧 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;7d99ffa3-0ccf-45af-b0dc-290657fc585a.jpg&apos;, bookUrl=&apos;https://item.jd.com/12445838.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t30436/35/1494683199/69182/11fe5fb2/5ce20930N6d70a9f6.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [17] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12122571&apos;, name=&apos;Java EE互联网轻量级框架整合开发 SSM框架（Spring MVC+Spring+MyBatis）和Redis实现&apos;, price=94.0, author=&apos;杨开振，周吉文，梁华辉，谭茂华 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2017-07-01&apos;, imageName=&apos;95e4d659-c74b-49e4-a07b-8269994ea6d4.jpg&apos;, bookUrl=&apos;https://item.jd.com/12122571.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/19862/32/5482/345418/5c3fea85E5d15cbf3/95a87b49209f8f7e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [18] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11917790&apos;, name=&apos;Java 8实战&apos;, price=62.4, author=&apos;[英] 厄马（Raoul-Gabriel Urma）[意] 著，陆明刚，劳佳 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2016-04-01&apos;, imageName=&apos;234259be-2795-466f-9d46-722d863a39b7.jpg&apos;, bookUrl=&apos;https://item.jd.com/11917790.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t2395/169/2883784014/95060/83d0b6ec/571e49e0N5a93c2ee.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [19] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12368970&apos;, name=&apos;Java高并发编程详解：多线程与架构设计&apos;, price=70.3, author=&apos;汪文君 著 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-05-01&apos;, imageName=&apos;fcd1f036-06cd-44d7-b8c8-a5490f3bd536.jpg&apos;, bookUrl=&apos;https://item.jd.com/12368970.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t21481/161/1127754267/285318/7de60cc1/5b207165Nbd3f492d.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [20] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11740734&apos;, name=&apos;Java并发编程的艺术&apos;, price=56.1, author=&apos;方腾飞，魏鹏，程晓明 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2015-07-01&apos;, imageName=&apos;fc23ab01-2df0-4e67-9bce-590ef47cfddd.jpg&apos;, bookUrl=&apos;https://item.jd.com/11740734.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1312/364/1104231705/156699/523dc84c/55b87a5eN09430825.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [21] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11894632&apos;, name=&apos;JavaEE开发的颠覆者：Spring Boot实战&apos;, price=84.6, author=&apos;汪云飞 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2016-03-01&apos;, imageName=&apos;8a7de13b-d300-4971-abb5-98d6bb690b55.jpg&apos;, bookUrl=&apos;https://item.jd.com/11894632.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t2107/53/2057024910/287539/276b11f9/56ef4a73Na00d39cb.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [22] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10922250&apos;, name=&apos;华章专业开发者丛书·Java并发编程实战&apos;, price=54.5, author=&apos;[美] Brian Goetz 等 著，童云兰 等 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2012-02-01&apos;, imageName=&apos;839f0d9e-7454-4c86-8b92-640ec74667b7.jpg&apos;, bookUrl=&apos;https://item.jd.com/10922250.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/12706/18f0ebc9-287b-40a5-86f7-57b2b39c7ec8.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [23] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12408117&apos;, name=&apos;Java核心技术第10版 卷I+卷II 套装共2册&apos;, price=203.8, author=&apos;Cay，S.Horstmann 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-08-01&apos;, imageName=&apos;399c00a7-c979-4461-80dc-c4352483032f.jpg&apos;, bookUrl=&apos;https://item.jd.com/12408117.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t25795/255/981510338/254829/dadb19ce/5b84b3efN3a83e381.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [24] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10100236&apos;, name=&apos;O&apos;Reilly：Head First设计模式（中文版）&apos;, price=67.4, author=&apos;[美] 弗里曼（Freeman E.） 等 著，UML China 编，OReilly Taiwan公司 译&apos;, publishing=&apos;中国电力出版社&apos;, pubDate=&apos;出版时间：2007-09-01&apos;, imageName=&apos;0e7e4526-10d0-4132-aa40-93674a3bf41b.jpg&apos;, bookUrl=&apos;https://item.jd.com/10100236.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t2161/296/1756302188/97371/5fcfff8a/566f88e4Nd320f07b.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [25] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;41559736446&apos;, name=&apos;Java解惑 （美）布洛赫&apos;, price=200.0, author=&apos;&apos;, publishing=&apos;宏田墨农图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;7b0afdca-7b56-4877-b732-ce7cb86db948.jpg&apos;, bookUrl=&apos;https://item.jd.com/41559736446.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/30722/19/6314/103860/5c8caf42E9e893400/8d73a86874877cc6.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [26] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10949745384&apos;, name=&apos;Java从入门到精通（第5版）（软件开发视频大讲堂）&apos;, price=29.9, author=&apos;明日科技 著&apos;, publishing=&apos;墨马图书旗舰店&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;4cf16c8b-bb7d-46a2-b8d5-1d9196d89053.jpg&apos;, bookUrl=&apos;https://item.jd.com/10949745384.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/60094/30/4064/161405/5d23f5a5Ef44d1a93/aefb557792d90dce.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [27] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;22690417364&apos;, name=&apos;Java核心技术卷I基础知识+卷II高级特性（原书第10版） 华章图书 Java核心技术系&apos;, price=150.0, author=&apos;[美] 凯S.霍斯特曼(CayS.Horstmann 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;8556cbc0-fa2f-4618-be05-61070dc7ca6a.png&apos;, bookUrl=&apos;https://item.jd.com/22690417364.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/60410/21/4265/424620/5d26de24Eceb5bf01/883ea73c36bea683.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [28] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11899370&apos;, name=&apos;Spring实战（第4版）&apos;, price=78.3, author=&apos;[美] Craig Walls 沃尔斯 著，张卫滨 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2016-04-01&apos;, imageName=&apos;504ca7f0-af2d-4747-97b6-87aa91c5d8db.jpg&apos;, bookUrl=&apos;https://item.jd.com/11899370.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t17503/334/529692453/390518/89ee87cb/5a93c36fNa6a46a43.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [29] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11098789&apos;, name=&apos;算法(第4版) [Algorithms Fourth Edition]&apos;, price=78.2, author=&apos;[美] Robert Sedgewick，[美] Kevin Wayne 著，谢路云 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2012-10-01&apos;, imageName=&apos;3f9b32ae-6c53-4edf-8cd1-9338959e5636.jpg&apos;, bookUrl=&apos;https://item.jd.com/11098789.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t5779/357/2012363015/875007/26c3ba31/592bf163N035f1d2c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [30] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12450812&apos;, name=&apos;Java并发编程之美&apos;, price=84.6, author=&apos;翟陆续，薛宾田 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;66b237d1-5320-492d-9727-6e42f43a8556.jpg&apos;, bookUrl=&apos;https://item.jd.com/12450812.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/1167/30/9347/118575/5baca2b1E5b8d2803/56dc8b9690fdebe8.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[message]------&gt;This page has had crawled completly : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=][message]------&gt;Begin to crawling this page : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=3]\\\\\\\\\\\\\\\\\\\\第 [31] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;24677303843&apos;, name=&apos;疯狂JAVA讲义(第四版)&apos;, price=78.5, author=&apos;李刚编著 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2018-01-01&apos;, imageName=&apos;f04b7b6b-25d3-474c-847b-8f5350c0a59e.jpg&apos;, bookUrl=&apos;https://item.jd.com/24677303843.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t28873/55/150261715/135795/7876803c/5be96452N71c20286.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [32] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;13645330933&apos;, name=&apos;Java核心技术卷II+Java核心技术卷1 全2册 原书第10版 java入门书&apos;, price=149.0, author=&apos;&apos;, publishing=&apos;墨马图书旗舰店&apos;, pubDate=&apos;&apos;, imageName=&apos;aa0fc695-7e2b-4ea5-b734-0fefd30f39a4.jpg&apos;, bookUrl=&apos;https://item.jd.com/13645330933.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/48548/24/4820/162629/5d26d982E08830568/e8f17b52a54361cd.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [33] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11355978&apos;, name=&apos;深入浅出Node.js&apos;, price=54.5, author=&apos;朴灵 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2013-12-01&apos;, imageName=&apos;64a61278-3781-4dec-95ae-2fe59d83654a.jpg&apos;, bookUrl=&apos;https://item.jd.com/11355978.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t6094/107/710811867/382815/4d54717/592bf165N755a88f0.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [34] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12049209&apos;, name=&apos;Android Studio应用开发实战详解&apos;, price=60.7, author=&apos;王翠萍 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-02-01&apos;, imageName=&apos;44284270-dda4-404c-aa84-4a79de0beddb.jpg&apos;, bookUrl=&apos;https://item.jd.com/12049209.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t4276/327/752840334/98356/931475ce/58b8f02dN377e2520.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [35] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12468732&apos;, name=&apos;Python从小白到大牛&apos;, price=78.3, author=&apos;关东升 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2018-11-01&apos;, imageName=&apos;07623d02-a025-40ab-9f08-7178cc51f1f1.jpg&apos;, bookUrl=&apos;https://item.jd.com/12468732.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/9499/9/2448/149643/5bd2be73E10148fe2/1922b5362c3bdea5.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [36] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12317007&apos;, name=&apos;Java设计模式（高等学校设计模式课程系列教材）&apos;, price=66.7, author=&apos;刘伟 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2018-03-01&apos;, imageName=&apos;11367a22-ea04-4617-8362-0803db9449b1.jpg&apos;, bookUrl=&apos;https://item.jd.com/12317007.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t18859/254/886040010/131423/b04938e9/5ab0be7aN8f05c0de.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [37] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;50669504780&apos;, name=&apos;Spring Boot+Vue全栈开发实战 独立实现大型SPA应用书籍 基础语言Java编程思想开发&apos;, price=48.9, author=&apos;&apos;, publishing=&apos;兴阅图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;f26e36d9-9497-49f7-bc72-c3098d9be58c.jpg&apos;, bookUrl=&apos;https://item.jd.com/50669504780.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/55264/14/3054/31805/5d0d8696E6f200a00/01cdd32b88b79f97.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [38] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;19297335&apos;, name=&apos;Thinking in Java Java编程思想 英文原版 [平装]&apos;, price=889.7, author=&apos;Bruce Eckel 著&apos;, publishing=&apos;Prentice Hall PTR&apos;, pubDate=&apos;出版时间：2006-02-20&apos;, imageName=&apos;f5be1014-17da-4b31-ab59-17abc76006ce.jpg&apos;, bookUrl=&apos;https://item.jd.com/19297335.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/g13/M03/10/0E/rBEhUlJbdQ4IAAAAAACM-xSPcewAAEGyAGhnvcAAI0T924.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [39] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;1027811599&apos;, name=&apos;Java编程思想 华章图书 计算机科学丛书&apos;, price=69.8, author=&apos;[美] 埃克尔（BruceEckel）著陈吴鹏译 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2007-06-01&apos;, imageName=&apos;d4e066e6-c4dc-4f52-b60a-f96f5e91947b.jpg&apos;, bookUrl=&apos;https://item.jd.com/1027811599.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/30902/10/15584/84432/5cc28991E8b0697aa/4a7d9ef337fd3eae.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [40] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12621746&apos;, name=&apos;Spring响应式微服务：Spring Boot 2+Spring 5+Spring Cloud实战&apos;, price=71.3, author=&apos;郑天民 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2019-06-01&apos;, imageName=&apos;178eb889-0b26-419d-889d-7cc4bb3d1e4a.jpg&apos;, bookUrl=&apos;https://item.jd.com/12621746.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/49732/1/1266/87243/5cf091baE59493bdf/a489bfc9b8563c59.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [41] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12395281&apos;, name=&apos;NIO与Socket编程技术指南&apos;, price=68.3, author=&apos;高洪岩 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-07-01&apos;, imageName=&apos;88e0e242-2ebd-42b0-89c3-7058c4239c13.jpg&apos;, bookUrl=&apos;https://item.jd.com/12395281.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t22930/190/1223174459/96931/f0575eb0/5b56b9f2N4b4c8d13.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [42] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12610902&apos;, name=&apos;Java多线程编程核心技术（第2版）&apos;, price=68.3, author=&apos;高洪岩 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2019-05-01&apos;, imageName=&apos;0ef7d3a3-9bfb-45d6-8920-ae4c77497123.jpg&apos;, bookUrl=&apos;https://item.jd.com/12610902.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t29287/121/1505506965/99325/e56b418c/5ce25434N2dbc1b6c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [43] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;47862504172&apos;, name=&apos;java从入门到精通 上下册 Java编程入门指南 java编辑基础知识书籍 零基础自学JAVA语言&apos;, price=56.0, author=&apos;明日科技 著&apos;, publishing=&apos;华研外语官方旗舰店&apos;, pubDate=&apos;&apos;, imageName=&apos;8f08f39a-6a30-4b60-b9ad-01e72925b5cc.png&apos;, bookUrl=&apos;https://item.jd.com/47862504172.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t10606/352/2945418656/423794/29037053/5cdd227dN01cf7974.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [44] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12403128&apos;, name=&apos;深入浅出Spring Boot 2.x&apos;, price=87.1, author=&apos;杨开振 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-08-01&apos;, imageName=&apos;48af1f52-6935-4a07-956b-eb7fa9dfa41f.jpg&apos;, bookUrl=&apos;https://item.jd.com/12403128.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t22465/12/900897894/181167/6cdc011/5b46ddd0N0e99663d.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [45] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10603153&apos;, name=&apos;JavaScript DOM编程艺术（第2版）&apos;, price=38.7, author=&apos;[英] Jeremy Keith，[加] Jeffrey Sambells 著，杨涛 等 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2011-04-01&apos;, imageName=&apos;2282ee16-5405-460f-a0c7-e1930d164667.jpg&apos;, bookUrl=&apos;https://item.jd.com/10603153.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t5914/15/800105189/215959/973eea1f/592bf164N56d3e3db.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [46] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12435255&apos;, name=&apos;分布式消息中间件实践&apos;, price=75.1, author=&apos;倪炜 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-09-01&apos;, imageName=&apos;84a5d340-98c3-468a-b2a5-086f9d68fc0a.jpg&apos;, bookUrl=&apos;https://item.jd.com/12435255.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/3450/19/9470/129555/5bac94d8E5620b17e/3a763b77711aab34.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [47] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10100583&apos;, name=&apos;怎样看110kV变电站典型二次回路图&apos;, price=14.0, author=&apos;郑新才，蒋剑 著&apos;, publishing=&apos;中国电力出版社&apos;, pubDate=&apos;出版时间：2009-10-01&apos;, imageName=&apos;a1a44a01-403b-41c2-bf6d-e3c8c5c15738.jpg&apos;, bookUrl=&apos;https://item.jd.com/10100583.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/19007/99f9dfce-38c8-47c3-b433-eb71edc9d734.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [48] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11449803&apos;, name=&apos;大型网站系统与Java中间件实践&apos;, price=61.8, author=&apos;曾宪杰 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2014-04-01&apos;, imageName=&apos;3cc05539-3c8b-4d77-9964-0d327304ef5d.jpg&apos;, bookUrl=&apos;https://item.jd.com/11449803.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/g14/M01/00/1D/rBEhV1Ne_5MIAAAAAAkNeMWAC5AAAMwOQL4rRIACQ2Q252.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [49] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;1027469792&apos;, name=&apos;Java并发编程实战&apos;, price=43.8, author=&apos;[美] 盖茨 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2012-02-01&apos;, imageName=&apos;e1fb5b4d-8268-418b-a343-82b3383a3988.jpg&apos;, bookUrl=&apos;https://item.jd.com/1027469792.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/5652/18/13839/60104/5bd93c37E3f0bfd91/87d0b3a61434181a.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [50] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12422624&apos;, name=&apos;Java基础入门&apos;, price=46.1, author=&apos;传智播客高教产品研发部 编&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2014-05-01&apos;, imageName=&apos;235c88aa-e380-49ee-8f8e-5d6952c657ae.jpg&apos;, bookUrl=&apos;https://item.jd.com/12422624.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t24940/109/1082655257/165480/27583a80/5b88fee7Ne45d1091.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [51] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12102001&apos;, name=&apos;Java Web从入门到精通（第2版）（配光盘）（软件开发视频大讲堂）&apos;, price=76.6, author=&apos;明日科技 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2017-06-01&apos;, imageName=&apos;ebb5f9e7-2808-4aae-8880-81dd397b685a.jpg&apos;, bookUrl=&apos;https://item.jd.com/12102001.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t5818/97/3776926155/98696/3b9619b4/59422c29N69528a65.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [52] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11676671&apos;, name=&apos;图灵程序设计丛书：你不知道的JavaScript（上卷） [You Don&apos;t Know JS:Scope &amp; Closures]&apos;, price=38.7, author=&apos;[美] 辛普森（Kyle Simpson） 著，赵望野，梁杰 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2015-04-01&apos;, imageName=&apos;b97a4325-68fd-47ef-981c-30cf303066b2.jpg&apos;, bookUrl=&apos;https://item.jd.com/11676671.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t6109/168/755288832/337238/a9c402b3/592bf16bN060edd40.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [53] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12458866&apos;, name=&apos;实战Java高并发程序设计（第2版）&apos;, price=84.6, author=&apos;葛一鸣 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;0c867b6c-c8f6-434e-890e-4cdb5f3a53dd.jpg&apos;, bookUrl=&apos;https://item.jd.com/12458866.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/9457/10/1147/146908/5bcd3149Ee45f979e/e5b85ad450838567.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [54] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12388762&apos;, name=&apos;Java语言程序设计与数据结构（基础篇）（原书第11版）&apos;, price=75.9, author=&apos;[美] 梁勇（Y. Daniel Liang） 著，戴开宇 复旦大学译 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;279f89fc-d32b-4f6f-a8bc-a718d1987e23.jpg&apos;, bookUrl=&apos;https://item.jd.com/12388762.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t22684/234/484637682/160167/5f280528/5b30be5cN7db0b1de.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [55] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;41536196488&apos;, name=&apos;EFFECTIVE JAVA 3 中文版原书第三版&apos;, price=71.9, author=&apos;[美] 约书亚·布洛克（JoshuaBloch） 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2019-01-01&apos;, imageName=&apos;a97f569d-7945-4394-a1ad-8841bef82e33.png&apos;, bookUrl=&apos;https://item.jd.com/41536196488.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/40336/22/2855/347935/5cc2899aE1e0b25b1/c3f196fa8e0312fe.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [56] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12534456&apos;, name=&apos;互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析&apos;, price=103.6, author=&apos;李艳鹏 等 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2019-03-01&apos;, imageName=&apos;2403d1a6-7f64-43f4-8155-2dd0f1d2d7a2.jpg&apos;, bookUrl=&apos;https://item.jd.com/12534456.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/16122/35/5881/158653/5c45966dE8b5c73ac/cb7b872dd995912e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [57] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12587702&apos;, name=&apos;Java核心技术 卷I 基础知识 第11版 英文版 上下册&apos;, price=131.1, author=&apos;[美] 凯·S.，霍斯特曼（Cay，S.，Horstmann） 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-05-01&apos;, imageName=&apos;3737dbb3-7f40-4c6c-8012-ad863cd9374d.jpg&apos;, bookUrl=&apos;https://item.jd.com/12587702.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/36138/24/1739/106284/5cb4114eEe575e257/9657767086f2e8fe.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [58] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12456376&apos;, name=&apos;正则指引（第2版）&apos;, price=84.6, author=&apos;余晟 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;cb035e08-421e-4cc9-a02c-5a435f6e4722.jpg&apos;, bookUrl=&apos;https://item.jd.com/12456376.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t27076/274/874525002/185922/be0e6dd2/5bbc4b37N07cffc59.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [59] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;43069250577&apos;, name=&apos;正版6本SSH框架企业级应用+SSM轻量级框架应用+JavaWeb应用设计及实战+MySQL数据库应&apos;, price=201.45, author=&apos;肖睿 郭泰 王丁磊 著&apos;, publishing=&apos;品阅轩图书专营店&apos;, pubDate=&apos;出版时间：2018-01-01&apos;, imageName=&apos;21858fcc-b612-43e5-9958-f7ee7a53954c.png&apos;, bookUrl=&apos;https://item.jd.com/43069250577.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/17642/6/12903/431603/5c9b4783E2c506db8/76b9707fa7879cb8.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [60] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12114302&apos;, name=&apos;Java基础案例教程&apos;, price=39.4, author=&apos;黑马程序员 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-01-01&apos;, imageName=&apos;a2be7356-6e6c-43b0-bdfd-13410558affa.jpg&apos;, bookUrl=&apos;https://item.jd.com/12114302.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t24253/234/2303901363/171875/d03546c2/5b7bc8d5N8ca2ba51.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[message]------&gt;This page has had crawled completly : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=][message]------&gt;Begin to crawling this page : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=5]\\\\\\\\\\\\\\\\\\\\第 [61] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;22690417364&apos;, name=&apos;Java核心技术卷I基础知识+卷II高级特性（原书第10版） 华章图书 Java核心技术系&apos;, price=150.0, author=&apos;[美] 凯S.霍斯特曼(CayS.Horstmann 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;95e9b54e-93c3-4e40-8d2c-ad991829daed.png&apos;, bookUrl=&apos;https://item.jd.com/22690417364.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/60410/21/4265/424620/5d26de24Eceb5bf01/883ea73c36bea683.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [62] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12403477&apos;, name=&apos;Java开发详解（全彩版）&apos;, price=86.3, author=&apos;明日科技（MingRi Soft） 著，明日科技 编&apos;, publishing=&apos;吉林大学出版社&apos;, pubDate=&apos;出版时间：2018-07-01&apos;, imageName=&apos;0ce5dbcb-7750-407e-a685-21b9b9d497f5.jpg&apos;, bookUrl=&apos;https://item.jd.com/12403477.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/44303/14/1165/281427/5cc53c63Eb79cabfb/a2a8c2f082c16238.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [63] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12019365&apos;, name=&apos;图解设计模式&apos;, price=62.4, author=&apos;[日] 结城浩 著，杨文轩 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2016-12-01&apos;, imageName=&apos;168fdcb7-0f62-48c9-99bd-a8a0cb91623b.jpg&apos;, bookUrl=&apos;https://item.jd.com/12019365.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t3244/19/4701748027/371568/973000db/585358ebN2d6b6a66.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [64] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12113317&apos;, name=&apos;Three.js开发指南：WebGL的JavaScript 3D库（原书第2版）&apos;, price=51.2, author=&apos;[美] 乔斯·德克森（Jos Dirksen） 著，杨芬 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2017-06-01&apos;, imageName=&apos;af99e3de-4081-42ac-9059-40984ca27234.jpg&apos;, bookUrl=&apos;https://item.jd.com/12113317.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t6358/7/1544342065/111169/e51a6cb0/59536a88N6cdfbad6.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [65] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11890435&apos;, name=&apos;Java和Android开发学习指南 第2版&apos;, price=60.7, author=&apos;[加] 克尼亚万（Budi Kurniawan） 著，李强 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2016-03-01&apos;, imageName=&apos;2b9dd61c-21c3-4429-b27d-7ac98d77ba53.jpg&apos;, bookUrl=&apos;https://item.jd.com/11890435.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t2320/312/2599966871/158930/ba4d65c2/56e6e180Nb900ed78.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [66] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12224904&apos;, name=&apos;Kotlin实战&apos;, price=84.6, author=&apos;[美] Dmitry Jemerov（德米特里·詹莫瑞福），[美] Svetlana Isakova（斯维特拉娜·伊凡诺沃） 著，覃宇，罗丽，李思阳，蒋扬海 译&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2017-08-01&apos;, imageName=&apos;453bd598-1069-437c-a11e-4552191ae8a2.jpg&apos;, bookUrl=&apos;https://item.jd.com/12224904.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t6061/329/6214493869/204427/b10fb30a/59715eb7N3e27da7c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [67] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;45822504367&apos;, name=&apos;Java语言的科学与艺术(国外计算机科学经典教材)9787302184416(美)罗伯茨,&apos;, price=198.0, author=&apos;美罗伯茨，付勇 著&apos;, publishing=&apos;正瀚图书专营店&apos;, pubDate=&apos;出版时间：2009-01-01&apos;, imageName=&apos;a9c28b69-bf07-430a-9e87-fd5850293919.jpg&apos;, bookUrl=&apos;https://item.jd.com/45822504367.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/32613/36/13257/20975/5cb9ce81Eea6a06b9/4551fc7c020d0440.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [68] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12380383&apos;, name=&apos;疯狂Android讲义（Kotlin版）&apos;, price=102.6, author=&apos;李刚 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;40bf6728-96ab-48a4-a672-e808a6ee7ad9.jpg&apos;, bookUrl=&apos;https://item.jd.com/12380383.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t24124/92/502105589/496222/fcfb82ec/5b31ec57N2511feed.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [69] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12165317&apos;, name=&apos;图解Java多线程设计模式&apos;, price=70.3, author=&apos;结城浩 著，侯振龙，杨文轩 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-08-01&apos;, imageName=&apos;a403a845-c612-4dee-87f7-15bf91cf17ad.jpg&apos;, bookUrl=&apos;https://item.jd.com/12165317.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t5797/85/9205318505/62242/28fec040/599a668aN07d69866.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [70] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;41567918434&apos;, name=&apos;EFFECTIVE JAVA中文版(第3版)+深入理解JAVA虚拟机&apos;, price=143.7, author=&apos;[美] 约书亚·布洛克（JoshuaBloch） 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2018-12-01&apos;, imageName=&apos;beff6a1e-5707-4c54-9d77-12708eba83bd.png&apos;, bookUrl=&apos;https://item.jd.com/41567918434.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/20454/25/6745/402129/5c63df9eE5bc92a32/4a00f2502c9fd4e4.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [71] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12261787&apos;, name=&apos;疯狂Java讲义（第4版）&apos;, price=103.6, author=&apos;李刚 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-01-01&apos;, imageName=&apos;09aab716-cd94-4d0f-942f-ca0697801225.jpg&apos;, bookUrl=&apos;https://item.jd.com/12261787.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/332/12/6080/110939/5ba09fa6Eee7d7f85/4522ae0a5c8c5215.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [72] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11402560819&apos;, name=&apos;【包邮】码出高效 Java开发手册+阿里巴巴Java开发手册 java语言编程教程书籍&apos;, price=88.0, author=&apos;&apos;, publishing=&apos;蓝墨水图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;21befded-3c1c-439e-be38-16664fc7e7c1.jpg&apos;, bookUrl=&apos;https://item.jd.com/11402560819.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t22930/102/2058568140/110279/a6953560/5b723c2dN20cc6d14.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [73] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;45585909326&apos;, name=&apos;分布式Java应用：基础与实践9787121109416林昊,电子工业出版社&apos;, price=159.0, author=&apos;林昊 著&apos;, publishing=&apos;正瀚图书专营店&apos;, pubDate=&apos;出版时间：2010-06-01&apos;, imageName=&apos;8ec5584c-ed9d-49a1-a100-64cd122cd31f.jpg&apos;, bookUrl=&apos;https://item.jd.com/45585909326.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/32843/9/11797/24414/5cb5e4a5E7be8a7e6/9aa05b5495e6b72c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [74] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10108619304&apos;, name=&apos;现货包邮 高教2019年版全国计算机等级考试二级教程 Java语言程序设计+公共基础知识 计算机等&apos;, price=49.6, author=&apos;&apos;, publishing=&apos;兰兴达图书专营店&apos;, pubDate=&apos;出版时间：2018-11-01&apos;, imageName=&apos;e06ad99e-756d-4379-9cd2-92f6d2ac5086.png&apos;, bookUrl=&apos;https://item.jd.com/10108619304.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t29137/200/736353919/425760/5b1c7204/5bfcf17cNd5c644a0.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [75] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12408073&apos;, name=&apos;Java程序员面试算法宝典&apos;, price=66.2, author=&apos;猿媛之家 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-08-01&apos;, imageName=&apos;d82ab71a-dc85-4718-84f7-7665628a12cd.jpg&apos;, bookUrl=&apos;https://item.jd.com/12408073.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t24967/54/534149984/139359/aeaddb97/5b729cf9N18087ac4.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [76] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11407830&apos;, name=&apos;Java性能优化权威指南 [Java performance]&apos;, price=86.1, author=&apos;[美] Charlie Hunt，Binu John 著，柳飞，陆明刚 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2014-03-01&apos;, imageName=&apos;69d936a5-a577-43f3-9c6e-a6811aab3d00.jpg&apos;, bookUrl=&apos;https://item.jd.com/11407830.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/g13/M09/15/1E/rBEhUlMEatcIAAAAAAVMw6OwOPYAAIwSwIOpu0ABUzb978.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [77] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12256043&apos;, name=&apos;Java函数式编程&apos;, price=113.1, author=&apos;[法] Pierre-Yves，Saumont（皮埃尔-伊夫斯 索蒙特） 著，高清华 译&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2017-11-01&apos;, imageName=&apos;5d7daffb-00cd-4d0b-811f-6738cf4454b6.jpg&apos;, bookUrl=&apos;https://item.jd.com/12256043.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/15329/10/2381/206427/5c1c56ebE5534c0d2/12d15081720f73e4.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [78] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11703581&apos;, name=&apos;Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]&apos;, price=75.1, author=&apos;[美] 蒂姆·林霍尔姆（Tim，Lindholm），弗兰克·耶林（Frank Yellin），吉拉德·布拉查（Glad Bracha），亚历史斯·巴克利（Alex Buckley） 著，爱飞翔，周志明 等 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2015-06-01&apos;, imageName=&apos;59fe9dd5-d484-4e01-9748-e6a6b880ab53.jpg&apos;, bookUrl=&apos;https://item.jd.com/11703581.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t913/184/1143778297/240173/d94ec3e/55792c94N29049a7a.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [79] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;26651591800&apos;, name=&apos;Java设计模式&apos;, price=50.9, author=&apos;刘伟编著 著&apos;, publishing=&apos;文轩网少儿专营店&apos;, pubDate=&apos;出版时间：2018-03-01&apos;, imageName=&apos;51c84da7-4a3f-4c0b-ae0c-a38ca956ece0.jpg&apos;, bookUrl=&apos;https://item.jd.com/26651591800.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/4552/10/14657/47389/5bdc27ccE29d97349/ed944718c2ab28b1.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [80] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12375485&apos;, name=&apos;Java编程入门官方教程（第7版）&apos;, price=61.4, author=&apos;[美] Herbert Schildt 著，左雷 译&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;bc0d9894-e697-43c6-87f2-66fc73f92436.jpg&apos;, bookUrl=&apos;https://item.jd.com/12375485.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t23575/108/589507071/44408/81d8bdff/5b35a8d7N4a31ba40.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [81] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11099999&apos;, name=&apos;Java程序性能优化：让你的Java程序更快、更稳定&apos;, price=56.6, author=&apos;葛一鸣 等 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2012-09-01&apos;, imageName=&apos;7c491cd2-f023-43d3-aa5f-8ccbe440b735.jpg&apos;, bookUrl=&apos;https://item.jd.com/11099999.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/g15/M09/19/11/rBEhWlKb234IAAAAAAQe--TPULkAAGMcAB9W-wABB8T163.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [82] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12573160&apos;, name=&apos;Java少儿编程&apos;, price=30.8, author=&apos;纳迪娅·阿梅西亚内·加西亚 著，李凡妮，姚均霖 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-03-01&apos;, imageName=&apos;d3bd567c-de8a-40ca-a35f-243a65fdcd56.jpg&apos;, bookUrl=&apos;https://item.jd.com/12573160.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/21048/30/12451/112738/5c9854b6E61bc9360/6fc03b60e6a61bc1.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [83] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;41551365134&apos;, name=&apos;机械工业：官方正版 Java核心技术(卷I)(基础知识)(原书第10版) Java核心&apos;, price=92.82, author=&apos;&apos;, publishing=&apos;新世纪图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;50d4ad5f-016f-4846-88c9-6963fb00c6c1.jpg&apos;, bookUrl=&apos;https://item.jd.com/41551365134.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/24495/4/6686/216823/5c627ea5E9a9b2e95/b1b972119a50c7f2.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [84] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12262844638&apos;, name=&apos;Netty权威指南 第2版 Java高性能NIO通信框架 大数据时代构建高可用分布式系统利&apos;, price=58.0, author=&apos;&apos;, publishing=&apos;润知天下图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;15db5b12-232b-4245-82e8-427081701985.jpg&apos;, bookUrl=&apos;https://item.jd.com/12262844638.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t5227/196/850978448/56451/abb128cb/590826faNe5a89553.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [85] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11550225525&apos;, name=&apos;Java核心技术 卷I：基础知识 原书第10版 华章图书 Java核心技术系列&apos;, price=75.8, author=&apos;[美] 凯S.霍斯特曼(CayS.Horstmann 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;01f8205a-63b1-4e76-ae60-799ec0133cf4.jpg&apos;, bookUrl=&apos;https://item.jd.com/11550225525.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t25831/30/2660146448/54798/20f01ee1/5bea76f9N86690ef9.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [86] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;39003018140&apos;, name=&apos;2019年版全国计算机等级考试二级教程 Java语言程序设计 高等教育部指定计算机二级Java教材&apos;, price=32.9, author=&apos;考试中心 著&apos;, publishing=&apos;布克专营店&apos;, pubDate=&apos;出版时间：2018-11-01&apos;, imageName=&apos;44b93525-c82e-4a80-a634-45f16e43996f.jpg&apos;, bookUrl=&apos;https://item.jd.com/39003018140.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/28943/5/2904/148459/5c21dc35E6968c918/c289064236c8a753.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [87] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12055718&apos;, name=&apos;21天学通Java 第7版&apos;, price=51.9, author=&apos;[美] 罗格斯·卡登海德（Rogers Cadenhead） 著，袁国忠 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2016-10-01&apos;, imageName=&apos;f7064a4d-5a7e-4cab-9170-e3ec04ad12a8.jpg&apos;, bookUrl=&apos;https://item.jd.com/12055718.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t3412/193/424731803/105322/a75a8764/580a41acNa2d1f4eb.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [88] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;41568057233&apos;, name=&apos;Java四大名著java编程思想+Effective java中文版（原书第3版）+Java核心技术&apos;, price=299.0, author=&apos;[美] 埃克尔（BruceEckel）著陈吴鹏译 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2007-06-01&apos;, imageName=&apos;ed79915c-bbb4-4e0e-9f52-7c2abf4e0337.png&apos;, bookUrl=&apos;https://item.jd.com/41568057233.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/53708/15/4673/540404/5d25480dE36392570/45eb35883bc01f7a.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [89] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12448711&apos;, name=&apos;智慧的疆界：从图灵机到人工智能 [The Boundaries of Intelligence from Turing Machine to Artificial Intelligence]&apos;, price=66.2, author=&apos;周志明 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;1a1e9147-57c4-44f1-928b-0d7463a2f51d.jpg&apos;, bookUrl=&apos;https://item.jd.com/12448711.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/8965/4/4114/198788/5bd9a09eE9e49a746/abbed9e17491f9b1.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [90] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12299018&apos;, name=&apos;Java编程的逻辑&apos;, price=94.1, author=&apos;马俊昌 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-01-01&apos;, imageName=&apos;a59dfde8-aeda-4ca4-b926-4412758791f3.jpg&apos;, bookUrl=&apos;https://item.jd.com/12299018.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t14494/344/2041325409/173602/8e9e46f2/5a66eb12N0a7be368.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[message]------&gt;This page has had crawled completly : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=][message]------&gt;Begin to crawling this page : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=7]\\\\\\\\\\\\\\\\\\\\第 [91] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;41708300430&apos;, name=&apos;JAVA WEB项目开发全程实录&apos;, price=60.6, author=&apos;明日科技 著&apos;, publishing=&apos;文轩网教育考试专营店&apos;, pubDate=&apos;出版时间：2018-11-01&apos;, imageName=&apos;705e226b-26eb-4a69-9d2c-2cbec83fe0bb.jpg&apos;, bookUrl=&apos;https://item.jd.com/41708300430.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/18107/31/6867/67500/5c638437E1328cc93/9a01f5af5557116d.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [92] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;44155570213&apos;, name=&apos;【包邮特价】Java核心技术 卷Ⅰ 基础知识（原书第10版）|64398&apos;, price=57.1, author=&apos;美 凯S 霍斯特曼Cay S Hor 著，周立新 译&apos;, publishing=&apos;互动创新图书专营店&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;7e925184-9653-4893-bc71-8849b431e79e.jpg&apos;, bookUrl=&apos;https://item.jd.com/44155570213.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/30658/29/7979/29956/5c9b1cdfEa1b61649/13241193de5b3b35.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [93] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12421187&apos;, name=&apos;Java核心技术及面试指南&apos;, price=45.7, author=&apos;金华，胡书敏，周国华，吴倍敏 著&apos;, publishing=&apos;北京大学出版社&apos;, pubDate=&apos;出版时间：2018-08-01&apos;, imageName=&apos;62eea26f-0558-498a-b522-80eedfce025b.jpg&apos;, bookUrl=&apos;https://item.jd.com/12421187.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t23923/73/2580373102/326345/42f70f99/5b8851b1N940d8fbe.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [94] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12031620&apos;, name=&apos;自己动手写网络爬虫（修订版 配光盘）&apos;, price=33.3, author=&apos;罗刚 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2016-08-01&apos;, imageName=&apos;2455f0ec-e755-455a-9437-88d07ad65616.jpg&apos;, bookUrl=&apos;https://item.jd.com/12031620.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t3121/197/1971715943/328291/4767e03b/57d79b0fNb70e3a7c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [95] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11737504&apos;, name=&apos;图解数据结构：使用Java&apos;, price=33.8, author=&apos;胡昭民 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2015-07-01&apos;, imageName=&apos;17c6340d-cd63-41e5-8cd3-634c745b4ec7.jpg&apos;, bookUrl=&apos;https://item.jd.com/11737504.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1366/26/894983513/125597/ec5981c7/55b09e7bN587ffcd0.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [96] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;44090780230&apos;, name=&apos;c语言从入门到精通+java从入门到精通 零基础电脑编程软件开发入门自学书籍 计算机c++&apos;, price=101.8, author=&apos;&apos;, publishing=&apos;友杰图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;24af83e0-b334-43b8-b65a-d142c9011cfc.jpg&apos;, bookUrl=&apos;https://item.jd.com/44090780230.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/24311/14/12881/471599/5c99d270E3bb044e6/ac74360ac178a4ab.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [97] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;26667242534&apos;, name=&apos;Java核心技术卷II 高级特性 原书第10版 中文版 程序开发书籍&apos;, price=100.1, author=&apos;&apos;, publishing=&apos;华心图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;bcac14aa-e677-48d4-b0cd-7e8ec92af494.jpg&apos;, bookUrl=&apos;https://item.jd.com/26667242534.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t19762/65/1063598371/148796/6dfdad77/5abb550eNa1b11338.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [98] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11763003&apos;, name=&apos;实战Gradle&apos;, price=84.6, author=&apos;[美] Benjamin Muschko（本杰明·马斯可） 著，李建，杨柳，朱本威 译&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2015-09-01&apos;, imageName=&apos;753b7522-f05d-4f77-9082-3a908c0ceb1b.jpg&apos;, bookUrl=&apos;https://item.jd.com/11763003.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1300/107/1072773516/494011/95eff86b/55ec0155Nf66f61fa.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [99] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12458778&apos;, name=&apos;自己动手实现Lua：虚拟机、编译器和标准库&apos;, price=85.4, author=&apos;张秀宏 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;522a62ec-3ef4-408c-b3a7-5181da1bef08.jpg&apos;, bookUrl=&apos;https://item.jd.com/12458778.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t27148/205/1034287519/111480/a295cbbd/5bbef1a5N7186e726.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [100] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12453426&apos;, name=&apos;精通Java并发编程 第2版&apos;, price=70.3, author=&apos;[西] 哈维尔·费尔南德斯·冈萨雷斯 著，唐富年 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;3d5d1f8b-0bc4-40b7-a4b9-5d67987e0f2e.jpg&apos;, bookUrl=&apos;https://item.jd.com/12453426.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t27568/359/470391574/128058/1be8bc10/5baefd93N5266114d.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [101] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12513757&apos;, name=&apos;JVM G1源码分析和调优&apos;, price=84.6, author=&apos;彭成寒 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2019-04-01&apos;, imageName=&apos;16417297-049e-43ad-a05f-5d948230ab8c.jpg&apos;, bookUrl=&apos;https://item.jd.com/12513757.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/22145/5/15100/88532/5cad9a58E3526a54e/44766928ae9ae297.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [102] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;42474709052&apos;, name=&apos;【套装2本】剑指Offer：名企面试官精讲典型编程题（第2版）+Java程序员面试笔试真题库&apos;, price=93.5, author=&apos;何海涛 著&apos;, publishing=&apos;华心图书专营店&apos;, pubDate=&apos;出版时间：2017-05-01&apos;, imageName=&apos;5a5f857d-1829-4a82-9158-62d5bf71c45c.jpg&apos;, bookUrl=&apos;https://item.jd.com/42474709052.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/22055/7/9016/215731/5c7c79faE1362681f/a4b83345935d45bf.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [103] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;36590815887&apos;, name=&apos;Java项目开发实战入门 Java从入门到精通 java语言程序设计java书籍教程java编程思想&apos;, price=38.8, author=&apos;&apos;, publishing=&apos;墨涵图书专营店&apos;, pubDate=&apos;出版时间：2006-08-01&apos;, imageName=&apos;9e3293e4-22b4-4ca6-9205-8ff150286aa2.jpg&apos;, bookUrl=&apos;https://item.jd.com/36590815887.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t26281/43/1578788516/96461/80d4c4fd/5be5f2b5Nd48ea11e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [104] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12465222&apos;, name=&apos;Java语言程序设计与数据结构（进阶篇 原书第11版） [Introduction to Java Programming and Data Structures Comprehensive Version，Eleventh Edition]&apos;, price=82.1, author=&apos;[美] 梁勇（Y.Daniel Liang） 著，戴开宇 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-10-01&apos;, imageName=&apos;e94695f6-5fbb-44d1-9cf0-74dc9b8e0500.jpg&apos;, bookUrl=&apos;https://item.jd.com/12465222.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/2121/6/13474/234872/5bd84120Eb021ec70/60e47b5f9b30c035.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [105] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12555764&apos;, name=&apos;Java编程技术大全（套装上下册）&apos;, price=104.7, author=&apos;魔乐科技（MLDN）软件实训中心 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2019-03-01&apos;, imageName=&apos;6c782009-a1c5-4032-804e-ce29956b9601.jpg&apos;, bookUrl=&apos;https://item.jd.com/12555764.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/18518/38/9268/243891/5c7dd017E5cfb911f/572600bf9a76226c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [106] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12086872&apos;, name=&apos;深度解析Java游戏服务器开发&apos;, price=75.1, author=&apos;何金成 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2017-01-01&apos;, imageName=&apos;0204b1a3-dbf1-458a-b7b9-4639e6953975.jpg&apos;, bookUrl=&apos;https://item.jd.com/12086872.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t3820/334/2296233492/141925/49d793ba/58573983N6fa2f9fd.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [107] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;29984270108&apos;, name=&apos;数据结构与算法分析：Java语言描述 原书第3版&apos;, price=48.3, author=&apos;&apos;, publishing=&apos;芝麻开门图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;e46ed4f3-3a1b-4f34-b4db-9e79780ce584.jpg&apos;, bookUrl=&apos;https://item.jd.com/29984270108.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t23143/300/684699781/92720/e73c27cc/5b3d83e9Nc91e4db6.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [108] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12361134&apos;, name=&apos;Java项目开发全程实录（第4版）&apos;, price=67.0, author=&apos;明日科技 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2018-05-01&apos;, imageName=&apos;a5e6a981-3291-4b7b-878b-e75c10a99063.jpg&apos;, bookUrl=&apos;https://item.jd.com/12361134.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t16984/46/2480234140/146600/2ed350d4/5af947d8N672a939f.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [109] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;43431775867&apos;, name=&apos;Java数据结构和算法 拉佛 9787508356440 中国电力出版社&apos;, price=119.0, author=&apos;&apos;, publishing=&apos;爱德雅图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;dd0aebe4-d7c9-40b2-9366-854c335aed04.jpg&apos;, bookUrl=&apos;https://item.jd.com/43431775867.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/29427/30/15617/108405/5cb16e25E59f4e362/0fc0d48027deb11c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [110] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11670385&apos;, name=&apos;51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化&apos;, price=75.1, author=&apos;葛一鸣 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2015-03-01&apos;, imageName=&apos;3c670922-e711-457c-a6b6-ff3382707068.jpg&apos;, bookUrl=&apos;https://item.jd.com/11670385.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t766/291/1218388189/323388/a16b717e/55264f4aNff32a143.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [111] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12386639&apos;, name=&apos;Java JDK 9学习笔记&apos;, price=67.6, author=&apos;林信良 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;38801c03-2afa-4a2a-a9bc-46e9c1e1e076.jpg&apos;, bookUrl=&apos;https://item.jd.com/12386639.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t22300/323/2247756849/47752/911f1288/5b4ed9a8Nf6ca30a6.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [112] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;43128267529&apos;, name=&apos;Effective Java中文版(原书第3版)&apos;, price=60.0, author=&apos;[美] 约书亚·布洛克（JoshuaBloch） 著&apos;, publishing=&apos;大石桥新华书店图书专营店&apos;, pubDate=&apos;出版时间：2019-01-01&apos;, imageName=&apos;67299383-d283-456a-be64-62e679599141.jpg&apos;, bookUrl=&apos;https://item.jd.com/43128267529.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/35558/4/1965/53785/5cb47d51E8762dc13/56b053cf06c66419.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [113] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11800589&apos;, name=&apos;实战Java高并发程序设计&apos;, price=65.6, author=&apos;葛一鸣，郭超 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2015-10-01&apos;, imageName=&apos;4ba3ae26-318c-425f-ad86-0faabec77a06.jpg&apos;, bookUrl=&apos;https://item.jd.com/11800589.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1978/210/1071750934/190027/becedfae/563b8251N19c01eb2.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [114] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12500208&apos;, name=&apos;区块链底层设计Java实战&apos;, price=65.6, author=&apos;牛冬 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-12-01&apos;, imageName=&apos;69ca3774-0f97-4ab0-a495-d667da2e4668.jpg&apos;, bookUrl=&apos;https://item.jd.com/12500208.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/7612/4/9370/392817/5c14a4a0E7bf4ce99/26ca34f21b1a403c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [115] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;45957612825&apos;, name=&apos;【套装2本】Java核心技术 卷I 基础知识 第10版 英文版 上下册 +Java核心技术 卷II&apos;, price=176.8, author=&apos;[美] 霍斯特曼 著&apos;, publishing=&apos;翔坤图书专营店&apos;, pubDate=&apos;出版时间：2016-06-01&apos;, imageName=&apos;13817e9b-295b-41d0-9e65-3f3bbd93018e.jpg&apos;, bookUrl=&apos;https://item.jd.com/45957612825.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/38647/18/1231/164778/5cbc49bcEc6a00982/826536550103172e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [116] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12384267&apos;, name=&apos;Java 9模块化开发：核心原则与实践&apos;, price=65.6, author=&apos;[荷] 桑德·马克 著，王净等译 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2018-06-01&apos;, imageName=&apos;0f04fa92-edb2-4729-b370-554426c7b93c.jpg&apos;, bookUrl=&apos;https://item.jd.com/12384267.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t24415/160/611982989/113145/19932968/5b3986d2N5531391e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [117] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;14710011813&apos;, name=&apos;Java核心技术 卷I 基础知识(原书第10版) 卷1 java编程思想 计算机基础&apos;, price=76.0, author=&apos;&apos;, publishing=&apos;墨马图书旗舰店&apos;, pubDate=&apos;&apos;, imageName=&apos;2760fab7-a4ff-4094-996a-1091f04b7893.jpg&apos;, bookUrl=&apos;https://item.jd.com/14710011813.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/79921/9/4278/144326/5d26d9efEdeae7b82/08e9ce4c068da8d3.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [118] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10058149&apos;, name=&apos;Java编程思想（英文版）（第4版）&apos;, price=54.4, author=&apos;[美] 埃克尔 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2007-04-01&apos;, imageName=&apos;5715c16b-f962-4082-a172-d10e04ff627e.jpg&apos;, bookUrl=&apos;https://item.jd.com/10058149.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/17310/9f5d4311-a88b-41e7-ae89-af45a1644b18.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [119] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10367718784&apos;, name=&apos;Java8实战&apos;, price=53.9, author=&apos;[英] 厄马（Raoul-GabrielUrma）[ 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2016-04-01&apos;, imageName=&apos;a2cf2242-6f6b-4d80-be58-bfc3cab7909d.png&apos;, bookUrl=&apos;https://item.jd.com/10367718784.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/72361/39/1775/483677/5d022ffdE244cda01/57c1b9cb4bddaad6.png&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [120] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12327466&apos;, name=&apos;轻量级Java EE企业应用实战（第5版）――Struts 2+Spring 5+Hiberna&apos;, price=121.6, author=&apos;李刚 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2018-03-01&apos;, imageName=&apos;a823e637-7470-4a48-b216-5692c2eaa611.jpg&apos;, bookUrl=&apos;https://item.jd.com/12327466.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t14452/269/2670034737/682465/a3b5a423/5ab38da3Ne4bbb41f.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[message]------&gt;This page has had crawled completly : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=][message]------&gt;Begin to crawling this page : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=9]\\\\\\\\\\\\\\\\\\\\第 [121] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;31163459184&apos;, name=&apos;包邮 [按需印刷]Java加密与解密的艺术(第2版)|3768927&apos;, price=89.0, author=&apos;梁栋 著&apos;, publishing=&apos;互动创新图书专营店&apos;, pubDate=&apos;出版时间：2014-01-01&apos;, imageName=&apos;c47edf98-43f3-42e2-b5f1-3710ce70e6f2.jpg&apos;, bookUrl=&apos;https://item.jd.com/31163459184.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/21909/26/11649/68080/5c909f88Ef605f986/5b9231a93f654974.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [122] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12283376&apos;, name=&apos;名师讲坛：Java开发实战经典（第2版）（配光盘）&apos;, price=113.3, author=&apos;李兴华 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2017-11-01&apos;, imageName=&apos;693dfc58-8ab4-4524-8d80-93e2ae16c910.jpg&apos;, bookUrl=&apos;https://item.jd.com/12283376.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t16483/365/368938559/139663/9ea8e248/5a2f31d7N848ab555.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [123] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12165339&apos;, name=&apos;神经网络算法与实现 基于Java语言&apos;, price=51.9, author=&apos;[巴西] Fábio，M.，Soares，法比奥，Alan ... 著，范东来，封强 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-09-01&apos;, imageName=&apos;3f8cc308-7428-44fe-b5ce-5a27dbda9c27.jpg&apos;, bookUrl=&apos;https://item.jd.com/12165339.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t7360/123/1084613304/153775/65018bcd/599a668bN381d917e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [124] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12494412&apos;, name=&apos;Java数据分析指南&apos;, price=69.5, author=&apos;[美] 约翰·哈伯德（John，R.，Hubbard） 著，高蓉，李茂 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-12-01&apos;, imageName=&apos;9074ddd6-6227-4a5a-9de9-df07ac6e07b3.jpg&apos;, bookUrl=&apos;https://item.jd.com/12494412.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t28843/357/839506568/135972/e33ce8a4/5c000f6dN105bb4ac.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [125] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12163883&apos;, name=&apos;Java测试驱动开发&apos;, price=38.7, author=&apos;[西] 维克多·法西克，阿列克斯·加西亚（Viktor，Farcic，Alex，Garcia） 著，袁国忠 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-08-01&apos;, imageName=&apos;6bb9f731-7ab8-4e3b-b3d7-8d1eef0cb172.jpg&apos;, bookUrl=&apos;https://item.jd.com/12163883.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t7639/38/1116505980/90363/d639eb6e/599a4d66Nfbf73d28.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [126] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11269625&apos;, name=&apos;Java程序员修炼之道&apos;, price=61.4, author=&apos;[英] Benjamin J. Evans，[荷兰] Martijn Verburg 著，吴海星 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2013-07-01&apos;, imageName=&apos;3dd86b6c-e421-4f3d-af70-413c7d4b24f2.jpg&apos;, bookUrl=&apos;https://item.jd.com/11269625.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/g14/M06/03/05/rBEhVlHNNcwIAAAAAAJcIy_bbgQAAAnfAME2goAAlw7350.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [127] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;41708300430&apos;, name=&apos;JAVA WEB项目开发全程实录&apos;, price=60.6, author=&apos;明日科技 著&apos;, publishing=&apos;文轩网教育考试专营店&apos;, pubDate=&apos;出版时间：2018-11-01&apos;, imageName=&apos;324faef0-8983-49a5-a3c2-3ca035b072b7.jpg&apos;, bookUrl=&apos;https://item.jd.com/41708300430.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/18107/31/6867/67500/5c638437E1328cc93/9a01f5af5557116d.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [128] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;32639062305&apos;, name=&apos;Java编程思想第4版 thinking in java中文版第四版 正版程序设计书籍&apos;, price=70.0, author=&apos;[美] Bruce Eckel 著&apos;, publishing=&apos;芝麻开门图书专营店&apos;, pubDate=&apos;出版时间：2007-05-31&apos;, imageName=&apos;d76a8245-4491-4e6d-b009-d8cff3917026.jpg&apos;, bookUrl=&apos;https://item.jd.com/32639062305.html&apos;, imageUrl=&apos;https://img10.360buyimg.com/n7/jfs/t1/1043/24/1131/246289/5b933671Ee8ebe0ad/d901647d53043923.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [129] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11948364&apos;, name=&apos;Java核心技术 卷I 基础知识 第10版 英文版 上下册&apos;, price=95.9, author=&apos;[美] 凯·S.霍斯特曼（Cay，S.，Horstmann） 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2016-06-01&apos;, imageName=&apos;2350b78c-e5fe-4a8c-b933-6f8a2c0901fe.jpg&apos;, bookUrl=&apos;https://item.jd.com/11948364.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t2881/229/2259944638/80470/3ebe59d/575fac26Ne2b16fc5.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [130] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12542817&apos;, name=&apos;Three.js开发指南：基于WebGL和HTML5在网页上渲染3D图形和动画（原书第3版） [Learning Three.Js:Programming 3D Animations and Visualizations for the Web with HTML5 and WebGL, Third Edition]&apos;, price=94.1, author=&apos;[美] 乔斯·德克森（Jos Dirksen） 著，周翀，张薇 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2019-06-01&apos;, imageName=&apos;feb3098e-3e43-4ee9-aa9c-289bbfd21a64.jpg&apos;, bookUrl=&apos;https://item.jd.com/12542817.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/75130/23/3757/73942/5d1eedbaE198299c6/6dfac1198604db6e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [131] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;28450266477&apos;, name=&apos;数据结构与算法分析：Java语言描述 原书第3版&apos;, price=48.3, author=&apos;&apos;, publishing=&apos;静默时光图书专营店&apos;, pubDate=&apos;出版时间：2016-03-01&apos;, imageName=&apos;bb9a8c1d-7e6a-491f-9c5a-04e78472f38b.jpg&apos;, bookUrl=&apos;https://item.jd.com/28450266477.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t19585/347/2645171682/187572/40555d8/5b03e16aNac0890bd.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [132] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;13645344718&apos;, name=&apos;Java核心技术卷II+Java核心技术卷1 全2册 原书第10版 java入门书 编程开&apos;, price=145.0, author=&apos;&apos;, publishing=&apos;润知天下图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;2b8d49e9-042a-401d-85eb-cd558896b3f5.jpg&apos;, bookUrl=&apos;https://item.jd.com/13645344718.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t1/63469/11/4163/162629/5d26db87E0a8e66a2/ae1c80bd3ea2495d.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [133] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;26667242534&apos;, name=&apos;Java核心技术卷II 高级特性 原书第10版 中文版 程序开发书籍&apos;, price=100.1, author=&apos;&apos;, publishing=&apos;华心图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;5e489770-aab8-4dbc-a414-94283c0ccd96.jpg&apos;, bookUrl=&apos;https://item.jd.com/26667242534.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t19762/65/1063598371/148796/6dfdad77/5abb550eNa1b11338.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [134] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12126544&apos;, name=&apos;Java Web程序设计任务教程&apos;, price=40.9, author=&apos;黑马程序员 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-01-01&apos;, imageName=&apos;5a7aafdc-4cc7-4601-9b5d-88939d935bba.jpg&apos;, bookUrl=&apos;https://item.jd.com/12126544.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t26002/96/769192476/197740/a1cd6efc/5b7bb2a3N3b8bcc37.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [135] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11983163&apos;, name=&apos;Hibernate实战（第2版） [Java Persistence with Hibernate, Second Edition]&apos;, price=60.7, author=&apos;[德] Christian Bauer，[澳] Gavin King 著，蒲成 译&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2016-09-01&apos;, imageName=&apos;d0a24200-f7d6-47a3-87eb-9ee2394fbaa1.jpg&apos;, bookUrl=&apos;https://item.jd.com/11983163.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t3118/15/3813135988/133775/e61b97dc/57f8810bNf0dbe792.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [136] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11525283&apos;, name=&apos;Java特种兵（上册 附光盘）&apos;, price=75.1, author=&apos;谢宇 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2014-09-01&apos;, imageName=&apos;a618b6b8-6b77-4c21-bb82-72fa17cea251.jpg&apos;, bookUrl=&apos;https://item.jd.com/11525283.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t238/162/2222749565/209732/b2aa41a4/540ecdc1Nc17d12d4.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [137] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12179091&apos;, name=&apos;Java机器学习&apos;, price=38.7, author=&apos;[斯洛文尼亚] 博思蒂安·卡鲁扎（Bo·tjan Kalu·a） 著，武传海 译&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2017-09-01&apos;, imageName=&apos;49ac21ff-b817-4cba-84fd-79c8944e1a52.jpg&apos;, bookUrl=&apos;https://item.jd.com/12179091.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t7627/330/2444106657/113904/4a53cc20/59afa68cN071ba978.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [138] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11615429&apos;, name=&apos;Java从入门到精通（第2版）&apos;, price=61.4, author=&apos;魔乐科技（MLDN）软件实训中心，张玉宏 编&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2015-03-01&apos;, imageName=&apos;4f968e6b-88f0-4711-ad92-23c63e3c9c70.jpg&apos;, bookUrl=&apos;https://item.jd.com/11615429.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1231/169/194210391/132178/44fd513d/55092239N36591404.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [139] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;36590815887&apos;, name=&apos;Java项目开发实战入门 Java从入门到精通 java语言程序设计java书籍教程java编程思想&apos;, price=38.8, author=&apos;&apos;, publishing=&apos;墨涵图书专营店&apos;, pubDate=&apos;出版时间：2006-08-01&apos;, imageName=&apos;0280ebb8-d904-4b6b-ba57-11dffa3dc154.jpg&apos;, bookUrl=&apos;https://item.jd.com/36590815887.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t26281/43/1578788516/96461/80d4c4fd/5be5f2b5Nd48ea11e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [140] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12377547&apos;, name=&apos;Spring学习指南 第3版&apos;, price=78.3, author=&apos;[印度] J.夏尔马（J. Sharma），阿西施·萨林（Ashish Sarin） 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-07-01&apos;, imageName=&apos;94f56705-2555-45a8-8999-f442b257ad7b.jpg&apos;, bookUrl=&apos;https://item.jd.com/12377547.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t23968/294/243413930/279875/124befec/5b2a19edNb9818bac.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [141] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12249634&apos;, name=&apos;疯狂前端开发讲义：jQuery+AngularJS+Bootstrap前端开发实战&apos;, price=75.1, author=&apos;李刚 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2017-10-01&apos;, imageName=&apos;d33dfa19-bd2d-43e9-9b9e-fb9ba83ba561.jpg&apos;, bookUrl=&apos;https://item.jd.com/12249634.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t10264/136/1233380306/324357/66dc456f/59de4605Na32313f3.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [142] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12073933&apos;, name=&apos;深入浅出React和Redux&apos;, price=54.5, author=&apos;程墨 著&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2017-05-01&apos;, imageName=&apos;d7a9c238-1037-4ecf-b07a-e1e1b426da9c.jpg&apos;, bookUrl=&apos;https://item.jd.com/12073933.html&apos;, imageUrl=&apos;https://img13.360buyimg.com/n7/jfs/t5107/58/1653926146/128683/79be7ee8/5912e2fcNf9a839fc.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [143] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;10189488174&apos;, name=&apos;大型网站技术架构+大型网站系统与Java中间件实践 （共两册）&apos;, price=90.6, author=&apos;李智慧 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2013-11-01&apos;, imageName=&apos;ea44569b-1155-4bdc-a8ab-ed9711806d93.jpg&apos;, bookUrl=&apos;https://item.jd.com/10189488174.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t19390/55/1480670900/71578/c2bffa92/5acb4125N250fc512.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [144] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;48468755934&apos;, name=&apos;&apos;, price=3698.0, author=&apos;&apos;, publishing=&apos;佳沃&apos;, pubDate=&apos;&apos;, imageName=&apos;17824a12-db77-4eae-9bba-fcd11bf03ee9.jpg&apos;, bookUrl=&apos;https://item.jd.com/48468755934.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/72048/34/294/146388/5ce7a96eEf35c4cd5/12660ede94253ebd.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [145] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;43431775867&apos;, name=&apos;Java数据结构和算法 拉佛 9787508356440 中国电力出版社&apos;, price=119.0, author=&apos;&apos;, publishing=&apos;爱德雅图书专营店&apos;, pubDate=&apos;&apos;, imageName=&apos;469c5af0-a181-42bd-8ce8-c7218b07593e.jpg&apos;, bookUrl=&apos;https://item.jd.com/43431775867.html&apos;, imageUrl=&apos;https://img12.360buyimg.com/n7/jfs/t1/29427/30/15617/108405/5cb16e25E59f4e362/0fc0d48027deb11c.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [146] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;11972824&apos;, name=&apos;数据结构与算法经典问题解析：Java语言描述(原书第2版）&apos;, price=62.4, author=&apos;[印度] 纳拉西姆哈·卡鲁曼希（Narasimha Karumanchi） 著，骆嘉伟 译&apos;, publishing=&apos;机械工业出版社&apos;, pubDate=&apos;出版时间：2016-06-01&apos;, imageName=&apos;50dd85ab-ebfa-44df-826f-493c1c870fac.jpg&apos;, bookUrl=&apos;https://item.jd.com/11972824.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t2827/53/3285584017/111648/dbb7962c/5787050dN0c9428ae.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [147] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12068611&apos;, name=&apos;Java 2实用教程（第5版）实验指导与习题解答/高等学校Java课程系列教材&apos;, price=25.0, author=&apos;张跃平，耿祥义 著&apos;, publishing=&apos;清华大学出版社&apos;, pubDate=&apos;出版时间：2017-04-01&apos;, imageName=&apos;c7d82418-2711-4ab9-9f25-fb4c3fd34e6d.jpg&apos;, bookUrl=&apos;https://item.jd.com/12068611.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t5146/32/423649499/74201/57f02580/58ff0b5cNd33fce0e.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [148] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12534924&apos;, name=&apos;Java面向对象思想与程序设计&apos;, price=59.3, author=&apos;刘彦君，张仁伟，满志强 著&apos;, publishing=&apos;人民邮电出版社&apos;, pubDate=&apos;出版时间：2018-11-01&apos;, imageName=&apos;d237c39a-e5be-4b33-b660-66ea3993b515.jpg&apos;, bookUrl=&apos;https://item.jd.com/12534924.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t1/20377/40/6204/204310/5c49136aE717954ee/325c34e9ba230448.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [149] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;18384142316&apos;, name=&apos;Java核心技术卷II：高级特性 原书第10版 华章图书 Java核心技术系列&apos;, price=87.8, author=&apos;[美] 凯S.霍斯特曼(CayS.Horstmann 著&apos;, publishing=&apos;文轩网旗舰店&apos;, pubDate=&apos;出版时间：2017-09-01&apos;, imageName=&apos;e8ab647d-bb8c-403b-819b-1861c0d6e5e8.jpg&apos;, bookUrl=&apos;https://item.jd.com/18384142316.html&apos;, imageUrl=&apos;https://img11.360buyimg.com/n7/jfs/t1/2608/16/7182/57817/5ba4ce62Ea982f0a9/90b6abd0629c209f.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\第 [150] 本\\\\\\\\\\\\\\\\\\\\Book&#123;sku=&apos;12167904&apos;, name=&apos;Java大学实用教程（第4版）&apos;, price=31.7, author=&apos;耿祥义 著&apos;, publishing=&apos;电子工业出版社&apos;, pubDate=&apos;出版时间：2017-03-01&apos;, imageName=&apos;4ceac15b-2d10-4161-868a-a3b098c06837.jpg&apos;, bookUrl=&apos;https://item.jd.com/12167904.html&apos;, imageUrl=&apos;https://img14.360buyimg.com/n7/jfs/t4663/293/1745170178/76878/a2d78fc0/58e51a8aN76bad3cb.jpg&apos;&#125;[message]------&gt;Data was added to the database successfully ヾ(◍°∇°◍)ﾉﾞ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[message]------&gt;This page has had crawled completly : [https://search.jd.com/Search?keyword=Java&amp;enc=utf-8&amp;page=]Process finished with exit code 0","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Jsoup","slug":"Jsoup","permalink":"http://yoursite.com/tags/Jsoup/"},{"name":"Crawler","slug":"Crawler","permalink":"http://yoursite.com/tags/Crawler/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://yoursite.com/tags/HttpClient/"}]},{"title":"Java爬虫之WebMagic","slug":"Java爬虫之WebMagic","date":"2019-07-12T11:58:43.000Z","updated":"2019-08-25T06:31:01.009Z","comments":true,"path":"2019/07/12/Java爬虫之WebMagic/","link":"","permalink":"http://yoursite.com/2019/07/12/Java爬虫之WebMagic/","excerpt":"","text":"学习笔记 : Java爬虫之WebMagic简介 : WebMagic是一款简单灵活的爬虫框架,WebMagic的结构分为Downloader、PageProcessor、Scheduler、Pipeline四大组件,并由Spider将它们彼此组织起来. 这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能. 而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为Spider是一个大的容器，它也是WebMagic逻辑的核心. Little book of WebMagic : http://webmagic.io/docs/zh/ WebMagic总体架构图如下所示 : WebMagic的四个组件DownloaderDownloader负责从互联网上下载页面,以便后续处理. WebMagic默认使用了Apache HttpClient作为下载工具 PageProcessorPageProcessor负责解析页面,抽取有用信息,以及发现新的链接,WebMagic使用Jsoup作为HTML解析工具,并基于其开发了解析XPath的工具Xsoup. 注意 : 在这四个组件中,PageProcessor对于每个站点每个页面都不一样,是需要使用者定制的部分 . SchedulerScheduler负责管理待抓取的URL,以及一些去重的工作. WebMagic默认提供了JDK的内存队列来管理URL,并用集合来进行去重. 也支持使用Redis进行分布式管理 . PipelinePipeline负责抽取结果的处理,包括计算、持久化到文件、数据库等.. WebMagic默认提供了输出到控制台和保存到文件两种结果处理方案. Pipeline定义了结果保存的方式,如果你要保存到指定数据库,则需要编写对应的Pipeline. 对于一类需求一般只需编写一个Pipeline . 用于数据流转的对象RequestRequest是对URL地址的一层封装,一个Request对应一个URL地址. 它是PageProcessor与Downloader交互的载体,也是PageProcessor控制Downloader唯一方式. 除了URL本身外,它还包含一个Key-Value结构的字段extra. 你可以在extra中保存一些特殊的属性,然后在其他地方读取,以完成不同的功能。例如附加上一个页面的一些信息等 . PagePage代表了从Downloader下载到的一个页面——可能是HTML,也可能是JSON或者其他文本格式的内容. Page为WebMagic抽取过程的核心对象,它提供一些方法可供抽取、结果保存等 .. ResultItemsResultItems相当于一个Map,它保存PageProcessor处理的结果,供Pipeline使用. 它的API与Map很类似,值得注意的是它有一个字段skip,若设置为true,则不应被Pipeline处理 . 控制爬虫运转的引擎-SpiderSpider是WebMagic内部流程的核心. Downloader、PageProcessor、Scheduler、Pipeline都是Spider的一个属性,这些属性是可以自由设置的,通过设置这个属性可以实现不同的功能. Spider也是WebMagic操作的入口,它封装了爬虫的创建、启动、停止、多线程等功能 .. 注意 : 一般来说,对于编写一个爬虫,PageProcessor是需要编写的部分,而Spider则是创建和控制爬虫的入口哟 ~ WebMagic入门程序获取我博客中的个人姓名信息,示例程序如下 :123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.crawler.WebMagic_Demo;import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Spider;import us.codecraft.webmagic.processor.PageProcessor;/** * @project: crawler_learning * @description: 第一个WebMagic小爬虫:爬取博客中的个人姓名 * @author: 黄宇辉 * @date: 7/10/2019-3:54 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class FirstDemo implements PageProcessor &#123; //可以对爬虫进行一些配置,包括编码,抓取间隔,超时时间,重试次数等.. private Site site = Site.me(); @Override public void process(Page page) &#123; //解析Page,并将其结果存放到ResultItem中 page.putField(\"name\", page.getHtml().css(\"aside#menu hgroup.introduce h5\", \"text\")); System.out.println(page.getResultItems().toString()); &#125; @Override public Site getSite() &#123; return site; &#125; //WebMagic默认将爬取结果输出到控制台 public static void main(String[] args) &#123; Spider.create(new FirstDemo()) .addUrl(\"https://yubuntu0109.github.io/\") .run(); &#125;&#125; 程序运行结果 :12345678910111219-07-13 15:58:11,084 INFO us.codecraft.webmagic.Spider(Spider.java:306) ## Spider yubuntu0109.github.io started!19-07-13 15:58:12,210 INFO us.codecraft.webmagic.downloader.HttpClientDownloader(HttpClientDownloader.java:86) ## downloading page success https://yubuntu0109.github.io/ResultItems&#123;fields=&#123;name=黄宇辉&#125;, request=Request&#123;url=&apos;https://yubuntu0109.github.io/&apos;, method=&apos;null&apos;, extras=null, priority=0, headers=&#123;&#125;, cookies=&#123;&#125;&#125;, skip=false&#125;get page: https://yubuntu0109.github.io/name: 黄宇辉 &lt;----------WebMagic默认将爬取结果输出到控制台19-07-13 15:58:17,405 INFO us.codecraft.webmagic.Spider(Spider.java:338) ## Spider yubuntu0109.github.io closed! 1 pages downloaded.Process finished with exit code 0 WebMagic抽取元素功能CSS : 爬取博客个人姓名信息的元素标签1page.putField(\"name\", page.getHtml().css(\"aside#menu hgroup.introduce h5\")); 程序运行结果 :1name: &lt;h5 class=&quot;nickname&quot;&gt;黄宇辉&lt;/h5&gt; CSS : 爬取博客个人姓名信息1page.putField(\"name\", page.getHtml().css(\"aside#menu hgroup.introduce h5\", \"text\")); 程序运行结果 :1name: 黄宇辉 CSS : 爬取博客首页所有文章标题1page.putField(\"title\", page.getHtml().css(\"div.container h3 a\", \"text\").all()); 程序运行结果 :12345678910111213title: [ Java爬虫之Jsoup, Java爬虫之HttpClient, Spring-Boot拥抱MyBatis及Redis ~, Spring Boot之文件上传与下载, Spring Boot项目:好友备忘录, Spring Boot之Thymeleaf, Spring Boot之整合视图层技术, Spring Boot之基本Web开发, Hi Redis ~, Hi Spring Boot ~] XPath : 爬取博客首页所有文章标题的元素标签1page.putField(\"title\", page.getHtml().xpath(\"//div[@class=container]/ul/li/article/h3/a\").all()); 程序运行结果 :12345678910111213title: [ &lt;a class=\"post-title-link\" href=\"/2019/07/10/Java爬虫之Jsoup/\"&gt;Java爬虫之Jsoup&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/07/10/Java爬虫之HttpClient/\"&gt;Java爬虫之HttpClient&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/07/01/Spring-Boot拥抱MyBatis及Redis/\"&gt;Spring-Boot拥抱MyBatis及Redis ~&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/06/30/Spring-Boot之文件上传/\"&gt;Spring Boot之文件上传与下载&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/06/30/Spring-Boot项目-好友备忘录/\"&gt;Spring Boot项目:好友备忘录&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/06/27/Spring-Boot之Thymeleaf/\"&gt;Spring Boot之Thymeleaf&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/06/26/Spring-Boot之整合视图层技术/\"&gt;Spring Boot之整合视图层技术&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/06/26/Spring-Boot之基本Web开发/\"&gt;Spring Boot之基本Web开发&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/06/25/Hi-Redis/\"&gt;Hi Redis ~&lt;/a&gt;, &lt;a class=\"post-title-link\" href=\"/2019/06/23/Hi-Spring-Boot/\"&gt;Hi Spring Boot ~&lt;/a&gt;] Regex : 爬取博客首页含’Java’关键字的文章标题1page.putField(\"title\", page.getHtml().css(\"div.container h3 a\", \"text\").regex(\".*Java.*\").all()); 程序运行结果 :1title: [Java爬虫之Jsoup, Java爬虫之HttpClient] Link : 爬取博客首页含’Java’关键字的文章链接1234//获取博客首页中包含'Hi'关键字的文章链接page.addTargetRequests(page.getHtml().css(\"div.container h3 a\").links().regex(\".*Hi.*\").all());//根据文章链接获取该文章标题page.putField(\"blog-title\", page.getHtml().css(\"div.post-content h2\", \"text\").all()); 程序运行结果 :12345678919-07-13 16:52:15,233 INFO us.codecraft.webmagic.downloader.HttpClientDownloader(HttpClientDownloader.java:86) ## downloading page success https://yubuntu0109.github.io/2019/06/25/Hi-Redis/get page: https://yubuntu0109.github.io/2019/06/25/Hi-Redis/blog-title: [学习笔记 : 拥抱Redis ~]19-07-13 16:52:20,490 INFO us.codecraft.webmagic.downloader.HttpClientDownloader(HttpClientDownloader.java:86) ## downloading page success https://yubuntu0109.github.io/2019/06/23/Hi-Spring-Boot/get page: https://yubuntu0109.github.io/2019/06/23/Hi-Spring-Boot/blog-title: [学习笔记 : 拥抱Spring Boot] WebMagic自定义配置对爬虫进行一些配置12345private static Site site = Site.me() .setCharset(\"utf-8\")//字符编码 .setTimeOut(10000)//超时时间-10s .setRetrySleepTime(2000)//重试间隔时间-2s .setRetryTimes(5);//重试次数 将爬取的数据存储到指定文件夹中1Spider.create(new PipelineDemo()).addPipeline(new FilePipeline(\"D:\\\\WebMagic-Pipeline-Demo\\\\Data\\\\\")) .. 设置处理爬虫的线程数1Spider.create(new ThreadDemo()).thread(5)..","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"WebMagic","slug":"WebMagic","permalink":"http://yoursite.com/tags/WebMagic/"}]},{"title":"Java爬虫之Jsoup","slug":"Java爬虫之Jsoup","date":"2019-07-10T10:55:14.000Z","updated":"2019-08-25T06:31:01.009Z","comments":true,"path":"2019/07/10/Java爬虫之Jsoup/","link":"","permalink":"http://yoursite.com/2019/07/10/Java爬虫之Jsoup/","excerpt":"","text":"学习笔记 : Java爬虫之Jsoup(Java HTML Parser)jsoup is a Java library for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jquery-like methods. 👍 jsoup Cookbook : https://www.open-open.com/jsoup/ 爬虫实现使用Jsoup解析不同数据的方式,示例程序如下 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.crawler.Jsoup_Demo;import org.apache.commons.io.FileUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;/** * @project: crawler_learning * @description: 学习使用Jsoup * @author: 黄宇辉 * @date: 7/8/2019-9:34 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class JsoupTest &#123; public static void main(String[] args) throws IOException &#123; urlTest(); stringTest(); fileTest(); &#125; // TODO: 7/8/2019 解析URL:获取网页title标签内容 private static void urlTest() throws IOException &#123; //解析URL地址并设置请求信息,获取Document对象 Document document = Jsoup.connect(\"https://www.bilibili.com/\") .timeout(1000) .userAgent(\"x-x-x-x-x-x\") .get(); System.out.println(document.title()); &#125; // TODO: 7/9/2019 解析字符串:获取字符串中title标签内容 private static void stringTest() throws IOException &#123; //使用文件工具类读取文件,获取字符串 String content = FileUtils.readFileToString(new File(\"C:/Users/Administrator/Desktop/html.html\"), \"gbk\"); //解析字符串 Document doc = Jsoup.parse(content); System.out.println(doc.getElementsByTag(\"title\").first().text()); &#125; // TODO: 7/9/2019 解析文件:获取文件中title标签内容 private static void fileTest() throws IOException &#123; //解析文件 Document doc = Jsoup.parse(new File(\"C:/Users/Administrator/Desktop/html.html\"), \"gbk\"); System.out.println(doc.title()); &#125;&#125; Jsoup DOM学习使用Jsoup-DOM获取元素及其中数据,示例程序如下 :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package pers.huangyuhui.crawler.Jsoup_DOM;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.IOException;/** * @project: crawler_learning * @description: 学习使用Jsoup-DOM获取元素及其中数据 * @author: 黄宇辉 * @date: 7/9/2019-8:18 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class ElementTest &#123; public static void main(String[] args) &#123; try &#123; /* 解析url并设置请求信息,获取Document对象 */ Document doc = Jsoup.connect(\"https://yubuntu0109.github.io/\") .timeout(5000) .userAgent(\"x-x-x-x-x-x\") .get(); /* 根据Document对象获取元素 */ //1:通过id获取元素:获取博客头标题 Element element = doc.getElementById(\"header\"); System.out.println(element.text()); //2:通过tag获取元素:获取博客文章标题 Elements elements = doc.getElementsByTag(\"h3\"); for (Element e : elements) &#123; System.out.println(e.text()); &#125; //3:通过class获取元素:获取博客文章简介 Elements elements2 = doc.getElementsByClass(\"post-content\"); for (Element e : elements2) &#123; System.out.println(e.text() + \"\\n\"); &#125; //4:通过attribute获取元素:获取博客文章发布时间 Elements elements3 = doc.getElementsByAttribute(\"datetime\"); for (Element e : elements3) &#123; System.out.println(e.text()); &#125; //4-2:通过属性名加属性值筛选元素:获取博客文章标题 Elements elements4 = doc.getElementsByAttributeValue(\"itemprop\", \"name\"); for (Element e : elements4) &#123; System.out.println(e.text()); &#125; /* 获取元素中的数据 */ Element e = doc.getElementById(\"header\"); //1:从元素中获取id System.out.println(e.id()); //2:从元素中获取文本内容text System.out.println(e.text()); //3:从元素中获取className System.out.println(e.className()); //4:从元素中获取属性的值attr System.out.println(e.attr(\"id\")); //5:从元素中获取所有属性attributes System.out.println(e.attributes().toString()); // ······ &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Jsoup Selector学习使用Jsoup选择器,示例程序如下 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package pers.huangyuhui.crawler.Jsoup_Selector;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.IOException;/** * @project: crawler_learning * @description: 学习使用Jsoup选择器 * @author: 黄宇辉 * @date: 7/9/2019-10:29 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class SelectorTest &#123; public static void main(String[] args) throws IOException &#123; /* 解析url并设置请求信息,获取Document对象 */ Document doc = Jsoup.connect(\"https://yubuntu0109.github.io/\") .timeout(5000) .userAgent(\"x-x-x-x-x-x\") .get(); /* Jsoup选择器的使用方式 */ //el#id : 获取博客头标题 System.out.println(doc.select(\"header#header\").first().text()); //el.class : 获取博客的导航标签 Elements elements = doc.select(\"ul.nav\"); for (Element e : elements) &#123; System.out.println(e.text()); &#125; //el[attr] : 获取博客文章标题 Elements elements2 = doc.select(\"h3[itemprop]\"); for (Element e : elements2) &#123; System.out.println(e.text()); &#125; //.ancestor child : 查询某个元素的下个子元素,获取博客导航标签 Elements elements3 = doc.select(\".nav li\"); for (Element e : elements3) &#123; System.out.println(e.text()); &#125; //parent &gt; child : 查询某个父元素下的直接子元素,获取博客文章链接的href值 Elements elements4 = doc.select(\".post-title &gt; a\"); for (Element e : elements4) &#123; System.out.println(e.attr(\"href\")); &#125; //parenet &gt; * : 查询某个父元素下所有直接子元素,获取博客文章标题 Elements elements5 = doc.select(\".post-title &gt; *\"); for (Element e : elements5) &#123; System.out.println(e.text()); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Jsoup","slug":"Jsoup","permalink":"http://yoursite.com/tags/Jsoup/"}]},{"title":"Java爬虫之HttpClient","slug":"Java爬虫之HttpClient","date":"2019-07-10T10:54:55.000Z","updated":"2019-08-25T06:31:01.008Z","comments":true,"path":"2019/07/10/Java爬虫之HttpClient/","link":"","permalink":"http://yoursite.com/2019/07/10/Java爬虫之HttpClient/","excerpt":"","text":"学习笔记 : Java爬虫之HttpClient简介 : HttpClient是Apache Jakarta Common下的子项目,用于提供高效的,功能丰富的支持HTTP协议的客户编程工具包,其主要功能如下: 实现了所有HTTP的方法 : GET,POST,PUT,HEAD .. 支持自动重定向 支持HTTPS协议 支持代理服务器 实现爬虫传统实现 : 爬取静态网页123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.crawler.HttpClient_Demo;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.nio.charset.StandardCharsets;/** * @project: crawler_learning * @description: 下载网页的基本方法:使用java.net.URL * @author: 黄宇辉 * @date: 7/8/2019-11:16 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BasicCrawler &#123; public static void main(String[] args) throws IOException &#123; URL pageURL = new URL(\"https://yubuntu0109.github.io/\"); //创建数据流 BufferedReader reader = new BufferedReader(new InputStreamReader(pageURL.openStream(), StandardCharsets.UTF_8)); //获取网页内容 String line; StringBuilder pageBuffer = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; pageBuffer.append(line); &#125; //释放资源 reader.close(); System.out.println(pageBuffer.toString()); &#125;&#125; HttpClient实现 : 爬取静态网页1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.crawler.HttpClient_Demo;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;/** * @project: crawler_learning * @description: 下载网页的基本方法:使用HttpClient * @author: 黄宇辉 * @date: 7/2/2019-10:42 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class HttpClientCrawler &#123; public static void main(String[] args) &#123; //指定待爬取的网页链接并设置Header信息 HttpGet httpGet = new HttpGet(\"https://www.bilibili.com/\"); httpGet.setHeader(\"User-Agent\", \"xxxxxx\"); //创建HttpClient对象 try (CloseableHttpClient httpClient = HttpClients.createDefault()) &#123; //发起请求,获取响应 try (CloseableHttpResponse response = httpClient.execute(httpGet)) &#123; //解析响应,获取数据 if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity httpEntity = response.getEntity(); //获取响应体 String content = EntityUtils.toString(httpEntity, \"utf-8\");//获取静态页面 System.out.println(content); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; GET请求无参GET请求 : 爬取B站静态网页123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.crawler.HttpClient_Get;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;/** * @project: crawler_learning * @description: 学习使用无参HttpGet():爬取B站静态网页 * @author: 黄宇辉 * @date: 7/8/2019-12:26 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class GetTest &#123; public static void main(String[] args) &#123; //指定待爬取网页的链接并设置Header信息 HttpGet httpGet = new HttpGet(\"https://www.bilibili.com/\"); httpGet.setHeader(\"User-Agent\", \"x-x-x-x-x-x\"); //创建HttpClient对象 try (CloseableHttpClient httpClient = HttpClients.createDefault()) &#123; //发起请求,获取响应 try (CloseableHttpResponse response = httpClient.execute(httpGet)) &#123; //解析响应,获取数据 if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity httpEntity = response.getEntity(); //获取响应体 String content = EntityUtils.toString(httpEntity, \"utf-8\");//获取静态页面 System.out.println(content); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 有参GET请求 : 爬取B站中搜索关键字为jsoup的网页内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.crawler.HttpClient_Get;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.net.URISyntaxException;/** * @project: crawler_learning * @description: 学习使用有参HttpGet(URI uri):爬取B站中搜索关键字为jsoup的网页内容 * @author: 黄宇辉 * @date: 7/8/2019-1:12 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class GetParamTest &#123; public static void main(String[] args) throws URISyntaxException, IOException &#123; //设置HttpGet参数 URIBuilder uriBuilder = new URIBuilder(\"https://search.bilibili.com/all\"); uriBuilder.setParameter(\"keyword\", \"jsoup\"); //指定待爬取的网页链接并设置Header信息 HttpGet httpGet = new HttpGet(uriBuilder.build()); httpGet.setHeader(\"User-Agent\", \"x-x-x-x-x-x\"); //创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); //发起请求,获取响应 CloseableHttpResponse response = httpClient.execute(httpGet); //解析响应,获取数据 if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity httpEntity = response.getEntity(); //获取响应体 String content = EntityUtils.toString(httpEntity, \"utf-8\");//获取静态页面 System.out.println(content); &#125; //释放资源 response.close(); httpClient.close(); &#125;&#125; POST请求无参POST请求 : 爬取CSDN静态网页1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.crawler.HttpClient_Post;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;/** * @project: crawler_learning * @description: 学习使用无参HttpPost():爬取CSDN静态网页 * @author: 黄宇辉 * @date: 7/8/2019-12:26 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class PostTest &#123; public static void main(String[] args) &#123; //指定待爬取的网页并设置Header信息 HttpPost httpPost = new HttpPost(\"https://www.csdn.net/\"); httpPost.setHeader(\"User-Agent\", \"x-x-x-x-x-x\"); //创建HttpClient对象 try (CloseableHttpClient httpClient = HttpClients.createDefault()) &#123; //发起请求,获取响应 try (CloseableHttpResponse response = httpClient.execute(httpPost)) &#123; //解析响应,获取数据 if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity httpEntity = response.getEntity(); //获取响应体 String content = EntityUtils.toString(httpEntity, \"utf-8\");//获取静态页面 System.out.println(content); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 有参POST请求 : 爬取B站中搜索关键字为jsoup的网页内容(注:其并不支持POST,既只做演示)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.huangyuhui.crawler.HttpClient_Post;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * @project: crawler_learning * @description: 学习使用有参HttpPost(String uri):爬取B站中搜索关键字为jsoup的网页内容(注:其并不支持POST,既只做演示) * @author: 黄宇辉 * @date: 7/8/2019-1:12 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class PostParamTest &#123; public static void main(String[] args) throws IOException &#123; //指定待爬取的网页链接 HttpPost httpPost = new HttpPost(\"https://search.bilibili.com/all\"); //封装表单中的参数 List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;(); params.add(new BasicNameValuePair(\"keyword\", \"jsoup\"));//设置请求参数 UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params, \"utf-8\");//创建表单中的Entity对象 httpPost.setEntity(formEntity);//将表单的Entity对象到Post请求中 httpPost.setHeader(\"User-Agent\", \"x-x-x-x-x-x\");//设置Header信息 //创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); //发起请求,返回响应 CloseableHttpResponse response = httpClient.execute(httpPost); //解析响应,获取数据 if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity httpEntity = response.getEntity(); //获取响应体 String content = EntityUtils.toString(httpEntity, \"utf-8\");//获取静态页面 System.out.println(content); &#125; //释放资源 response.close(); httpClient.close(); &#125;&#125; HttpClient连接池学习使用HttpClient连接池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pers.huangyuhui.crawler.HttpClient_ConnPool;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.util.EntityUtils;/** * @project: crawler_learning * @description: 学习使用HttpClient连接池 * @author: 黄宇辉 * @date: 7/8/2019-3:45 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class PoolTest &#123; public static void main(String[] args) &#123; //创建连接池管理器 PoolingHttpClientConnectionManager phccm = new PoolingHttpClientConnectionManager(); phccm.setMaxTotal(100);//最大连接数 phccm.setDefaultMaxPerRoute(10);//每个主机的最大连接数 doGet(phccm); &#125; /** * @description: 爬取B站静态网页 * @param: phccm * @date: 2019-07-08 4:15 PM * @return: void */ private static void doGet(PoolingHttpClientConnectionManager phccm) &#123; //指定待爬取网页的url HttpGet httpGet = new HttpGet(\"https://www.bilibili.com/\"); httpGet.setHeader(\"User-Agent\", \"x-x-x-x-x-x\"); //创建HttpClient对象:每次从连接池中获取HttpClient对象 CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(phccm).build(); //发起请求,获取响应 try (CloseableHttpResponse response = httpClient.execute(httpGet)) &#123; //解析响应,获取数据 if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity httpEntity = response.getEntity(); //获取响应体 String content = EntityUtils.toString(httpEntity, \"utf-8\");//获取静态页面 System.out.println(content); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //httpClient.close(); //由PoolingHttpClientConnectionManager管理 &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://yoursite.com/tags/HttpClient/"}]},{"title":"Spring-Boot拥抱MyBatis及Redis ~","slug":"Spring-Boot拥抱MyBatis及Redis","date":"2019-07-01T02:26:26.000Z","updated":"2019-08-25T06:31:01.037Z","comments":true,"path":"2019/07/01/Spring-Boot拥抱MyBatis及Redis/","link":"","permalink":"http://yoursite.com/2019/07/01/Spring-Boot拥抱MyBatis及Redis/","excerpt":"","text":"学习笔记 : Spring Boot拥抱MyBatis及Redis ~Spring Boot集成MyBatis下面通过使用Spring Boot开发一个基于SSM的框架的应用,并通过一个简单的用户信息查询为例,记录如何在Spring Boot中使用MyBatis ~ tb_user.sql : 用户信息数据表 1234567create table tb_user( id int auto_increment primary key, name varchar(15) not null, gender char null, email varchar(50) null); pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- lookup parent from repository --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;pers.huangyuhui&lt;/groupId&gt; &lt;artifactId&gt;redis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot_redis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;!-- mvn package --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; SpringbootRedisApplication.java : Spring Boot启动类 12345678910111213package pers.huangyuhui.redis;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootRedisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootRedisApplication.class, args); &#125;&#125; application.properties : Spring Boot配置文件 1234567#JDBC-Connection Configuration Informationspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truespring.datasource.username=xxxxxxspring.datasource.password=xxxxxx#Logging Configuration Informationlogging.level.pers.huangyuhui.redis=debug User.java : 用户信息实体类 1234567891011121314151617181920package pers.huangyuhui.redis.bean;/** * @project: springboot_redis * @description: 用户信息 * @author: 黄宇辉 * @date: 7/1/2019-7:08 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class User &#123; private Integer id; private String name; private String gender; private String email; //getter and setter ······&#125; UserMapper.java : 操控用户数据表信息 123456789101112131415161718192021222324252627package pers.huangyuhui.redis.dao;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import pers.huangyuhui.redis.bean.User;import java.util.List;/** * @project: springboot_redis * @description: Dao层-操控用户信息 * @author: 黄宇辉 * @date: 7/1/2019-7:12 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Mapperpublic interface UserMapper &#123; // TODO: 7/1/2019 查询所有用户信息 @Select(\"select * from tb_user\") List&lt;User&gt; selectAll(); // TODO: 7/1/2019 根据id删除指定用户信息 @Delete(\"Delete from tb_user where id = #&#123;id&#125;\") void deleteById(Integer id);&#125; UserService.java : 操控用户信息 12345678910111213141516171819202122package pers.huangyuhui.redis.service;import pers.huangyuhui.redis.bean.User;import java.util.List;/** * @project: springboot_redis * @description: Service层-操控用户信息 * @author: 黄宇辉 * @date: 7/1/2019-7:25 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface UserService &#123; // TODO: 7/1/2019 获取或有用户信息 List&lt;User&gt; findAll(); // TODO: 7/1/2019 根据id删除指定用户信息 void delete(Integer id);&#125; UserServiceImpl.java : UserService.java的实现类 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.redis.service.impl;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import pers.huangyuhui.redis.bean.User;import pers.huangyuhui.redis.dao.UserMapper;import pers.huangyuhui.redis.service.UserService;import javax.annotation.Resource;import java.util.List;/** * @project: springboot_redis * @description: UserService的实现类 * @author: 黄宇辉 * @date: 7/1/2019-7:27 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; //注入Mapper对象 @Resource private UserMapper userMapper; @Override public List&lt;User&gt; findAll() &#123; return userMapper.selectAll(); &#125; @Override public void delete(Integer id) &#123; userMapper.deleteById(id); &#125;&#125; UserController.java : 用户信息控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.redis.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import pers.huangyuhui.redis.bean.User;import pers.huangyuhui.redis.service.UserService;import java.util.List;/** * @project: springboot_redis * @description: 用户控制器 * @author: 黄宇辉 * @date: 7/1/2019-7:28 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controller@RequestMapping(\"/user\")public class UserController &#123; //注入业务对象 @Autowired private UserService userService; /** * @description: 获取所有用户信息 * @date: 2019-07-01 8:16 AM * @return: java.util.List&lt;pers.huangyuhui.redis.bean.User&gt; */ @RequestMapping(\"/getUserList\") @ResponseBody public List&lt;User&gt; getUserList() &#123; return userService.findAll(); &#125; /** * @description: 删除指定id的好友信息 * @param: id * @date: 2019-07-01 12:51 PM * @return: void */ @RequestMapping(\"/deleteUser/&#123;id&#125;\") public void deleteUser(@PathVariable Integer id) &#123; userService.delete(id); &#125;&#125; userList.html : 用户信息列表页面 (将EasyUI框架的资源文件拷贝到src/main/resource下的static文件夹下,并在static文件夹中创建userList.html页面文件) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息列表页面&lt;/title&gt; &lt;!-- CSS --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"easyui/themes/metro/easyui.css\"/&gt; &lt;!-- JS --&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.easyui.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"easyui/themes/locale/easyui-lang-zh_CN.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function () &#123; $('#graid').datagrid(&#123; url: 'user/getUserList', fit: true, columns: [[ &#123;field: 'id', title: '编号', width: 100&#125;, &#123;field: 'name', title: '姓名', width: 100&#125;, &#123;field: 'gender', title: '性别', width: 100&#125;, &#123;field: 'email', title: '邮箱', width: 200&#125; ]] &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 用户信息列表 --&gt;&lt;table id=\"graid\"&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 启动Spring Boot项目,在浏览器中输入访问地址 : http://localhost:8080/userList.html后,显示效果参考下图 : 紧接着刷新页面三次,其控制台打印的日志信息如下所示,发现每刷新一次页面都会执行一次查询数据库操作,但如果将列表数据缓冲到Redis后,会发现控制台只会出现一次查询数据库的日志信息哟 !123456789101112132019-07-01 11:41:49.868 DEBUG 7844 --- [nio-8080-exec-3] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 11:41:49.869 DEBUG 7844 --- [nio-8080-exec-3] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 11:41:49.871 DEBUG 7844 --- [nio-8080-exec-3] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 52019-07-01 11:41:54.250 DEBUG 7844 --- [nio-8080-exec-5] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 11:41:54.250 DEBUG 7844 --- [nio-8080-exec-5] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 11:41:54.253 DEBUG 7844 --- [nio-8080-exec-5] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 52019-07-01 11:41:57.251 DEBUG 7844 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 11:41:57.251 DEBUG 7844 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 11:41:57.256 DEBUG 7844 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 5Process finished with exit code -1 Spring Boot集成RedisRedis是一个完全开源的,遵守BSD协议的,内存中的数据结构存储,它既可以作为数据库,也可以作为缓存和消息代理. 通常在企业中常将其作为缓存使用哟~ 接下来在Spring Boot集成MyBatis示例程序基础上将列表数据缓存到Redis中,详细步骤如下 : 在pom.xml中添加Spring Boot支持Redis的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在SpringbootRedisApplication.java中添加@EnableCaching注解来开启缓存 12345@SpringBootApplication@EnableCachingpublic class SpringbootRedisApplication &#123; //······&#125; 在业务逻辑类UserServiceImpl.java的方法上添加@Cacheable注解来支持Redis缓存 12345@Override@Cacheable(value = \"UserCatch\", key = \"'user.selectAll'\")public List&lt;User&gt; findAll() &#123; return userMapper.selectAll();&#125; 为便于数据的传输,将实体类User.java实现序列化接口Serializable 123public class User implements Serializable &#123; //······&#125; 在application.properties中指定Redis缓存主机地址及端口号. 我使用的是Windows的Redis发行版哟,其学习笔记 : https://yubuntu0109.github.io/2019/06/25/Hi-Redis/ 123#Redis Configuration Infromationspring.redis.host=localhostspring.redis.port=6379 启动Redis服务,并启动Spring Boot项目,在浏览器地址栏中输入访问地址 : http://localhost:8080/userList.html后,不断刷新页面,其控制台打印的日志信息如下,结论 : 在没有使用Redis缓存之前,每刷新一次页面,都会执行一次查询数据库的操作,添加缓存后,会发现日志信息中只出现了一次查询语句,这也就说明所配置的Redis缓存已经生效啦 ~ 123456789101112131415161718192019-07-01 12:43:06.945 INFO 1984 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet &apos;dispatcherServlet&apos;2019-07-01 12:43:06.946 INFO 1984 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet &apos;dispatcherServlet&apos;2019-07-01 12:43:06.951 INFO 1984 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 5 ms2019-07-01 12:43:07.218 INFO 1984 --- [nio-8080-exec-7] io.lettuce.core.EpollProvider : Starting without optional epoll library2019-07-01 12:43:07.218 INFO 1984 --- [nio-8080-exec-7] io.lettuce.core.KqueueProvider : Starting without optional kqueue library2019-07-01 12:43:07.701 INFO 1984 --- [nio-8080-exec-7] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting...2019-07-01 12:43:07.791 INFO 1984 --- [nio-8080-exec-7] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Start completed.2019-07-01 12:43:07.805 DEBUG 1984 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 12:43:07.815 DEBUG 1984 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 12:43:07.836 DEBUG 1984 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 7Process finished with exit code -1 清除Redis缓存当执行添加,更新和删除操作后,数据库中的数据会发生变化,继而Redis缓存中的数据同样也需要进行相应的变化,为了保证Redis缓存中的数据与数据库中的一致,通常需要在执行添加,更新和删除操作之前清除缓存,然后再下一次执行查询操作时,将新的数据存储到Redis缓存中 . 若要实现清除缓存的功能,只需在相应的方法中使用@CacheEvict注解即可,下面以案例程序中的删除用户功能为例,在用户业务逻辑类的deleteUser()方法上添加@CacheEvict注解 :12345@Override@CacheEvict(value = \"UserCatch\", key = \"'user.selectAll'\")public void delete(Integer id) &#123; userMapper.deleteById(id);&#125; 重启Spring Boot项目,在浏览器地址栏中输入访问地址 : http://localhost:8080/user/deleteUser/5, ../6 , ../7删除id为5,6,7的用户信息后再查询用户列表信息 : http://localhost:8080/userList.html,其控制台打印的日志信息如下 :12345678910111213141516171819202019-07-01 18:13:45.143 DEBUG 14764 --- [nio-8080-exec-1] p.h.redis.dao.UserMapper.deleteById : ==&gt; Preparing: Delete from tb_user where id = ? 2019-07-01 18:13:45.160 DEBUG 14764 --- [nio-8080-exec-1] p.h.redis.dao.UserMapper.deleteById : ==&gt; Parameters: 5(Integer)2019-07-01 18:13:45.162 DEBUG 14764 --- [nio-8080-exec-1] p.h.redis.dao.UserMapper.deleteById : &lt;== Updates: 12019-07-01 18:13:45.331 INFO 14764 --- [nio-8080-exec-1] io.lettuce.core.EpollProvider : Starting without optional epoll library2019-07-01 18:13:45.332 INFO 14764 --- [nio-8080-exec-1] io.lettuce.core.KqueueProvider : Starting without optional kqueue library2019-07-01 18:15:16.033 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.deleteById : ==&gt; Preparing: Delete from tb_user where id = ? 2019-07-01 18:15:16.033 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.deleteById : ==&gt; Parameters: 6(Integer)2019-07-01 18:15:16.034 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.deleteById : &lt;== Updates: 12019-07-01 18:15:31.217 DEBUG 14764 --- [nio-8080-exec-6] p.h.redis.dao.UserMapper.deleteById : ==&gt; Preparing: Delete from tb_user where id = ? 2019-07-01 18:15:31.218 DEBUG 14764 --- [nio-8080-exec-6] p.h.redis.dao.UserMapper.deleteById : ==&gt; Parameters: 7(Integer)2019-07-01 18:15:31.219 DEBUG 14764 --- [nio-8080-exec-6] p.h.redis.dao.UserMapper.deleteById : &lt;== Updates: 12019-07-01 18:15:47.353 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: Select * from tb_user 2019-07-01 18:15:47.353 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 18:15:47.377 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 4Process finished with exit code -1","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring Boot之文件上传与下载","slug":"Spring-Boot之文件上传","date":"2019-06-30T13:22:23.000Z","updated":"2019-08-25T06:31:01.036Z","comments":true,"path":"2019/06/30/Spring-Boot之文件上传/","link":"","permalink":"http://yoursite.com/2019/06/30/Spring-Boot之文件上传/","excerpt":"","text":"学习笔记 : Spring Boot之文件上传关键字 : Servlet 3.0 、 SpringMVC 、 Spring Boot 简介前天使用Sprint Boot开发了一个基于SSM框架的项目,一个简单的好友备忘录,该项目地址 : https://github.com/YUbuntu0109/SpringBoot-CURD-Memo ,在该项目中除了基本的CURD,还添加了上传用户头像的功能哟~ 以至于在写此功能时发现了Spring Boot在上传文件时不同于Spring MVC的一个细节问题 : 头像被上传到非预期路径下! 注 : Spring Boot启动时会创建一个/tmp/tomcat.xxxxxx/work/Tomcat/localhost/ROOT的临时目录作为文件上传的临时目录,但是该目录会在10天之后被系统自动清理掉 !` 继而程序抛出如下异常信息 :12java.io.IOException: java.io.FileNotFoundException:/tmp/tomcat.273391201583741210.8080/work/Tomcat/localhost/ROOT/upload/portrait/myportrait.jpg (No such file or directory)... 异常分析upload/portrait是我用于存储头像的项目目录,而transferTo(File dest)方法预期写入的文件路径为/tmp/tomcat.273391201583741210.8080/work/Tomcat/localhost/ROOT/upload/portrait/,我们并没有创建该目录,因此会抛出此异常信息 ! 问题分析为什么会这样呢 ? 相对路径-预期路径应该是项目路径/tmp/source/,但是报错确是一个系统临时文件路径,由于是写入文件时报错,继而我们来查看一下transferTo(File dest)的源码吧 : 12345678910111213141516171819202122232425package org.apache.catalina.core;//....../** * Adaptor to allow &#123;@link FileItem&#125; objects generated by the package renamed * commons-upload to be used by the Servlet 3.0 upload API that expects * &#123;@link Part&#125;s. */public class ApplicationPart implements Part &#123; //...... @Override public void write(String fileName) throws IOException &#123; File file = new File(fileName); if (!file.isAbsolute()) &#123; file = new File(location, fileName); &#125; try &#123; fileItem.write(file); &#125; catch (Exception e) &#123; throw new IOException(e); &#125; &#125;&#125; 由源码可知,在使用Servlet3.0支持的上传文件功能时,若我们没有使用绝对路径,transferTo(File dest)方法会在相对路径前添加一个location路径 ! 继而影响了SpringMVC的MultipartFile的使用 . 解决方案使用绝对路径通过ResourceUtils.getURL(&quot;classpath:&quot;).getPath()获取项目的绝对路径,为防止项目路径中含有空格等特殊字符继而乱码,可以通过URLDecoder.decode(String s, Charset charset)对其进行解码.1234//项目下存储头像的目录private final String uploadPath = \"/static/upload/friend_portrait/\";//指定存储头像目录的完整路径(项目发布路径):若不使用绝对路径,则Spring boot会默认将上传的文件存储到临时目录中String dirPath = URLDecoder.decode(ResourceUtils.getURL(\"classpath:\").getPath(), StandardCharsets.UTF_8) + uploadPath; 注 : 当我们使用ClassLoader()的getResource()方法获取路径时,获取到的路径是已被URLEncoder.encode(path,&quot;utf-8&quot;)编码了的,当路径中存在中文和空格时,它会对这些字符进行转换,继而得到的往往不是我们想要的真实路径,所以我们可以调用URLDecoder.decode(String s, Charset charset)方法进行解码,以便得到原始的中文及空格路径. 发送的时候使用encode(String s, Charset charset)编码,接收的时候使用URLDecoder.decode(String s, Charset charset)解码,按指定的编码格式进行编码、解码,可以保证不会出现乱码哟 ~12345//使用指定的编码机制将字符串转换为 application/x-www-form-urlencoded 格式URLEncoder.encode(String s, Charset charset)//使用指定的编码机制对 application/x-www-form-urlencoded 字符串解码URLDecoder.decode(String s, Charset charset) 修改location的值location可以理解为临时文件目录,可以通过配置location的值,使其指向我们的项目路径,继而来解决此问题. 只需在Spring Boot启动类中添如下代码 :123456 @Bean MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); factory.setLocation(\"/app/pttms/tmp\"); return factory.createMultipartConfig();&#125; 示例程序该上传文件的示例程序摘自我的Sping Boot-好友备忘录小项目,程序中使用绝对路径方案来解决上述问题,该程序具有参考与学习价值哟~ FriendController.java : 好友信息控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.haungyuhui.memo.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.stereotype.Controller;import org.springframework.util.ResourceUtils;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import pers.haungyuhui.memo.bean.Friend;import pers.haungyuhui.memo.service.FriendService;import pers.haungyuhui.memo.util.UploadFile;import javax.annotation.Resource;import java.io.FileNotFoundException;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @project: memo * @description: 控制器-管理好友信息页面 * @author: 黄宇辉 * @date: 6/28/2019-8:25 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controller@RequestMapping(\"/memo\")public class StudentController &#123; //...... //项目下存储头像的目录,需放在静态资源'static'目录下哟 private final String uploadPath = \"/static/upload/friend_portrait/\"; /** * @description: 上传头像-原理:将头像上传到项目发布目录中,通过读取数据库中的头像路径来显示头像 * @param: photo * @param: request * @date: 2019-06-29 4:20 PM * @return: java.util.Map&lt;java.lang.String, java.lang.Object&gt; */ @PostMapping(\"/uploadPhoto\") @ResponseBody public Map&lt;String, Object&gt; uploadPhoto(MultipartFile photo) throws FileNotFoundException &#123; //指定存储头像目录的完整路径(项目发布路径): 若不使用绝对路径,则Spring boot会默认将上传的文件存储到临时目录中 String dirPath = URLDecoder.decode(ResourceUtils.getURL(\"classpath:\").getPath(), StandardCharsets.UTF_8) + uploadPath; //返回头像的上传结果 return UploadFile.getUploadResult(photo, dirPath, uploadPath); &#125;&#125; UploadFile.java : 上传文件的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package pers.haungyuhui.memo.util;import org.apache.commons.io.filefilter.SuffixFileFilter;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.UUID;/** * @project: memo * @description: 上传文件工具类 * @author: 黄宇辉 * @date: 6/29/2019-9:38 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class UploadFile &#123; //限制头像大小最大为20M private static final int MAX_SIZE = 20971520; //存储文件上传失败的错误信息 private static Map&lt;String, Object&gt; error_result = new HashMap&lt;&gt;(); //存储头像的上传结果信息 private static Map&lt;String, Object&gt; upload_result = new HashMap&lt;&gt;(); //指定上传文件的类型 private static final String[] suffixs = new String[]&#123;\".png\", \".PNG\", \".jpg\", \".JPG\", \".jpeg\", \".JPEG\", \".gif\", \".GIF\", \".bmp\", \".BMP\"&#125;; /** * @description: 效验所上传图片的大小及格式等信息... * @param: photo * @param: path * @date: 2019-06-29 9:40 AM * @return: java.util.Map&lt;java.lang.String, java.lang.Object&gt; */ private static Map&lt;String, Object&gt; uploadPhoto(MultipartFile photo, String path) &#123; //若存储文件的目录路径不存在,则创建该目录 File filePath = new File(path); if (!filePath.exists()) &#123; filePath.mkdirs(); &#125; //限制上传文件的大小 if (photo.getSize() &gt; MAX_SIZE) &#123; error_result.put(\"success\", false); error_result.put(\"msg\", \"上传的图片大小不能超过20M哟!\"); return error_result; &#125; // 限制上传的文件类型 SuffixFileFilter suffixFileFilter = new SuffixFileFilter(suffixs); if (!suffixFileFilter.accept(new File(path + photo.getOriginalFilename()))) &#123; error_result.put(\"success\", false); error_result.put(\"msg\", \"禁止上传此类型文件! 请上传图片哟!\"); return error_result; &#125; return null; &#125; /** * @description: 获取头像的上传结果信息 * @param: photo * @param: dirPaht * @param: portraitPath * @date: 2019-06-29 9:44 AM * @return: java.util.Map&lt;java.lang.String, java.lang.Object&gt; */ public static Map&lt;String, Object&gt; getUploadResult(MultipartFile photo, String dirPath, String uploadPath) &#123; if (!photo.isEmpty() &amp;&amp; photo.getSize() &gt; 0) &#123; //效验图片-error_result: 存储头像上传失败的错误信息 Map&lt;String, Object&gt; error_result = uploadPhoto(photo, dirPath); if (error_result != null) &#123; return error_result; &#125; //使用UUID重命名图片名称(uuid__原始图片名称) String newPhotoName = UUID.randomUUID() + \"__\" + photo.getOriginalFilename(); //将上传的图片保存到目标目录下 try &#123; photo.transferTo(new File(dirPath + newPhotoName)); //将存储头像的目录路径返回给页面 upload_result.put(\"success\", true); upload_result.put(\"portrait_path\", uploadPath + newPhotoName); &#125; catch (IOException e) &#123; e.printStackTrace(); upload_result.put(\"success\", false); upload_result.put(\"msg\", \"上传文件失败! 服务器端发生异常!\"); return upload_result; &#125; &#125; else &#123; upload_result.put(\"success\", false); upload_result.put(\"msg\", \"头像上传失败! 未找到指定图片!\"); &#125; return upload_result; &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot项目:好友备忘录","slug":"Spring-Boot项目-好友备忘录","date":"2019-06-30T12:53:09.000Z","updated":"2019-08-26T03:29:48.889Z","comments":true,"path":"2019/06/30/Spring-Boot项目-好友备忘录/","link":"","permalink":"http://yoursite.com/2019/06/30/Spring-Boot项目-好友备忘录/","excerpt":"","text":"A simple project for Spring Boot ~ 我的第一个Spring Boot小项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目的GitHub仓库地址 : https://github.com/YUbuntu0109/springboot-beginner 项目概述👍一个简单的,基于Spring Boot的好友备忘录小项目,通过本项目可以学习Spring Boot与MyBatis的整合及CURD操作的基本思路,同时也可以帮助你学习Thylemeaf模板引擎使用哟 ! 该项目的代码注释详细,逻辑结构清晰,非常具有参考,学习价值哟 ! 可以说非常适合初学Sping Boot的同学啦(っ•̀ω•́)っ✎⁾⁾~ 💗为了让更多同学快速地体验该项目,已通过mvn package将其打包,并将其作为v1.0上传到了release中~ 项目截图 项目主页面 好友信息管理页面 项目结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374│ .gitattributes│ LICENSE│ README.md│├─database file│ memo.sql│├─demonstration_picture│ SpringBoot-CURD-Memo_FriendListView.PNG│ SpringBoot-CURD-Memo_FriendListView2.PNG│ SpringBoot-CURD-Memo_MainView.PNG│└─memo │ .gitignore │ mvnw │ mvnw.cmd │ pom.xml │ │ └─src └─main ├─java │ └─pers │ └─haungyuhui │ └─memo │ │ MemoApplication.java │ │ │ ├─bean │ │ Friend.java │ │ │ ├─controller │ │ StudentController.java │ │ │ ├─dao │ │ FriendMapper.java │ │ FriendMapper.xml │ │ │ ├─service │ │ │ FriendService.java │ │ │ │ │ └─impl │ │ FriendServiceImpl.java │ │ │ └─util │ UploadFile.java │ └─resources │ application.properties │ ├─static │ ├─easyui │ │ │ jquery.easyui.min.js │ │ │ jquery.min.js │ │ │ │ │ ├─css │ │ │ default.css │ │ │ demo.css │ │ │ │ │ ├─js │ │ │ outlook2.js │ │ │ validateExtends.js │ │ │ │ │ └─themes │ │ │(略..) │ │ │ │ │ │ │ └─image │ default_portrait.png │ └─templates friendList.html intro.html main.html 项目文件说明-Spring boot启动类1MemoApplication.java 项目文件说明-数据库文件1memo.sql 项目文件说明-EasyUI 前端框架1easyui/ 项目文件说明-默认头像1default_portrait.png 🙂 Look forward to your contribution ! If you need any help, please contact me ~ QQ : 3083968068","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://yoursite.com/tags/Thymeleaf/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"Spring Boot之Thymeleaf","slug":"Spring-Boot之Thymeleaf","date":"2019-06-27T03:34:09.000Z","updated":"2019-08-25T06:31:01.033Z","comments":true,"path":"2019/06/27/Spring-Boot之Thymeleaf/","link":"","permalink":"http://yoursite.com/2019/06/27/Spring-Boot之Thymeleaf/","excerpt":"","text":"学习笔记 : Thymeleaf的常用语法简介 : Thymeleaf是一种用于Web和独立环境的现代服务器端的Java模板引擎. Thymeleaf的主要目标是将优雅的自然模板带到开发工作流程中,并将HTML在浏览器中正确显示,并且可以作为静态原型,让开发团队能更容易地协作. Thymeleaf能够处理HTML,XML,JavaScript,CSS甚至纯文本 . 基础语法变量表达式 ${}使用方法 : 直接使用th:xx = &quot;${}&quot;获取对象属性12345678&lt;form id=\"userForm\"&gt; &lt;input id=\"id\" name=\"id\" th:value=\"$&#123;user.id&#125;\"/&gt; &lt;input id=\"username\" name=\"username\" th:value=\"$&#123;user.username&#125;\"/&gt; &lt;input id=\"password\" name=\"password\" th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/form&gt;&lt;div th:text=\"hello\"&gt;&lt;/div&gt;&lt;div th:text=\"$&#123;user.username&#125;\"&gt;&lt;/div&gt; 选择变量表达式 *{}使用方法 : 首先通过th:object获取对象,然后使用`th:xx = “{}”`获取对象属性*12345&lt;form id=\"userForm\" th:object=\"$&#123;user&#125;\"&gt; &lt;input id=\"id\" name=\"id\" th:value=\"*&#123;id&#125;\"/&gt; &lt;input id=\"username\" name=\"username\" th:value=\"*&#123;username&#125;\"/&gt; &lt;input id=\"password\" name=\"password\" th:value=\"*&#123;password&#125;\"/&gt;&lt;/form&gt; 链接表达式 @{}使用方法 : 通过链接表达式@{}直接拿到应用路径,然后拼接静态资源路径12345&lt;!-- 访问项目路径下的user并传递id,name等参数 --&gt;&lt;a th:href=\"@&#123;~/user(id=1,name=demo)&#125;\"&gt;demo&lt;/a&gt; &lt;script th:src=\"@&#123;/webjars/jquery/jquery.js&#125;\"&gt;&lt;/script&gt;&lt;link th:href=\"@&#123;/webjars/bootstrap/css/bootstrap.css&#125;\" rel=\"stylesheet\" type=\"text/css\"&gt; 片段表达式 ~{} ~{viewName} : 表示引入完整页面 ~{viewName ::selector} : 表示在指定页面寻找片段,其中selector可为片段名、jquery选择器等 ~{::selector} : 表示在当前页寻找 使用方法 : 首先通过th:fragment定制片段,然后通过th:replace填写片段路径和片段名123456&lt;!-- /views/common/head.html--&gt;&lt;head th:fragment=\"static\"&gt; &lt;script th:src=\"@&#123;/webjars/jquery/3.3.1/jquery.js&#125;\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;!-- /views/your.html --&gt;&lt;div th:replace=\"~&#123;common/head::static&#125;\"&gt;&lt;/div&gt; 注意 : 由于默认拼接的路径为spring.thymeleaf.prefix = classpath:/templates/,所以在使用替换路径th:replace开头请勿添加斜杠,避免部署运行的时候出现路径报错 ! 消息表达式 &amp;#35;{}即通常的国际化属性 : &amp;#35;{msg},用于获取国际化语言翻译值1&lt;title th:text=\"#&#123;user.title&#125;\"&gt;&lt;/title&gt; 其它表达式在基础语法中,默认支持字符串连接、数学运算、布尔逻辑和三目运算等..1&lt;input name=\"name\" th:value=\"$&#123;'I am '+(user.name!=null?user.name:'NoBody')&#125;\"/&gt; 常用语法迭代循环想要遍历List集合很简单,配合th:each即可快速完成迭代1234&lt;div th:each=\"user:$&#123;userList&#125;\"&gt; 账号: &lt;input th:value=\"$&#123;user.username&#125;\"/&gt; 密码: &lt;input th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/div&gt; 在集合的迭代过程还可以获取状态变量,只需在变量后面指定状态变量名即可,状态变量可用于获取集合的下标/序号、总数、是否为单数/偶数行、是否为第一个/最后一个123456&lt;div th:each=\"user,stat:$&#123;userList&#125;\" th:class=\"$&#123;stat.even&#125;?'even':'odd'\"&gt; 下标: &lt;input th:value=\"$&#123;stat.index&#125;\"/&gt; 序号: &lt;input th:value=\"$&#123;stat.count&#125;\"/&gt; 账号: &lt;input th:value=\"$&#123;user.username&#125;\"/&gt; 密码: &lt;input th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/div&gt; 如果缺省状态变量名,则迭代器会默认帮我们生成以变量名开头的状态变量 xxStat123456&lt;div th:each=\"user:$&#123;userList&#125;\" th:class=\"$&#123;userStat.even&#125;?'even':'odd'\"&gt; 下标：&lt;input th:value=\"$&#123;userStat.index&#125;\"/&gt; 序号：&lt;input th:value=\"$&#123;userStat.count&#125;\"/&gt; 账号：&lt;input th:value=\"$&#123;user.username&#125;\"/&gt; 密码：&lt;input th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/div&gt; 条件判断if语句其语法为 : th:if,通常用于动态页面的初始化123&lt;div th:if=\"$&#123;userList&#125;\"&gt; &lt;div&gt;exist...&lt;/div&gt;&lt;/div&gt; 如果想取反则可以使用unless123&lt;div th:unless=\"$&#123;userList&#125;\"&gt; &lt;div&gt;not exist...&lt;/div&gt;&lt;/div&gt; switch语句其语法中需要th:switch与th:case结合使用,通常用于动态页面的初始化12345&lt;div th:switch=\"$&#123;num&#125;\"&gt; &lt;span th:case=\"1\"&gt;num=1&lt;/span&gt; &lt;span th:case=\"2\"&gt;num=2&lt;/span&gt; &lt;span th:case=\"3\"&gt;num=3&lt;/span&gt;&lt;/div 日期格式化使用默认的日期格式(toString方法)并不是我们预期的格式 : Mon Dec 03 23:16:50 CST 20181&lt;input type=\"text\" th:value=\"$&#123;user.createTime&#125;\"/&gt; 此时可以通过时间工具类&amp;#35;dates来将日期进行格式化为 : 2018-12-03 23:16:501&lt;input type=\"text\" th:value=\"$&#123;#dates.format(user.createTime,'yyyy-MM-dd HH:mm:ss')&#125;\"/&gt; 内联写法 内联写法 : 解决 JS无法获取服务端返回的变量的尴尬 ~ 使用方法 : 标准格式为: [[${xx}]],其可以读取服务端变量,也可以调用内置对象的方法.例如获取用户变量和应用路径:12345&lt;script th:inline=\"javascript\"&gt; var user = [[$&#123;user&#125;]];` var APP_PATH = [[$&#123;#request.getContextPath()&#125;]]; var LANG_COUNTRY = [[$&#123;#locale.getLanguage()+'_'+#locale.getCountry()&#125;]];&lt;/script&gt; 内置对象七大基础对象 ${&amp;#35;ctx} : 上下文对象,可用于获取其它内置对象 ${&amp;#35;vars} : 上下文变量 ${&amp;#35;locale} : 上下文区域设置 ${&amp;#35;request} : HttpServletRequest对象 ${&amp;#35;response} : HttpServletResponse对象 ${&amp;#35;session} : HttpSession对象 ${&amp;#35;servletContext} : ServletContext对象 常用的工具类 &amp;#35;strings :字符串工具类 &amp;#35;lists : List工具类 &amp;#35;arrays : 数组工具类 &amp;#35;sets : Set工具类 &amp;#35;maps : 常用Map方法 &amp;#35;objects : 一般对象类,通常用来判断非空 &amp;#35;bools : 常用的布尔方法 &amp;#35;execInfo : 获取页面模板的处理信息 &amp;#35;messages : 在变量表达式中获取外部消息的方法,与使用&amp;#35;{...}语法获取的方法相同 &amp;#35;uris : 转义部分URL / URI的方法 &amp;#35;conversions : 用于执行已配置的转换服务的方法 &amp;#35;dates : 时间操作和时间格式化等 &amp;#35;calendars : 用于更复杂时间的格式化 &amp;#35;numbers : 格式化数字对象的方法 &amp;#35;aggregates : 在数组或集合上创建聚合的方法 &amp;#35;ids : 处理可能重复的id属性的方法 🙂thanks a lot : https://www.jianshu.com/p/908b48b10702","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot之整合视图层技术","slug":"Spring-Boot之整合视图层技术","date":"2019-06-26T14:33:47.000Z","updated":"2019-08-25T06:31:01.035Z","comments":true,"path":"2019/06/26/Spring-Boot之整合视图层技术/","link":"","permalink":"http://yoursite.com/2019/06/26/Spring-Boot之整合视图层技术/","excerpt":"","text":"学习笔记 : Spring Boot之整合视图层技术简介 : 在目前的企业级应用开发中,前后端分离是趋势,但是视图技术还有一席之地. Spring Boot对视图层技术提供了很好的支持,官方推荐使用的模板引擎是Thymeleaf,也支持FreeMarker哟,需要注意的是Spring Boot官方并不推荐使用JSP技术 ! 整合ThymeleafThymeleaf是新一代模板引擎,类似于Velocity,FreeMarker等传统Java模板引擎.与其不同的是: Thymeleaf支持HTML原型,同时Spring Boot也提供了Thymeleaf自动化配置解决方案. 更多资料见 : https://www.thymeleaf.org/ 配置ThymeleafSpring Boot为Thymeleaf提供了自动化配置类ThymeleafAutoConfiguration,相关的配置信息在ThymeleafProperties类中,其部分源码如下所示 :1234567891011121314@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; ······ 如果需要对默认的Thymeleaf配置参数进行自定义,那么可以直接在application.properties中进行配置哟,常见配置如下:1234567891011121314#是否开启缓存,开发时可设置为false,默认为truespring.thymeleaf.cache=true#检查模板是否存在,默认为truespring.thymeleaf.check-template=true#检查模板位置是否存在,默认为truespring.thymeleaf.check-template-location=true#模板文件编码spring.thymeleaf.encoding=UTF-8#模板文件位置spring.thymeleaf.prefix=classpath:/templates/#Content-Type配置spring.thymeleaf.servlet.content-type=text/html#模板文件后缀spring.thymeleaf.suffix=.html 示例程序 pom.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- lookup parent from repository --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;pers.huangyuhui&lt;/groupId&gt; &lt;artifactId&gt;view&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;view&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Book.java : 图书信息 123456789101112131415161718192021222324package pers.huangyuhui.view.bean;/** * @project: view * @description: 图书信息 * @author: 黄宇辉 * @date: 6/26/2019-9:24 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Book &#123; private Integer id; private String name; private String author; public Book(Integer id, String name, String author) &#123; this.id = id; this.name = name; this.author = author; &#125; //getter and setter ...&#125; BookDao.java : 获取并存储图书信息 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.view.dao;import pers.huangyuhui.view.bean.Book;import java.util.ArrayList;import java.util.List;/** * @project: view * @description: 操控图书信息 * @author: 黄宇辉 * @date: 6/26/2019-9:41 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BookDao &#123; //存储图书信息 private static List&lt;Book&gt; books = new ArrayList&lt;&gt;(); public static List&lt;Book&gt; getBooks() &#123; Book book1 = new Book(1, \"Spring\", \"spring-author\"); Book book2 = new Book(2, \"Spring MVC\", \"springmvc-author\"); Book book3 = new Book(3, \"MyBatis\", \"mybatis-author\"); Book book4 = new Book(4, \"Spring Boot\", \"springboot-author\"); books.add(book1); books.add(book2); books.add(book3); books.add(book4); return books; &#125;&#125; BookController.java : 操控图书信息的控制器 123456789101112131415161718192021222324252627package pers.huangyuhui.view.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;import pers.huangyuhui.view.dao.BookDao;/** * @project: view * @description: 操控图书信息的控制器 * @author: 黄宇辉 * @date: 6/26/2019-9:26 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controllerpublic class BookController &#123; @GetMapping(\"/getBookList\") public ModelAndView books() &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"books\", BookDao.getBooks()); modelAndView.setViewName(\"bookList\"); return modelAndView; &#125;&#125; bookList.html : 展示图书列表信息的页面 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;!-- 导入Thymeleaf的名称空间 --&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图书信息列表页面-Thymeleaf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;图书编号&lt;/td&gt; &lt;td&gt;图书名称&lt;/td&gt; &lt;td&gt;图书作者&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"book:$&#123;books&#125;\"&gt; &lt;td th:text=\"$&#123;book.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;book.name&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;book.author&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 整合FreeMarkerFreeMarker是一个非常古老的模板引擎,可以用在Web环境或者非Web环境中. 与Thymeleaf不同的是FreeMarker需要经过解析才能够在浏览器中展示出来. 更多资料见 : https://freemarker.apache.org/ 配置FreeMarkerSpring Boot对FreeMarker也提供了配置类FreeMarkerAutoConfiguration,相关的配置属性在FreeMarkerProperties中,其部分源码如下所示 :123456789101112@ConfigurationProperties( prefix = \"spring.freemarker\")public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties &#123; public static final String DEFAULT_TEMPLATE_LOADER_PATH = \"classpath:/templates/\"; public static final String DEFAULT_PREFIX = \"\"; public static final String DEFAULT_SUFFIX = \".ftl\"; private Map&lt;String, String&gt; settings = new HashMap(); private String[] templateLoaderPath = new String[]&#123;\"classpath:/templates/\"&#125;; private boolean preferFileSystemAccess = true; ······ 如果需要对默认的FreeMarker配置参数进行自定义,那么可以直接在application.properties中进行配置哟,常见配置如下:1234567891011121314151617181920#HttpServletRequest的属性是否可以覆盖controller中model的同名项spring.freemarker.allow-request-override=false#HttpSession的属性是否可以覆盖controller中的model的同名项spring.freemarker.allow-session-override=false#是否开启缓存spring.freemarker.cache=false#模板文件编码spring.freemarker.charset=UTF-8#是否检查模板位置spring.freemarker.check-template-location=true#Content-type的值spring.freemarker.content-type=text/html#是否将HttpServletRequest中的属性添加到Model中spring.freemarker.expose-request-attributes=false#是否将HttpSession中的属性添加到Model中spring.freemarker.expose-session-attributes=false#模板文件后缀spring.freemarker.suffix=.ftl#模板文件位置spring.freemarker.template-loader-path=classpath:/templates/ 示例程序 Book.java,BookDao.java,BookController.java程序与Thymeleaf示例程序相同,此处略写 … 在pom.xml中需添加FreeMarker依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; bookList.html : 展示图书列表的页面 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图书列表信息页面-FreeMarker&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;图书编号&lt;/td&gt; &lt;td&gt;图书名称&lt;/td&gt; &lt;td&gt;图书作者&lt;/td&gt; &lt;/tr&gt; &lt;!-- 若model中的books不为空并且books中有数据,则遍历books集合 --&gt; &lt;#if books ??&amp;&amp;(books?size&gt;0)&gt; &lt;#list books as book&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/#if&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 整合JSPSpring Boot官方并不推荐使用JSP技术! 但是小哥是个念旧的孩纸,来学习一波呗😁 ~ Book.java,BookDao.java,BookController.java程序与Thymeleaf示例程序相同,此处略写 … 在pom.xml中需添加使用JSP所需的依赖 1234567891011&lt;!-- JSTL --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 用于编译JSP --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; application.properties配置文件中用于解析视图的代码 12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp bookList.jsp : 展示图书列表信息的页面 12345678910111213141516171819202122&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;图书列表信息页面-JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;图书编号&lt;/td&gt; &lt;td&gt;图书名称&lt;/td&gt; &lt;td&gt;图书作者&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;books&#125;\" var=\"book\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 程序运行结果(以上三个示例程序运行结果大同小异哟)","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot之基本Web开发","slug":"Spring-Boot之基本Web开发","date":"2019-06-26T02:11:58.000Z","updated":"2019-08-25T06:31:01.034Z","comments":true,"path":"2019/06/26/Spring-Boot之基本Web开发/","link":"","permalink":"http://yoursite.com/2019/06/26/Spring-Boot之基本Web开发/","excerpt":"","text":"学习笔记 : Spring Boot之基本Web开发@ServletComponentScan的使用在SpringBootApplication上使用@ServletComponentScan注解后,Servlet、Filter、Listener可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册,无需其他代码哟 ! 开发Servlet pom.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- lookup parent from repository --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;io.github.yubuntu0109&lt;/groupId&gt; &lt;artifactId&gt;web-servlet&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;web-servlet&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MyServlet.java : 自定义Servlet 1234567891011121314151617181920212223package pers.huangyuhui.web.servlet;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @project: web-servlet * @description: learn to use the annotation: @ServletComponentScan * @author: 黄宇辉 * @date: 6/26/2019-9:49 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@WebServlet(name = \"MyServlet\", urlPatterns = \"/helloServlet\")public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; System.out.println(\"this's my servlet ~\"); &#125;&#125; WebServletApplication.java : Spring Boot启动类 123456789101112131415package pers.huangyuhui.webservlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;@SpringBootApplication@ServletComponentScanpublic class WebServletApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebServletApplication.class, args); &#125;&#125; 程序运行结果 1this&apos;s my servlet ~ 开发Filter MyFilter.java : 自定义过滤器 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;/** * @project: web-servlet * @description: learn to user annotation: @ServletComponentScan * @author: 黄宇辉 * @date: 6/26/2019-10:30 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@WebFilter(filterName = \"MyFile\", urlPatterns = \"/helloServlet\")public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"this's my filetr !\"); filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 程序运行结果 12this&apos;s my filetr !this&apos;s my servlet ~ 开发Listener MyListener.java : 自定义监听器 12345678910111213141516171819202122232425262728package pers.huangyuhui.web.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;/** * @project: web-servlet * @description: learn to user annotation: @ServletComponentScan * @author: 黄宇辉 * @date: 6/26/2019-10:54 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@WebListener(value = \"MyListenre\")public class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\"this's contextInitialized ~\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\"this's contextDestroyed ~\"); &#125;&#125; 程序运行结果 1234this&apos;s requestInitialized ~this&apos;s my filetr !this&apos;s my servlet ~this&apos;s requestDestroyed ~ 使用Bean注解注册Servlet等组件WebServletApplication.java : Spring Boot启动类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.huangyuhui.web;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletListenerRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import pers.huangyuhui.web.filter.MyFilter;import pers.huangyuhui.web.listener.MyListener;import pers.huangyuhui.web.servlet.MyServlet;@SpringBootApplicationpublic class WebServletApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebServletApplication.class, args); &#125; @Bean //使用@Bean注解注册Servlet public ServletRegistrationBean getServletRegistration() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet()); servletRegistrationBean.addUrlMappings(\"/Bean-helloServlet\"); return servletRegistrationBean; &#125; /*the result: this's my servlet ~ */ @Bean //使用@Bean注解注册Filter public FilterRegistrationBean getFilterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new MyFilter()); filterRegistrationBean.addUrlPatterns(\"/Bean-helloServlet\"); return filterRegistrationBean; &#125; /*the result: this's my filetr ! this's my servlet ~ */ @Bean //使用@Bean注解注册Listener public ServletListenerRegistrationBean getServletListenerRegistrationBean() &#123; return new ServletListenerRegistrationBean(new MyListener()); &#125; /*the result: this's contextInitialized ~ */&#125; 静态资源访问默认策略简介 : Spring Boot默认会过滤所有的静态资源,而静态资源的位置一共有5个,如下所示. 注意: 按照定义的顺序,5个静态资源位置的优先级依次降低! 但是一般情况下,Spring Boot项目不需要webapp目录,所以在第5个”/“可以暂时不考虑哟 ~ classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/pulic/ / 扩 : 如果你使用的是Intellij IDEA开发工具,记得设置目录类型哟 ! 自定义策略如果默认的静态资源过滤策略不能满足开发需求,也可以自定义资源过滤策略,自定义静态资源过滤策略有如下两种方式 : 在配置文件中定义 Java编码定义 第一种方式示例 : 可以在application.properties中直接定义过滤规则(第一行)和静态资源位置(第二行),示例代码如下 :12spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/ 文件的上传简介 : 多数文件上传都是通过表单形式提交给服务器的,因此,要实现文件上传功能就需要提供一个上传文件的表单,而此表单必须满足以下三个条件. form表单的method的属性设置为post form表单的enctype属性设置为multipart/form-data 提供&lt;input type=&quot;file&quot; name=&quot;filename&quot;/&gt;的文件上传输入框 在Spring Boot中可以根据需要在application.properties中对上传的文件进行详细的配置,示例代码如下 :123456spring.servlet.multipart.enabled=truespring.servlet.multipart.file-size-threshold=0spring.servlet.multipart.location=D://upload//photospring.servlet.multipart.max-file-size=5MBspring.servlet.multipart.max-request-size=10MBspring.servlet.multipart.resolve-lazily=false 第一行: 设置是否开启文件上传支持,默认为true 第二行: 设置文件写入磁盘的阈值,默认为0 第三行: 指定上传文件的临时保存位置 第四行: 设置上传的单个文件的最大大小,默认为1MB 第五行: 设置多文件上传时文件的总大小,默认为10MB 第六行: 设置文件是否延迟解析,默认为false 示例程序upload.html : 上传文件页面123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 验证表单信息 --&gt; &lt;script type=\"text/javascript\"&gt; function check() &#123; var file = document.getElementById(\"file\").value; if (file.length === 0 || file === \"\") &#123; alert(\"请选择需要上传的文件 !\"); return false; &#125; return true; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"../fileUpload\" method=\"post\" enctype=\"multipart/form-data\" onsubmit=\"return check()\"&gt; 请选择文件 &lt;input id=\"file\" type=\"file\" name=\"uploadfile\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FileController.java : 操控文件的控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pers.huangyuhui.web.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.util.UUID;/** * @project: web-servlet * @description: 操控文件的控制器 * @author: 黄宇辉 * @date: 6/26/2019-4:34 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@RestControllerpublic class FileController &#123; /** * @description: 上传文件 * @param: uploadfile * @param: request * @date: 2019-06-26 5:00 PM * @return: java.lang.String */ @RequestMapping(\"/fileUpload\") public String handleFormUpload(MultipartFile uploadfile, HttpServletRequest request) &#123; if (!uploadfile.isEmpty() &amp;&amp; uploadfile.getSize() &gt; 0) &#123; //获取上传文件的原始名称 final String originFileName = uploadfile.getOriginalFilename(); //指定上传文件的保存目录 final String dirPath = request.getServletContext().getRealPath(\"/upload/photo/\"); //若保存文件的目录不存在,则创建该目录 File file = new File(dirPath); if (!file.exists()) &#123; file.mkdirs(); &#125; //使用UUID重命名文件名称(uuid__原始文件名称) final String newFileName = UUID.randomUUID() + \"__\" + originFileName; try &#123; //将上传的文件保存到目标目录下 uploadfile.transferTo(new File(dirPath + newFileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"success to upload the file !\"; &#125; return \"fail to upload the file !\"; &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Hi Redis ~","slug":"Hi-Redis","date":"2019-06-25T08:13:48.000Z","updated":"2019-08-25T06:31:00.964Z","comments":true,"path":"2019/06/25/Hi-Redis/","link":"","permalink":"http://yoursite.com/2019/06/25/Hi-Redis/","excerpt":"","text":"学习笔记 : 拥抱Redis ~简介 : Redis(REmote DIctionary Server)是一个非常流行的基于内存的轻量级键值数据库(key-value database). 严格的说与其把Redis称为一种数据库,不如把它称为一种数据服务器更为恰当(https://matt.sh/thinking-in-redis-part-one). Redis原生地在内存中实现了多种类型的数据结构,并提供了操作这些数据结构的多种API. 更加重要的是,作为一个需要长期运行的数据库存储服务,Redis还提供了高性能命令处理,高可靠性/扩展性的架构及数据持久化等特性 . 微软开源技术小组(Microsoft Open Technologies group)曾经维护了一个Windows的Redis发行版(😅小哥的联想小新潮中Ubuntu系统好久没玩过了啊,要不先在Windows系统下学习Redis吧, (#→⌒→)都是借口,大懒蛋 ~) : https://github.com/microsoftarchive/redis/releases Windows-Redis安装文件说明 redis.windows.conf —redis的配置文件:将redis作为普通软件使用的配置 redis.windows-service.conf —redis的配置文件:将redis作为系统服务的配置 redis-benchmark.exe —测试工具:测试redis的读写性能情况 redis-check-aof.exe —aof 修复检查日志 redis-cli.exe —redis客户端程序 redis-server.exe —redis服务器程序 Redis临时服务 进入Redis安装包目录,启动Redis临时服务的命令为 : redis-server redis.windows.conf ,通过该命令可以创建Redis临时服务,既Services列表中不会出现Redis的服务名及其状态,关闭从此窗口既关闭Redis服务. 1234567891011121314151617181920212223E:\\MS-Redis\\Redisλ redis-server.exe redis.windows.conf _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.100 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 3796 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos;[3796] 25 Jun 17:20:55.403 # Server started, Redis version 3.2.100[3796] 25 Jun 17:20:55.403 * DB loaded from disk: 0.000 seconds[3796] 25 Jun 17:20:55.403 * The server is now ready to accept connections on port 6379 启动Redis服务后再开启一个cmder窗口,运行客户端程序 123456E:\\MS-Redis\\Redisλ redis-cli.exe # 运行客户端程序的命令127.0.0.1:6379&gt; set firstKey HelloRedis~OK127.0.0.1:6379&gt; get firstKey&quot;HelloRedis~&quot; Redis默认服务安装进入Redis安装包目录,执行将Redis注册为服务的命令,执行该命令后Services列表中将出现Redis服务,但此时该服务并非启动状态,需要执行Redis启动命令来启动服务,启动服务后,即可运行客户端程序哟 ~12345678910111213141516171819202122E:\\MS-Redis\\Redis λ redis-server --service-install redis.windows.conf # 将Redis注册为服务的命令E:\\MS-Redis\\Redisλ redis-server --service-start # 启动服务命令[18704] 25 Jun 17:55:33.957 # Redis service successfully started.E:\\MS-Redis\\Redisλ redis-cli.exe # 运行客户端程序的命令127.0.0.1:6379&gt; set firstKey helloRedis~OK127.0.0.1:6379&gt; get firstKey&quot;helloRedis~&quot;127.0.0.1:6379&gt; exit # 退出E:\\MS-Redis\\Redisλ redis-server --service-stop # 停止命令命令[7784] 25 Jun 18:09:43.467 # Redis service successfully stopped.E:\\MS-Redis\\Redisλ redis-server --service-uninstall # 卸载服务命令[11968] 25 Jun 18:13:44.417 # Redis service successfully uninstalled. 参考书籍 : Redis 4.x CookBook ——黄鹏程,王左非 · 著","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Hi Spring Boot ~","slug":"Hi-Spring-Boot","date":"2019-06-23T14:18:06.000Z","updated":"2019-08-25T06:31:00.967Z","comments":true,"path":"2019/06/23/Hi-Spring-Boot/","link":"","permalink":"http://yoursite.com/2019/06/23/Hi-Spring-Boot/","excerpt":"","text":"学习笔记 : 拥抱Spring Boot简介 : 随着注解的功能增强,尤其是Servlet 3.0规范的提出,Web容器可以脱离web.xml的部署,使得Web容器完全可以基于注解开发,对于Spring 3.x和Spring 4.x的版本注解功能越来越强大,对于XML的依赖越来越少,到了4.x的版本后甚至可以完全脱离XML,因此在Spring中使用注解开发占据了主流的地位. 于此同时,Pivotal团队在原有Spring基础上主要通过注解的方式继续简化了Spring框架的开发,他们基于Spring框架开发了Spring Boot,所以Spring Boot并非是代替Spring框架,而是让Spring框架更加容易使用哟 ~ Spring Boot的优点 创建独立的Spring应用程序 嵌入的Tomcat,Jetty或Undertow,无须部署WAR文件 允许通过Maven来根据需要获取starter 尽可能地自动配置Spring 提供生产就绪型功能,如指标,健康检查和外部配置 绝对没有代码生成,对XML没有要求配置 第一个Spring Boot程序 DemoApplication.java : Spring boot启动类 12345678910111213package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; MyController.java : Spring mvc控制器 123456789101112131415161718192021package com.example.demo.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @project: first-spring-boot * @description: 自定义控制器 * @author: 黄宇辉 * @date: 6/23/2019-9:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@RestControllerpublic class MyController &#123; @GetMapping(\"/hello\") public String hello() &#123; return \"Hi Spring Boot! it's so simple ~\"; &#125;&#125; 启动项目的方式有三种,如下所示. 启动成功后在浏览器中输入:http://localhost:8080/hello即可看到如下图的运行结果. 使用Maven命令运行项目 : mvn spring-boot:run 直接运行DemoApplication.java中的main方法 打包运行 : 将Spring boot打成jar包后使用mvn package运行 推荐书籍 深入浅出Spring Boot 2.x ——杨开振 · 著 Spring Boot+Vue全栈开发实战 ——王松 · 著","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"How to support full Unicode in MySQL databases","slug":"How-to-support-full-Unicode-in-MySQL-databases","date":"2019-06-23T00:28:41.000Z","updated":"2019-08-25T06:31:00.979Z","comments":true,"path":"2019/06/23/How-to-support-full-Unicode-in-MySQL-databases/","link":"","permalink":"http://yoursite.com/2019/06/23/How-to-support-full-Unicode-in-MySQL-databases/","excerpt":"","text":"How to support full Unicode in MySQL databases · Mathias Bynens😂Alternative title: The things we do to store U+1F4A9 PILE OF POO (💩) correctly. Are you using MySQL’s utf8 charset in your databases? In this write-up I’ll explain why you should switch to utf8mb4 instead, and how to do it. UTF-8The UTF-8 encoding can represent every symbol in the Unicode character set, which ranges from U+000000 to U+10FFFF. That’s 1,114,112 possible symbols. (Not all of these Unicode code points have been assigned characters yet, but that doesn’t stop UTF-8 from being able to encode them.) UTF-8 is a variable-width encoding; it encodes each symbol using one to four 8-bit bytes. Symbols with lower numerical code point values are encoded using fewer bytes. This way, UTF-8 is optimized for the common case where ASCII characters and other BMP symbols (whose code points range from U+000000 to U+00FFFF) are used — while still allowing astral symbols (whose code points range from U+010000 to U+10FFFF) to be stored. MySQL’s utf8For a long time, I was using MySQL’s utf8 charset for databases, tables, and columns, assuming it mapped to the UTF-8 encoding described above. By using utf8, I’d be able to store any symbol I want in my database — or so I thought. While writing about JavaScript’s internal character encoding, I noticed that there was no way to insert the U+1D306 TETRAGRAM FOR CENTRE (𝌆) symbol into the MySQL database behind this site. The column I was trying to update had the utf8_unicode_ci collation, and the connection charset was set to utf8. 123456789101112131415# just to emphasize that the connection charset is set to `utf8`mysql&gt; SET NAMES utf8; Query OK, 0 rows affected (0.00 sec)mysql&gt; UPDATE database_name.table_name SET column_name = &apos;foo𝌆bar&apos; WHERE id = 9001;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; SELECT column_name FROM database_name.table_name WHERE id = 9001;+-------------+| column_name |+-------------+| foo |+-------------+1 row in set (0.00 sec) The content got truncated at the first astral Unicode symbol, in this case 𝌆 — so, attempting to insert foo𝌆bar actually inserted foo instead, resulting in data loss (and possibly introducing security issues; see below). MySQL returned a warning message, too: 1234567mysql&gt; SHOW WARNINGS;+---------+------+------------------------------------------------------------------------------+| Level | Code | Message |+---------+------+------------------------------------------------------------------------------+| Warning | 1366 | Incorrect string value: &apos;\\xF0\\x9D\\x8C\\x86&apos; for column &apos;column_name&apos; at row 1 |+---------+------+------------------------------------------------------------------------------+1 row in set (0.00 sec) Turns out MySQL’s utf8 charset only partially implements proper UTF-8 encoding. It can only store UTF-8-encoded symbols that consist of one to three bytes; encoded symbols that take up four bytes aren’t supported. Since astral symbols (whose code points range from U+010000 to U+10FFFF) each consist of four bytes in UTF-8, you cannot store them using MySQL’s utf8 implementation. This doesn’t just affect the 𝌆 character, but more important symbols like U+01F4A9 PILE OF POO (💩) as well. In total, that’s 1,048,575 possible code points you can’t use. In fact, MySQL’s utf8 only allows you to store 5.88% ((0x00FFFF + 1) / (0x10FFFF + 1)) of all possible Unicode code points. Proper UTF-8 can encode 100% of all Unicode code points. As shown above, this behavior can lead to data loss, but it gets worse — it can result in security vulnerabilities.MySQL’s utf8 encoding is awkwardly named, as it’s different from proper UTF-8 encoding. It doesn’t offer full Unicode support, which can lead to data loss or security vulnerabilities. MySQL’s utf8mb4Luckily, MySQL 5.5.3 (released in early 2010) introduced a new encoding called utf8mb4 which maps to proper UTF-8 and thus fully supports Unicode, including astral symbols. Switching from MySQL’s utf8 to utf8mb4 Step 1: Create a backupCreate a backup of all the databases on the server you want to upgrade. Safety first! Step 2: Upgrade the MySQL serverUpgrade the MySQL server to v5.5.3+, or ask your server administrator to do it for you. Step 3: Modify databases, tables, and columnsChange the character set and collation properties of the databases, tables, and columns to use utf8mb4 instead of utf8. For each database :ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; For each table :ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; For each column :ALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; (Don’t blindly copy-paste this! The exact statement depends on the column type, maximum length, and other properties. The above line is just an example for a VARCHAR column.)Since utf8mb4 is fully backwards compatible with utf8, no mojibake or other forms of data loss should occur. (But you have a backup, right?) Step 4: Check the maximum length of columns and index keysThis is probably the most tedious part of the whole upgrading process. When converting from utf8 to utf8mb4, the maximum length of a column or index key is unchanged in terms of bytes. Therefore, it is smaller in terms of characters, because the maximum length of a character is now four bytes instead of three. For example, a TINYTEXT column can hold up to 255 bytes, which correlates to 85 three-byte or 63 four-byte characters. Let’s say you have a TINYTEXT column that uses utf8 but must be able to contain more than 63 characters. Given this requirement, you can’t convert this column to utf8mb4 unless you also change the data type to a longer type such as TEXT — because if you’d try to fill it with four-byte characters, you’d only be able to enter 63 characters, but not more. The same goes for index keys. The InnoDB storage engine has a maximum index length of 767 bytes, so for utf8 or utf8mb4 columns, you can index a maximum of 255 or 191 characters, respectively. If you currently have utf8 columns with indexes longer than 191 characters,you will need to index a smaller number of characters when using utf8mb4. (Because of this, I had to change some indexed VARCHAR(255) columns to VARCHAR(191).) Section 10.1.11 of the MySQL 5.5 Reference Manual has some more information on this. Step 5: Modify connection, client, and server character setsIn your application code, set the connection character set to utf8mb4. This can be done by simply replacing any variants of SET NAMES utf8 with SET NAMES utf8mb4. If your old SET NAMES statement specified the collation, make sure to change that as well, e.g. SET NAMES utf8 COLLATE utf8_unicode_ci becomes SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci. Make sure to set the client and server character set as well. I have the following in my MySQL configuration file (/etc/my.cnf):12345678910[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ci You can easily confirm these settings work correctly:12345678910111213141516mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE &apos;character\\_set\\_%&apos; OR Variable_name LIKE &apos;collation%&apos;;+--------------------------+--------------------+| Variable_name | Value |+--------------------------+--------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || collation_connection | utf8mb4_unicode_ci || collation_database | utf8mb4_unicode_ci || collation_server | utf8mb4_unicode_ci |+--------------------------+--------------------+10 rows in set (0.00 sec) As you can see, all the relevant options are set to utf8mb4, except for character_set_filesystem which should be binary unless you’re on a file system that supports multi-byte UTF-8-encoded characters in file names, and character_set_system which is always utf8 and can’t be overridden. Note: The default character set and collation can be configured at some other levels as well. Step 6: Repair and optimize all tablesAfter upgrading the MySQL server and making the necessary changes explained above, make sure to repair and optimize all databases and tables. I didn’t do this right away after upgrading (I didn’t think it was necessary, as everything seemed to work fine at first glance), and ran into some weird bugs where UPDATE statements didn’t have any effect, even though no errors were thrown. You could run the following MySQL queries for each table you want to repair and optimize:123# For each tableREPAIR TABLE table_name;OPTIMIZE TABLE table_name; Luckily, this can easily be done in one go using the command-line mysqlcheck utility:1$ mysqlcheck -u root -p --auto-repair --optimize --all-databases This will prompt for the root user’s password, after which all tables in all databases will be repaired and optimized. SummaryNever use utf8 in MySQL — always use utf8mb4 instead. Updating your databases and code might take some time, but it’s definitely worth the effort. Why would you arbitrarily limit the set of symbols that can be used in your database? Why would you lose data every time a user enters an astral symbol as part of a comment or message or whatever it is you store in your database? There’s no reason not to strive for full Unicode support everywhere. Do the right thing, and use utf8mb4. 🍻 ヾ(￣▽￣)Bye~Bye~ 🙂expressing thanks : https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"SSM项目:学生管理系统","slug":"SSM项目-学生管理系统","date":"2019-06-22T13:48:14.000Z","updated":"2019-08-25T06:31:01.023Z","comments":true,"path":"2019/06/22/SSM项目-学生管理系统/","link":"","permalink":"http://yoursite.com/2019/06/22/SSM项目-学生管理系统/","excerpt":"","text":"a simple student management system , created by SSM framework ~ 我的第二个SSM小项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目地址 : https://github.com/YUbuntu0109/SSM-SMS 项目概述一个基于SSM的学生管理系统 : 代码注释详细,逻辑结构清晰,非常具有参考,学习价值哟 !数据库中默认的管理员身份信息 : 账户名 : 黄宇辉 , 密码 demo0109 用户权限介绍 管理员 : 具有所有管理模块的操控权限 教师 : 仅具有学生信息管理模块的所有权限,且在教师信息管理模块中只具有查询及添加信息的权限 学生 : 仅具有学生信息管理模块的查询及添加信息的权限 项目截图 (管理员身份登录) 用户登录页面 系统主页面 管理员信息管理页面 学生信息管理页面 教师信息管理页面 年级信息管理页面 班级信息管理页面 个人信息管理页面 项目截图 (教师身份登录) 教师仅具有学生信息管理模块的所有权限,且在教师信息管理模块中只具有查询及添加信息的权限 项目截图 (学生身份登录) 学生仅具有学生信息管理模块的查询及添加信息的权限 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149│ .gitattributes│ LICENSE│ README.md│├─database file│ ssm_sms.sql│├─demonstration_picture│ SMS-ClassInfo-view.PNG│ SMS-GradeInfo-view.PNG│ SMS-Login-view.PNG│ SMS-ModifyPwd-view.PNG│ SMS-Student-permission.PNG│ SMS-StudentInfo-view.PNG│ SMS-Teacher-permission.PNG│ SMS-TeacherInfo-view.PNG│ SSM-AdminInfo-view.PNG│ SSM-Main-view.PNG│└─sms │ pom.xml │ ├─.idea │ │(略..) │ │ └─src └─main ├─java │ └─pers │ └─huangyuhui │ └─sms │ ├─bean │ │ Admin.java │ │ Clazz.java │ │ Grade.java │ │ LoginForm.java │ │ Student.java │ │ Teacher.java │ │ │ ├─controller │ │ AdminController.java │ │ ClazzController.java │ │ CommonController.java │ │ GradeController.java │ │ StudentController.java │ │ SystemController.java │ │ TeacherController.java │ │ │ ├─dao │ │ AdminMapper.java │ │ ClazzMapper.java │ │ GradeMapper.java │ │ StudentMapper.java │ │ TeacherMapper.java │ │ │ ├─interceptor │ │ LoginInterceptor.java │ │ │ ├─service │ │ │ AdminService.java │ │ │ ClazzService.java │ │ │ GradeService.java │ │ │ StudentService.java │ │ │ TeacherService.java │ │ │ │ │ └─impl │ │ AdminServiceImpl.java │ │ ClazzServiceImpl.java │ │ GradeServiceImpl.java │ │ StudentServiceImpl.java │ │ TeacherServiceImpl.java │ │ │ └─util │ CreateVerifiCodeImage.java │ UploadFile.java │ ├─resource │ ├─database-conf │ │ c3p0.properties │ │ │ ├─mapper │ │ AdminMapper.xml │ │ ClazzMapper.xml │ │ GradeMapper.xml │ │ StudentMapper.xml │ │ TeacherMapper.xml │ │ │ ├─mybatis-conf │ │ mybatis-config.xml │ │ │ └─spring-conf │ applicationContext.xml │ springmvc-config.xml │ └─webapp │ index.jsp │ ├─image │ └─portrait │ default_admin_portrait.png │ default_student_portrait.png │ default_teacher_portrait.png │ ├─static │ ├─easyui │ │ │ │ │ ├─css │ │ │ │ │ ├─js │ │ │ │ │ └─themes │ │ │ │ │ └─h-ui │ │(略..) │ │ │ └─WEB-INF │ web.xml │ └─view ├─admin │ adminList.jsp │ ├─clazz │ clazzList.jsp │ ├─common │ settings.jsp │ ├─error │ 404.jsp │ 500.jsp │ ├─grade │ gradeList.jsp │ ├─student │ studentList.jsp │ ├─system │ intro.jsp │ login.jsp │ main.jsp │ └─teacher teacherList.jsp 项目文件说明-数据库文件1ssm_sms.sql 项目文件说明-数据库配置信息1c3p0.properties 项目文件说明-H-ui 前端框架1h-ui/ 项目文件说明-EasyUI 前端框架1easyui/ 项目文件说明-Spring 核心配置文件1applicationContext.xml 项目文件说明-Spring MVC 核心配置文件1springmvc-config.xml 项目文件说明-MyBatis 核心配置文件1mybatis-config.xml 项目文件说明-Mapper 接口映射文件1mapper/ 项目文件说明-用户默认头像1portrait/ 数据库ER图:sweat_smile: 数据库设计待优化 : 数据表之间的并没有设置约束关系哟,好尴尬呢··· Jar包依赖关系图","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"SSM整合项目:简易同学录","slug":"SSM整合项目-简易同学录","date":"2019-06-12T11:06:17.000Z","updated":"2019-08-25T06:31:01.021Z","comments":true,"path":"2019/06/12/SSM整合项目-简易同学录/","link":"","permalink":"http://yoursite.com/2019/06/12/SSM整合项目-简易同学录/","excerpt":"","text":"A Simple Alumnn Book 我的第一个SSM小项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目地址 : https://github.com/YUbuntu0109/SSM-CURD-Alumni 项目概述 一个简单的,基于SSM的同学录小项目,通过本项目可以学习SSM的整合及CURD操作的基本思路,同时也可以帮助你学习Intellij IEAD开发利器的使用哟,可以说非常适合初学SSM的同学啦~ 代码注释非常详细,思路也很清晰 :12345678910111213141516171819202122232425262728293031323334 @Autowired //注入业务对象 private FriendService friendService; //存储预返回给页面的对象数据 private Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); /** * @description: 分页查询: 获取所有好友信息,分页后返回给页面 * @param: page 当前页数 * @param: rows 每页行数 * @date: 2019-06-06 10:10 AM * @return: java.util.List&lt;pers.huangyuhui.ssm.crud.bean.Friend&gt; */ @RequestMapping(\"/getFriendList\") @ResponseBody //将Map转化为JSON数据 public Map&lt;String, Object&gt; getFriendlist(Integer page, Integer rows) &#123; //设置每页的记录数 PageHelper.startPage(page, rows); //获取所有好友信息 List&lt;Friend&gt; list = friendService.selectAll(); //封装查询结果 PageInfo&lt;Friend&gt; pageInfo = new PageInfo&lt;&gt;(list); //获取总记录数 long total = pageInfo.getTotal(); //获取当前页数据列表 List&lt;Friend&gt; friendList = pageInfo.getList(); //存储对象数据 result.put(\"total\", total); result.put(\"rows\", friendList); return result; &#125; 项目截图 欢迎页面 好友列表 IDEA截图 目录结构 目录类型(重点呦:IDEA可不同与Eclipse !) Jar包依赖关系 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869└─SSM-CURD-Alumni │ LICENSE │ README.md │ ├─database │ ssm.sql │ ├─demonstration_picture │ Intellij-IDEA-Folder-Alumni.PNG │ Intellij-IDEA-Project-Alumni.PNG │ SSM-CRUD-Alumni-Jar.png │ SSM-CURD-Alumni01.PNG │ SSM-CURD-Alumni02.PNG │ └─ssm_crud2 │ pom.xml │ ssm_crud_alumni.iml │ ├─.idea │ │(略..) │ │ └─src └─main ├─java │ └─pers │ └─huangyuhui │ └─ssm │ └─crud │ ├─bean │ │ Friend.java │ │ │ ├─controller │ │ FriendController.java │ │ │ ├─dao │ │ FriendMapper.java │ │ │ └─service │ │ FriendService.java │ │ │ └─impl │ FriendServiceImpl.java │ ├─resource │ ├─database-conf │ │ c3p0.properties │ │ │ ├─mapper │ │ FriendMapper.xml │ │ │ ├─mybatis-conf │ │ mybatis-config.xml │ │ │ └─spring-conf │ applicationContext.xml │ springmvc-config.xml │ └─webapp │ friendInfo.jsp │ index.jsp │ ├─static │ └─easyui │ │(略..) │ │ └─WEB-INF web.xml 项目结构说明-数据库文件1database/ssm.sql 项目结构说明-数据库配置信息1ssm_crud2/src/main/resource/database-conf/c3p0.properties 项目结构说明-EasyUI Framework1ssm_crud2/src/main/webapp/static/easyui/ 项目结构说明-Spring 核心配置文件1ssm_crud2/src/main/resource/spring-conf/applicationContext.xml 项目结构说明-Spring MVC 核心配置文件1ssm_crud2/src/main/resource/spring-conf/springmvc-config.xml 项目结构说明-MyBatis 核心配置文件1ssm_crud2/src/main/resource/mybatis-conf/mybatis-config.xml 项目结构说明-Mapper 接口映射文件1ssm_crud2/src/main/resource/mapper/FriendMapper.xml","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"Java web项目:学生管理系统","slug":"Java-web项目-学生管理系统","date":"2019-06-12T11:04:40.000Z","updated":"2019-08-26T03:31:36.485Z","comments":true,"path":"2019/06/12/Java-web项目-学生管理系统/","link":"","permalink":"http://yoursite.com/2019/06/12/Java-web项目-学生管理系统/","excerpt":"","text":"Student Information Management System 我的第一个Java web项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目的GitHub仓库地址 : https://github.com/YUbuntu0109/SMS 项目概述项目阶段介绍 第一阶段：+信息管理功能 :white_check_mark: 第二阶段：+成绩管理功能 :x: 用户权限介绍 管理员 : 具有所有管理模块的权限 教师 : 具有学生管理信息模块的所有权限,但在教师信息管理模块中只具有查询并修改个人信息的权限 学生 : 只具有查询并修改个人信息的权限 设置权限的核心示例代码如下 :12345678// 用户权限设置: 如果当前用户类型为教师,则将其权限设置为仅能查询个人信息if (userType == 3) &#123; TeacherInfo currentTeacherInfo = (TeacherInfo) request.getSession().getAttribute(\"userInfo\"); teacherInfo.setId(currentTeacherInfo.getId());&#125;// 获取分页后的教师列表信息List&lt;TeacherInfo&gt; teacherList = teacherDao.getTeacherList(teacherInfo, new Paging(currentPage, pageSize)); 系统截图 登录页面 系统主页 学生信息管理页面 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124│└─student_information_management_system │ │ ├─build │ └─classes │ │ databaseConfig.properties │ │ ├─database │ SMS.sql │ ├─src │ │ databaseConfig.properties │ │ │ └─pers │ └─huangyuhui │ └─sms │ ├─dao │ │ AdminDao.java │ │ BasicDao.java │ │ ClazzDao.java │ │ StudentDao.java │ │ TeacherDao.java │ │ │ ├─filter │ │ LoginFilter.java │ │ │ ├─model │ │ AdminInfo.java │ │ ClazzInfo.java │ │ Paging.java │ │ StudentInfo.java │ │ TeacherInfo.java │ │ │ ├─servlet │ │ ClazzManagementServlet.java │ │ LoginServlet.java │ │ OutVerifiCodeServlet.java │ │ PersonalManagementServlet.java │ │ PhotoServlet.java │ │ StuManagementServlet.java │ │ SysMainInterfaceServlet.java │ │ TeacherManagementServlet.java │ │ │ └─util │ CreateVerifiCodeImage.java │ DbConfig.java │ DbUtil.java │ StringUtil.java │ └─WebContent │ index.jsp │ refresh.jsp │ ├─easyui │ │ │ ├─css │ │ │ ├─js │ │ │ └─themes │ │ ├─h-ui │ │ │ ├─css │ │ │ ├─images │ │ │ ├─js │ │ │ ├─lib │ │ │ └─skin │ │ ├─META-INF │ MANIFEST.MF │ ├─resource │ └─image │ default_portrait.jpg │ └─WEB-INF │ web.xml │ ├─lib │ commons-beanutils-1.8.3.jar │ commons-collections-3.2.1.jar │ commons-fileupload-1.2.1.jar │ commons-io-1.4.jar │ commons-lang-2.5.jar │ commons-logging-1.1.1.jar │ ezmorph-1.0.6.jar │ FilelLoad.jar │ json-lib-2.3-jdk15.jar │ jsonplugin-0.34.jar │ jstl.jar │ mysql-connector-java-8.0.11.jar │ standard.jar │ └─view │ login.jsp │ ├─class │ classList.jsp │ ├─error │ 404.jsp │ 500.jsp │ ├─management │ personalView.jsp │ ├─student │ studentList.jsp │ ├─system │ main.jsp │ welcome.jsp │ └─teacher teacherList.jsp 项目文件说明-数据库文件1SMS.sql 项目文件说明-数据库配置信息1databaseConfig.properties 项目文件说明-H-ui 前端框架1h-ui/ 项目文件说明-EasyUI 前端框架1easyui/ 数据库ER图","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"}]},{"title":"DBUtils","slug":"DBUtils","date":"2019-05-30T09:28:41.000Z","updated":"2019-08-25T06:31:00.957Z","comments":true,"path":"2019/05/30/DBUtils/","link":"","permalink":"http://yoursite.com/2019/05/30/DBUtils/","excerpt":"","text":"学习笔记 : DBUtils工具简介 : 为了更加简单地使用JDBC,Apache组织提供了一个工具类库commons-dbutils,它是操作数据库的一个组件,实现了对JDBC的简单封装,可以在不影响性能的情况下极大地简化JDBC的编码工作量. API 介绍简介 : commons-dbutils的核心是两个类为DbUtils,QueryRunner,和一个接口ResultSetHandler. org.apache.commons.dbutils.DbUtils : 该类主要为如何关闭数据库连接,装载JDBC驱动程序之类的常规工作提供静态方法. org.apache.commons.dbutils.QueryRunner : 该类简化了执行SQL语句的代码,它与ResultSetHandler组合在一起就能完成大部分的数据库操作,大大减少编码量. org.apache.commons.dbutils.ResultSetHandler : 该接口用于处理ResultSet结果集,它可以将结果集中的数据转换为不同的形式. CURE 案例 数据表信息 1234567-- auto-generated definition by Intellij IDEAcreate table user( id int auto_increment primary key, name varchar(15) null, password varchar(20) null) C3P0配置文件 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置: 在没有指定配置时默认使用该配置创建c3p0数据源对象 --&gt; &lt;default-config&gt; &lt;property name=\"user\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"password\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/test?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;30000&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxIdleTime\"&gt;600&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"minPoolSize\"&gt;1&lt;/property&gt; &lt;property name=\"maxStatements\"&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 自定义配置 --&gt; &lt;named-config name=\"yu\"&gt; &lt;property name=\"user\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"password\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/test?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"initiaPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 数据源工具类 1234567891011121314151617181920212223242526272829package pers.huangyuhui.dbutils.utils;import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;/** * @project: dbutils * @package: pers.huangyuhui.dbutils.utils * @description: 创建数据源 * @author: HuangYuhui * @date: 5/31/2019-7:00 PM * @version: 1.0 */public class C3P0Utils &#123; private static DataSource dataSource; //创建数据源 static &#123; dataSource = new ComboPooledDataSource(\"yu\"); &#125; //获取数据源 public static DataSource getDataSource() &#123; return dataSource; &#125;&#125; Java Bean : 存储用户信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pers.huangyuhui.dbutils.bean;/** * @project: dbutils * @package: pers.huangyuhui.dbutils.bean * @description: 用户信息 * @author: HuangYuhui * @date: 5/31/2019-7:13 PM * @version: 1.0 */public class User &#123; private Integer id; private String name; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; DAO层 : 封装数据库的基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package pers.huangyuhui.dbutils.dao;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import pers.huangyuhui.dbutils.bean.User;import pers.huangyuhui.dbutils.utils.C3P0Utils;import javax.sql.DataSource;import java.sql.SQLException;import java.util.List;/** * @project: dbutils * @package: pers.huangyuhui.dbutils * @description: 数据库的基本操作 * @author: HuangYuhui * @date: 5/31/2019-7:07 PM * @version: 1.0 */public class DBUtilsDao &#123; //获取数据源 private static DataSource dataSource = C3P0Utils.getDataSource(); //创建queryRunner对象 private static QueryRunner queryRunner = new QueryRunner(dataSource); //sql private String SQL_SELECT = \"select id,name,password from user where id = ?\"; private String SQL_UPDATE = \"update user set name=?,password=? where id=?\"; private String SQL_INSERT = \"insert into user(name,password) values(?,?)\"; private String SQL_SELECTALL = \"select id,name,password from user\"; private String SQL_DELETE = \"delete from user where id=?\"; // TODO: 6/8/2019 查询所有用户信息 public List selectAll() throws SQLException &#123; //获取用户列表 List&lt;User&gt; list = queryRunner.query(SQL_SELECTALL, new BeanListHandler&lt;User&gt;(User.class)); return list; &#125; // TODO: 6/8/2019 查询单个用户信息 public User select(int id) throws SQLException &#123; //获取用户信息 User user = queryRunner.query(SQL_SELECT, new BeanHandler&lt;&gt;(User.class), new Object[]&#123;id&#125;); return user; &#125; // TODO: 6/8/2019 添加用户信息 public boolean insert(User user) throws SQLException &#123; //判断是否添加成功 int num = queryRunner.update(SQL_INSERT, new Object[]&#123;user.getName(), user.getPassword()&#125;); if (num &gt; 0) &#123; return true; &#125; return false; &#125; // TODO: 6/8/2019 修改用户信息 public boolean update(User user) throws SQLException &#123; int num = queryRunner.update(SQL_UPDATE, new Object[]&#123;user.getName(), user.getPassword(), user.getId()&#125;); if (num &gt; 0) &#123; return true; &#125; return false; &#125; // TODO: 6/8/2019 删除用户信息 public boolean delete(int id) throws SQLException &#123; int num = queryRunner.update(SQL_DELETE, id); if (num &gt; 0) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package pers.huangyuhui.dbutils.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.dbutils.bean.User;import pers.huangyuhui.dbutils.dao.DBUtilsDao;import java.sql.SQLException;import java.util.List;/** * @project: dbutils * @description: 测试数据库的基本操作 * @author: HuangYuhui * @date: 5/31/2019-7:45 PM * @version: 1.0 */public class DBUtilsDaoTest &#123; private static User user; private static DBUtilsDao dbUtilsDao; @BeforeClass public static void init() &#123; user = new User(); dbUtilsDao = new DBUtilsDao(); &#125; @Ignore @Test // TODO: 6/8/2019 测试添加用户操作 public void insertTest() throws SQLException &#123; user.setName(\"YUbuntu0109\"); user.setPassword(\"MyPassword\"); if (dbUtilsDao.insert(user)) &#123; System.out.println(\"success to insert a user information !\"); &#125; else &#123; System.out.println(\"fail to insert a new user information !\"); &#125; &#125; @Ignore @Test // TODO: 6/8/2019 测试修改用户信息操作 public void updateTest() throws SQLException &#123; user.setId(1); user.setName(\"YUbuntu0109-1\"); user.setPassword(\"MyPassword-1\"); if (dbUtilsDao.update(user)) &#123; System.out.println(\"success to update the user information !\"); &#125; else &#123; System.out.println(\"fail to update the user information !\"); &#125; &#125; @Ignore @Test // TODO: 6/8/2019 测试删除用户操作 public void deleteTest() throws SQLException &#123; if (dbUtilsDao.delete(1)) &#123; System.out.println(\"success to delete the user information !\"); &#125; else &#123; System.out.println(\"fail to delete the user information !\"); &#125; &#125; @Ignore @Test // TODO: 6/8/2019 测试查询单个用户信息操作 public void selectTest() throws SQLException &#123; System.out.println(dbUtilsDao.select(1)); &#125; @Ignore @Test // TODO: 6/8/2019 测试查询所有用户信息操作 public void selectAllTest() throws SQLException &#123; List users = dbUtilsDao.selectAll(); System.out.println(users); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"Spring MVC之JSON数据交互","slug":"Spring-MVC之JSON数据交互和RESTful支持","date":"2019-05-28T13:03:53.000Z","updated":"2019-08-25T06:31:01.046Z","comments":true,"path":"2019/05/28/Spring-MVC之JSON数据交互和RESTful支持/","link":"","permalink":"http://yoursite.com/2019/05/28/Spring-MVC之JSON数据交互和RESTful支持/","excerpt":"","text":"学习笔记 : Spring MVC之JSON数据交互JSON 数据交互简介 : JSON(JavaScript Object Notation,JS对象标记) 是一种轻量级的数据交换格式. 它基于JavaScript的一个子集,使用了C,C++,C#,Java,JavaScript,Perl,Python等其它语言的约定,采用完全独立于编程语言的文本格式来存储和表示数据. 这些特性使JSON称为理性的数据交互语言 ! JSON 数据转换简介 : 为了实现浏览器与控制器Controller之间的数据交互,Spring提供了一个HttpMessageConverter&lt;T&gt;接口来完成此项工作. 该接口主要用于将请求消息中的数据转换为一个T的对象,并将类型为T的对象绑定到请求方法的参数中,或者将对象转换为响应消息传递给浏览器显示. Spring为HttpMessageConverter&lt;T&gt;接口提供了很多实现类,这些实现类可以对不同的类型的数据进行信息转换,其中MappingJackson2HttpMessageConverter是Spring MVC默认处理JSON格式请求响应的实现类. 该实现类利用Jackson开源包读写JSON数据,将Java对象转换为JSON对象和XML文档,同时也可以将JSON对象和XML文档转换为Java对象 ! 示例程序 web.xml : 对Spring mvc的前端控制器等信息进行配置 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Spring MVC前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定Spring MVC配置文件的路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 服务器启动后立即加载Spring MVC配置文件 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc-config.xml : Spring mvc配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 定义Spring组件扫描器,指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.controller\"/&gt; &lt;!-- 配置注解驱动 该配置会自动注册RequestMappingHandlerMapping和RequestMappingHandlerAdapter两个Bean, 并提供对读写XML和读写JSON等功能的支持. --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置静态资源的访问路径,此配置中的文件将不被前端控制器所拦截(该目录存放jquery-1.12.4.js) --&gt; &lt;mvc:resources mapping=\"/js/\" location=\"/js/**\"/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; User.java : 用户信息 123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.springmvc.bean;/** * @project: springmvc_json * @package: pers.huangyuhui.springmvc.bean * @description: User information * @author: HuangYuhui * @date: 5/31/2019-1:44 PM * @version: 1.0 */public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"username='\" + username + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; index.jsp : 用于测试JSON交互的页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 5/31/2019 Time: 1:46 PM To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring MVC&lt;/title&gt; &lt;script src=\"js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function testJson() &#123; //用户表单信息 var username = $(\"#username\").val(); var password = $(\"#password\").val(); $.ajax(&#123; url: \"$&#123;pageContext.request.contextPath&#125;/testJson\", type: \"post\", //data:发送的数据 data: JSON.stringify(&#123;username: username, password: password&#125;), //定义发送请求的数据格式为JSON字符串 contentType: \"application/json;charset=UTF-8\", //定义回调响应的数据格式为JSON字符串 dataType: \"json\", //成功响应的结果 success: function (data) &#123; if (data != null) &#123; alert(\"你输入的用户名:\" + username + \"\\n密码:\" + password); &#125; &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; 用户名 &lt;input type=\"text\" name=\"username\" id=\"username\"/&gt;&lt;br&gt; 密码&lt;input type=\"password\" name=\"password\" id=\"password\"&gt;&lt;br&gt; &lt;input type=\"button\" value=\"Test\" onclick=\"testJson()\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; UserController.java : 控制器 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import pers.huangyuhui.springmvc.bean.User;/** * @project: springmvc_json * @package: pers.huangyuhui.springmvc.controller * @description: Controller * @author: HuangYuhui * @date: 5/31/2019-1:39 PM * @version: 1.0 */@Controllerpublic class MyController &#123; /** * @description: 接收页面请求的JSON数据, 并返回JSON格式结果 * @param: user * @date: 2019-06-08 5:34 PM * @return: pers.huangyuhui.springmvc.bean.User */ //@ResponseBody 用于直接返回retrun对象(将Java对象转换为JSON格式的响应数据) //@RequestBody 用于将请求体中的数据绑定到方法的形参上(将JSON格式的请求数据转换为Java对象) @RequestMapping(\"/testJson\") @ResponseBody public User testJson(@RequestBody User user) &#123; //输出接收的JSON格式数据 System.out.println(user); //返回JSON格式的响应 return user; &#125;&#125; 由程序运行的结果(略..)可知,JSON格式的请求数据成功转换为方法中的Java对象,Java对象也成功地转换为了JSON格式的响应数据. RESTful(っ•̀ω•́)っ✎⁾⁾ 略写…(会单独写一个关于RESTful风格的编程笔记哟 ~)","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring MVC之文件上传与下载","slug":"Spring-MVC之文件上传与下载","date":"2019-05-28T13:01:46.000Z","updated":"2019-08-25T06:31:01.057Z","comments":true,"path":"2019/05/28/Spring-MVC之文件上传与下载/","link":"","permalink":"http://yoursite.com/2019/05/28/Spring-MVC之文件上传与下载/","excerpt":"","text":"学习笔记 : Spring MVC之文件的上传与下载文件上传简介 : 多数文件上传都是通过表单形式提交给服务器的,因此,要实现文件长传功能后,就需要提供一个文件上传的表单,而表单必须满足以下三个条件. form表单的method的属性设置为post form表单的enctype属性设置为multipart/form-data 提供&lt;input type=&quot;file&quot; name=&quot;filename&quot;/&gt;的文件上传输入框 当客户端form表单的enctype属性为multipart/form-data时,浏览器就会采用二进制流的方式来处理表单数据,服务器端就会对文件上传的请求进行解析处理. Spring MVC为文件上传提供了支持,这种支持是通过MultipartResolver(多部件解析器)对象实现的. MultipartResolver是一个接口对象,需要通过它的实现类CommonsMultipartResolver来完成文件的上传工作,在需要在spring mvc配置文件中定义MultipartResolver接口的Bean即可,其配置方式如下 : springmvc-config.xml 1234567&lt;!-- 配置文件上传解析器:MultipartResolver --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置请求编码格式 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 设置允许上传文件的最大值(10MB),单位为字节 --&gt; &lt;property name=\"maxUploadSize\" value=\"20971520\"/&gt;&lt;/bean&gt; 注意: 因为MultipartResolver接口的实现类CommonsMultipartResolver内部是引用multipartResolver字符串获取该实现类对象并完成文件解析的,所以在配置CommonsMultipartResolver时必须指定该Bean的id为multipartResolver 文件上传案例 web.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Spring MVC前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定Spring MVC核心配置文件路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使服务器启动后立即加载Spring MVC核心配置文件 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Springmvc-config.xml : Spring MVC核心配置文件 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 定义组件扫描器,指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.file.controller\"/&gt; &lt;!-- 注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 配置文件上传解析器:MultipartResolver --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置请求编码格式 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 设置允许上传文件的最大值(10MB),单位为字节 --&gt; &lt;property name=\"maxUploadSize\" value=\"20971520\"/&gt; &lt;/bean&gt;&lt;/beans&gt; upload.jsp : 文件上传页面 12345678910111213141516171819202122232425262728293031323334353637&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 6/1/2019 Time: 4:01 PM--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;upload file&lt;/title&gt; &lt;!-- 验证表单信息 --&gt; &lt;script type=\"text/javascript\"&gt; function check() &#123; var name = document.getElementById(\"name\").value; var file = document.getElementById(\"file\").value; if (name === \"\") &#123; alert(\"请填写上传人 !\"); return false; &#125; if (file.length === 0 || file === \"\") &#123; alert(\"请选择上传文件 !\"); return false; &#125; return true; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/fileUpload\" method=\"post\" enctype=\"multipart/form-data\" onsubmit=\"return check()\"&gt; 上传人 &lt;input id=\"name\" type=\"text\" name=\"name\" multiple=\"multiple\"/&gt;&lt;br&gt; 请选择文件 &lt;input id=\"file\" type=\"file\" name=\"uploadfile\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FileController.java : 文件上传控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package pers.huangyuhui.file.controller;import org.apache.commons.io.FileUtils;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.List;import java.util.UUID;/** * @project: file * @description: 文件控制器 * @author: HuangYuhui * @date: 6/1/2019-5:17 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controllerpublic class FileController &#123; /** * @description: upload the specified file * @param: name 上传人姓名 * @param: uploadfile 上传文件 * @param: request * @date: 2019-06-08 6:20 PM * @return: java.lang.String */ @RequestMapping(\"/fileUpload\") public String handleFormUpload(String name, List&lt;MultipartFile&gt; uploadfile, HttpServletRequest request) &#123; //判断文件是否存在 if (!uploadfile.isEmpty() &amp;&amp; uploadfile.size() &gt; 0) &#123; //遍历文件 for (MultipartFile files : uploadfile) &#123; //获取上传文件的原始名称 String originFileName = files.getOriginalFilename(); //设置上传文件的保存地址目录 String dirPath = request.getServletContext().getRealPath(\"/upload/\"); System.out.println(dirPath); //如果保存文件的地址不存在,则创建该目录 File file = new File(dirPath); if (!file.exists()) &#123; file.mkdirs(); &#125; //使用UUID重新命名上传的文件名称(上传人_uuid_原始文件名称) String newFileName = name + \"_\" + UUID.randomUUID() + \"_\" + originFileName; try &#123; //使用MultipartFile接口的方法将文件上传保存到目标目录下 files.transferTo(new File(dirPath + newFileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return \"success\"; &#125; return \"error\"; &#125;&#125; 注意: upload文件夹是在项目的发布路径中,而非创建的项目所在路径哟 ! 文件下载简介 : Spring MVC提供了一个ResponseEntity类型的对象,使用它可以很方便地定义返回的HttpHeaders与HttpStatus对象,通过对这两个对象的设置,既可完成下载文件时所需对的配置信息. download.jsp : 文件下载页面 123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 6/1/2019 Time: 7:18 PM--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;%@ page import=\"java.net.URLEncoder\" %&gt;&lt;%@ page import=\"java.nio.charset.StandardCharsets\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/fileDownload?filename=&lt;%=URLEncoder.encode(\"黄宇辉好可耐.jpg\",StandardCharsets.UTF_8)%&gt;\"&gt; 点击下载图片哟!&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; FileController.java : 文件下载控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package pers.huangyuhui.file.controller;import org.apache.commons.io.FileUtils;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.List;import java.util.UUID;/** * @project: file * @description: 文件操作控制器 * @author: HuangYuhui * @date: 6/1/2019-5:17 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controllerpublic class FileController &#123; /** * @description: download the specified file * @param: request * @param: filename * @date: 2019-06-08 6:23 PM * @return: org.springframework.http.ResponseEntity&lt;byte [ ]&gt; */ @RequestMapping(\"/fileDownload\") public ResponseEntity&lt;byte[]&gt; fileDownload(HttpServletRequest request, String filename) throws IOException &#123; //指定要下载的文件的所在路径 String path = request.getServletContext().getRealPath(\"/upload/\"); //创建该文件对象 File file = new File(path + File.separator + filename); //对文件名进行编码,防止中文文件乱码 filename = this.getFileName(request, filename); //设置响应头 HttpHeaders httpHeaders = new HttpHeaders(); //通知浏览器以下载的方式打开文件 httpHeaders.setContentDispositionFormData(\"attachment\", filename); //定义以流的形式下载返回文件数据 //MediaType.APPLICATION_OCTET_STREAM的值为application/octet-stream,既表示以二进制流的形式下载数据 httpHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM); //使用Spring MVC框架的ResponseEntity对象封装返回的下载数据 //HttpStatus类型代表Http协议中的状态,HttpStatus.OK表示200,既服务器已成功处理了请求 return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), httpHeaders, HttpStatus.OK); &#125; /** * @description: 根据浏览器的不同进行编码设置, 返回编码后的文件名 * @param: request * @param: filename * @date: 2019-06-08 6:24 PM * @return: java.lang.String */ public String getFileName(HttpServletRequest request, String filename) throws UnsupportedEncodingException &#123; //IE不同版本的User-Agent中出现的关键字 String[] IEBrowserkeyWords = &#123;\"MSIE\", \"Trident\", \"Edge\"&#125;; //获取请求头代理信息 String userAgent = request.getHeader(\"User-Agent\"); for (String keyWork : IEBrowserkeyWords) &#123; if (userAgent.contains(keyWork)) &#123; //IE内核浏览器,统一设置为UTF-8编码显示 return URLEncoder.encode(filename, StandardCharsets.UTF_8.name()); &#125; &#125; //火狐等其它浏览器统一设置为ISO-8859-1编码显示 return new String(filename.getBytes(StandardCharsets.UTF_8.name()), StandardCharsets.ISO_8859_1.name()); &#125;&#125;","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Database Connection Pool","slug":"Database-Connection-Pool","date":"2019-05-28T12:57:13.000Z","updated":"2019-08-25T06:31:00.958Z","comments":true,"path":"2019/05/28/Database-Connection-Pool/","link":"","permalink":"http://yoursite.com/2019/05/28/Database-Connection-Pool/","excerpt":"","text":"学习笔记 : 数据库连接池简介 : 在JDBC编程中,每次创建和断开Connection对象都会消耗一定的时间和IO资源.为了避免频繁地创建数据库连接,工程师们提出了数据库连接池技术,其负责分配,管理和释放数据库连接,它允许应用程序重复使用现有的数据库连接,而不是重新建立连接 ! DataSource 接口简介 : 为了获取数据库连接对象(Connection),JDBC提供了javax.sql.DataSource接口,它负责与数据库建立连接,并定义了返回值为Connection对象的方法. 人们习惯性地把实现了该接口的类称为数据源,在数据源中存储了所有建立数据库连接的信息. 数据源中包含数据库库连接池,如果数据是水,数据库就是水库,数据源就是连接水库的管道,终端用户看到的数据集是管道里流出来的水. DBCP 数据源简介 : DBCP是数据库连接池(DataBase Connection Pool)的简称,是Apache组织下的开源连接池实现.其jar包中包含两个核心的类,分别是BasicDataSourceFactory和BasicDataSource. BasicDataSource : 为DataSource的实现类,主要包含设置数据源对象的方法. BasicDataSourceFactory : 为创建BasicDataSource对象的工厂类,它主要包含一个返回值为BasicDataSource对象的方法createDataSource(),该方法通过读取配置文件的信息生成数据源对象并返回给调用者. 使用BasicDataSource类创建数据源对象 示例程序如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.dbcp.test;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import javax.sql.DataSource;import org.apache.commons.dbcp2.BasicDataSource;/** * @ClassName: DBCPTest * @Description: 通过BasicDataSource类直接创建数据源对象 * @author: HuangYuhui * @date: May 29, 2019 9:25:36 PM * */public class DBCPTest &#123; private static DataSource dataSource = null; static &#123; // 获取DBCP数据源实现类对象 BasicDataSource basicDataSource = new BasicDataSource(); // 设置连接数据库需要的配置信息 basicDataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); basicDataSource.setUrl(\"jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\"); basicDataSource.setUsername(\"xxxxxx\"); basicDataSource.setPassword(\"xxxxxx\"); // 设置连接池的参数 basicDataSource.setInitialSize(5); dataSource = basicDataSource; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库连接对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 打印数据库连接信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\n\"); &#125;&#125; 程序运行结果如下 123URL : jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/J 通过读取配置文件创建数据源对象 db.properties : 数据源文件12345678#database configuration informationdriverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueusername=xxxxxxpassword=xxxxxx#DBCP configuration informationinitialSize=5maxIdle=10 DBCPTest2.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.dbcp.test;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;/** * @ClassName: DBCPTest2 * @Description: 通过读取配置文件创建数据源对象 * @author: HuangYuhui * @date: May 29, 2019 9:45:15 PM * */public class DBCPTest2 &#123; public static DataSource dataSource = null; static &#123; // 新建一个配置文件对象 Properties properties = new Properties(); // 通过类加载器找到文件路径并读取配置文件 InputStream inputStream = new DBCPTest2().getClass().getClassLoader().getResourceAsStream(\"db.properties\"); try &#123; // 把文件以输入流的形式加载到配置对象中 properties.load(inputStream); // 创建数据源对象 dataSource = BasicDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库连接对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 打印数据库连接信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\nDriver version: \" + databaseMetaData.getDriverVersion()); &#125;&#125; 程序运行结果如下 1234URL : jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/JDriver version : mysql-connector-java-8.0.11 (Revision: 6d4eaa273bc181b4cf1c8ad0821a2227f116fedf) C3P0 数据源简介 : C3P0实现了DataSource数据源接口,支持JDBC2,JDBC3的标准规范,易于扩展并且性能优越,著名的开源框架Hibernate和Spring使用的都是该数据源. C3P0中DataSource接口的实现类为ComboPooledDataSource,它是C3P0的核心类. 使用ComboPooledDataSource类创建数据库源对象 示例程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.c3p0.test;import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * @ClassName: ComboPooledDataSourceTest * @Description: 通过ComboPooledDataSource类直接创建数据源对象 * @author: HuangYuhui * @date: May 29, 2019 10:04:46 PM * */public class ComboPooledDataSourceTest &#123; private static DataSource dataSource = null; // 初始化c3p0数据源 static &#123; ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); try &#123; comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; comboPooledDataSource.setJdbcUrl( \"jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\"); comboPooledDataSource.setUser(\"xxxxxx\"); comboPooledDataSource.setPassword(\"xxxxxx\"); // 设置连接池的参数 comboPooledDataSource.setInitialPoolSize(5); comboPooledDataSource.setMaxPoolSize(15); dataSource = comboPooledDataSource; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库连接对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 输出数据库连接信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\nDriver version: \" + databaseMetaData.getDriverVersion()); &#125;&#125; 程序运行结果如下 1234URL : jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/JDriver version : mysql-connector-java-8.0.11 (Revision: 6d4eaa273bc181b4cf1c8ad0821a2227f116fedf) 通过配置文件创建数据源对象 c3p0-config.xml : 数据源配置文件 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置:在没有指定配置时默认使用该配置创建c3p0数据源对象 --&gt; &lt;default-config&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;GoodTime&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;30000&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"maxIdleTime\"&gt;100&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;100&lt;/property&gt; &lt;property name=\"minPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"maxStatements\"&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 自定义配置 --&gt; &lt;named-config name=\"yu\"&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;GoodTime&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"initiaPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; ComboPooledDataSourceTest2.java : 测试类 12345678910111213141516171819202122232425262728293031323334package pers.huangyuhui.c3p0.test;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class ComboPooledDataSourceTest2 &#123; public static DataSource dataSource = null; // 初始化C3P0数据源 static &#123; // 使用c3p0-config.xml配置文件中的named-config节点中name属性的值 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(\"yu\"); dataSource = comboPooledDataSource; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 输出数据库配置信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\nDriver version: \" + databaseMetaData.getDriverVersion()); &#125;&#125; 程序运行结果 1234URL : jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/JDriver version : mysql-connector-java-8.0.11 (Revision: 6d4eaa273bc181b4cf1c8ad0821a2227f116fedf)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"SSM框架整合","slug":"SSM框架整合","date":"2019-05-23T14:05:49.000Z","updated":"2019-08-25T06:31:01.021Z","comments":true,"path":"2019/05/23/SSM框架整合/","link":"","permalink":"http://yoursite.com/2019/05/23/SSM框架整合/","excerpt":"","text":"学习笔记 : SSM整合整合环境搭建简介 : 由于Spring MVC是Spring框架中的一个模块,所以Spring MVC与Spring之间不存在整合问题,因此SSM整合主要只涉及Spring与MyBatis的整合.下面通过客户id查询数据表中指定的客户信息的简单案例来演示SSM整合思路 ~ 编写配置文件 db.properties : 数据库配置文件 12345678910111213##database configuration information#jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql:xxxxxx?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=xxxxxxjdbc.password=xxxxxx##DBCP configuration#jdbc.maxTotal=30 #最大连接数jdbc.maxIdle=10 #最大空闲连接数jdbc.initialSize=5 #初始化连接数 applicationContext.xml : Spring核心配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=\"maxTotal\" value=\"$&#123;jdbc.maxTotal&#125;\"/&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name=\"maxIdle\" value=\"$&#123;jdbc.maxIdle&#125;\"/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 事务管理器,依赖于数据源 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; &lt;!-- 配置MyBatis工厂: 构建SqlSessionFactory --&gt; &lt;!-- 指定数据源和配置文件: 使得Spring IOC容器在初始化id为sqlSessionFactory的Bean时解析MyBatis的配置文件,并与数据源一同保存到Spring的Bean中 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 指定MyBatis核心配置文件位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 配置mapper扫描器 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.huangyuhui.ssm.dao\"/&gt; &lt;/bean&gt; &lt;!-- 扫描Service --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.ssm.service\"/&gt; &lt;/beans&gt; mybatis-config.xml : MyBatis核心配置文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 通过扫描包的形式定义别名: mybatis会将所有该包中的POJO类以首字母小写的非限定类名来作为它的别名 --&gt; &lt;package name=\"pers.huangyuhui.ssm.po\" /&gt; &lt;/typeAliases&gt; &lt;!-- 配置Mapper --&gt; &lt;mappers&gt; &lt;!-- 使用Mapper接口动态代理开发时,如果完全遵循了编写规范,那么该配置文件中无需以下映射文件 --&gt; &lt;!-- &lt;mapper resource=\"pers/huangyuhui/ssm/dao/CustomerDao.xml\"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;ssm_01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置加载Spring文件的监听器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置Spring MVC前端核心过滤器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置服务器启动后立即加载Spring MVC配置文件 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;!-- 拦截除了jsp外的所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- Spring-context.jar包中提供了通过JMX来实时查看Spring放在applicationContext里的bean列表功能, 其会在项目配置文件里找一个叫`spring.liveBeansView.mbeanDomain`的环境变量,如果没找到, 就会抛出异常:[spring.liveBeansView.mbeanDomain] threw NamingException ... 解决方案: 在项目中的web.xml中添加如下配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;spring.liveBeansView.mbeanDomain&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 整合应用测试上述已经了SSM框架整合环境的搭建工作,接下来开始整合开发工作 ~ t_customer.sql : 客户信息表 12345678create table t_customer ( id INT(20) PRIMARY KEY AUTO_INCREMENT, name VARCHAR(10) NOT NULL, job VARCHAR(10) NOT NULL, phone VARCHAR(12) NOT NULL ) Customer.java : 持久化类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.ssm.po;/** * @ClassName: Customer * @Description: 客户信息 * @author: HuangYuhui * @date: May 25, 2019 11:07:37 AM * */public class Customer &#123; private Integer id; private String name; private String job; private String phone; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Customer [id=\" + id + \", name=\" + name + \", job=\" + job + \", phone=\" + phone + \"]\"; &#125;&#125; CustomerDao.java : Dao层 123456789101112131415161718192021package pers.huangyuhui.ssm.dao;import pers.huangyuhui.ssm.po.Customer;/** * @ClassName: CustomerDao * @Description: TODO * @author: HuangYuhui * @date: May 25, 2019 11:09:22 AM * */public interface CustomerDao &#123; /** * @Title: findCustomerById * @Description: 根据客户id查找客户信息 * @param: id * @return: Customer */ public Customer findCustomerById(Integer id);&#125; CustomerDao.xml : 接口对应的映射文件 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.ssm.dao.CustomerDao\"&gt; &lt;!-- 根据客户id查找客户信息 --&gt; &lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"customer\"&gt; select id,name,job,phone from t_customer where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; CustomerService.java : Service层 12345678910111213141516171819202122package pers.huangyuhui.ssm.service;import pers.huangyuhui.ssm.po.Customer;/** * @ClassName: CustomerService * @Description: TODO * @author: HuangYuhui * @date: May 25, 2019 11:15:26 AM * */public interface CustomerService &#123; /** * * @Title: findCustomerById * @Description: 通过id查找客户信息 * @param: id * @return: Customer */ public Customer findCustomerById(Integer id);&#125; CustomerServiceImpl.java : CustomerService的实现类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.ssm.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import pers.huangyuhui.ssm.dao.CustomerDao;import pers.huangyuhui.ssm.po.Customer;import pers.huangyuhui.ssm.service.CustomerService;/** * @ClassName: CustomerServiceImpl * @Description: CustomerService的实现类 * @author: HuangYuhui * @date: May 25, 2019 11:17:12 AM * */@Service // 标识为业务层的实现类@Transactional // 将类中所有方法都纳入Spring的事物管理public class CustomerServiceImpl implements CustomerService &#123; @Autowired // 将CustomerDao接口对象注入到本类 private CustomerDao customerDao; @Override // 查询客户信息 public Customer findCustomerById(Integer id) &#123; return this.customerDao.findCustomerById(id); &#125;&#125; CustomerController.java : 控制器 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.ssm.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import pers.huangyuhui.ssm.po.Customer;import pers.huangyuhui.ssm.service.CustomerService;/** * @ClassName: CustomerController * @Description: 用于处理页面请求的控制器 * @author: HuangYuhui * @date: May 25, 2019 11:21:39 AM * */@Controller // 标识为控制器public class CustomerController &#123; @Autowired // 将CustomerService接口对象注入到本类 private CustomerService customerService; /** * @Title: findCustomerById * @Description: 通过id查询客户信息 * @param: id * @param: model * @return: String */ @RequestMapping(\"/findCustomerById\") public String findCustomerById(Integer id, Model model) &#123; Customer customer = customerService.findCustomerById(id); model.addAttribute(\"customer\", customer); // 返回客户信息展示页面 return \"customerInfo\"; &#125;&#125; WebContent/WEB-INF/view/customerInfo.jsp : 展示客户信息页面 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;SSM整合案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;客户信息&lt;/h2&gt;&lt;hr/&gt; &lt;table align=\"center\" border=\"1\" &gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;职业&lt;/td&gt; &lt;td&gt;电话&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;$&#123;customer.id &#125;&lt;/td&gt; &lt;td&gt;$&#123;customer.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;customer.job &#125;&lt;/td&gt; &lt;td&gt;$&#123;customer.phone &#125;&lt;/td&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; log4j.properties : 日志文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.ssm.controller=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 将项目发布到Tomcat并启动,在浏览器中访问地址: http://localhost:8080/ssm_01/findCustomerById?id=1,其页面显示效果如下图所示. 由图可知,通过浏览器成功查出了t_customer表中id为1的客户信息.继而证明SSM框架整合成功!ヾ(◍°∇°◍)ﾉﾞ Console输出的主要日志信息如下 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051DispatcherServlet with name &apos;spring_mvc&apos; processing GET request for [/ssm_01/findCustomerById]Looking up handler method for path /findCustomerByIdReturning handler method [public java.lang.String pers.huangyuhui.ssm.controller.CustomerController.findCustomerById(java.lang.Integer,org.springframework.ui.Model)]Returning cached instance of singleton bean &apos;customerController&apos;Last-Modified value for [/ssm_01/findCustomerById] is: -1Creating new transaction with name [pers.huangyuhui.ssm.service.impl.CustomerServiceImpl.findCustomerById]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &apos;&apos;Acquired Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] for JDBC transactionSwitching JDBC Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] to manual commitCreating a new SqlSessionRegistering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]JDBC Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] will be managed by Spring==&gt; Preparing: select id,name,job,phone from t_customer where id = ? ==&gt; Parameters: 2(Integer)&lt;== Total: 1Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Initiating transaction commitCommitting JDBC transaction on Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J]Releasing JDBC Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] after transactionReturning JDBC Connection to DataSourceInvoking afterPropertiesSet() on bean with name &apos;customerInfo&apos;Rendering view [org.springframework.web.servlet.view.InternalResourceView: name &apos;customerInfo&apos;; URL [/WEB-INF/view/customerInfo.jsp]] in DispatcherServlet with name &apos;spring_mvc&apos;Added model object &apos;customer&apos; of type [pers.huangyuhui.ssm.po.Customer] to request in view with name &apos;customerInfo&apos;Added model object &apos;org.springframework.validation.BindingResult.customer&apos; of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name &apos;customerInfo&apos;Forwarding to resource [/WEB-INF/view/customerInfo.jsp] in InternalResourceView &apos;customerInfo&apos;Successfully completed request","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring MVC之拦截器","slug":"Spring-MVC之拦截器","date":"2019-05-23T14:05:26.000Z","updated":"2019-08-25T06:31:01.046Z","comments":true,"path":"2019/05/23/Spring-MVC之拦截器/","link":"","permalink":"http://yoursite.com/2019/05/23/Spring-MVC之拦截器/","excerpt":"","text":"学习笔记 : Spring MVC之拦截器简介 : Spring MVC中的拦截器(Interceptor)类似于Servlet中的过滤器(Filter),主要用于拦截用户请求并做相应的处理,例如通过拦截器可以进行权限验证,记录请求信息的日志,判断用户是否登录等..要使用Spring MVC中的拦截器,就需要对拦截器类进行定义和配置,通常拦截器类可以通过两种方式来定义,如下所示 : 实现HandlerInterceptor接口,或继承HandlerInterceptor接口的实现类,如HandlerInterceptorAdapter. 实现WebRequestInterceptor接口,或继承WebRequestInterceptor接口的实现类. 拦截器的执行流程单个拦截器的执行流程 web.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;springmvc_filter&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;!-- 设置前端过滤器 --&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化时加载配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 容器启动时立即加载Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; CustomInterceptor.java : 自定义拦截器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;/** * @ClassName: CustomInterceptor * @Description: 拦截器 * @author: HuangYuhui * @date: May 23, 2019 9:23:19 PM * */public class CustomInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"------ this is preHandle1 ------\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"------ this is postHandle1 ------\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"------ this is afterCompletion1 ------\"); &#125;&#125; springmvc-config.xml : Spring MVC配置文件 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.filter.controller\" /&gt; &lt;!-- 定义视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\" /&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 配置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 拦截所有请求 --&gt; &lt;bean class=\"pers.huangyuhui.springmvc.filter.interceptor.CustomInterceptor\" /&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; MyController.java : 控制器 1234567891011121314151617181920212223242526272829package pers.huangyuhui.springmvc.filter.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @ClassName: MyController * @Description: 控制器 * @author: HuangYuhui * @date: May 23, 2019 9:20:31 PM * */@Controller@RequestMapping(\"/myFilter\")public class MyController &#123; /** * @Title: singleFilter * @Description: 测试单个拦截器的执行流程 * @return: String */ @RequestMapping(\"/singleFilter\") public String singleFilter() &#123; System.out.println(\"test my filter ~\"); return \"index\"; &#125;&#125; 新建WebContent/WEB-INF/view/index.jsp(仅测试) 将项目发布到Tomcat服务器并启动,在浏览器中访问地址: http://localhost:8080/springmvc_filter/myFilter/singleFilter 即可得到程序运行结果,如下所示 : 1234------ this is preHandle1 ------test my filter ~------ this is postHandle1 ------------ this is afterCompletion1 ------ 多个拦截器的执行流程 web.xml(同上..) CustomInterceptor.java : 第一个自定义拦截器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;/** * @ClassName: CustomInterceptor * @Description: 自定义拦截器 * @author: HuangYuhui * @date: May 23, 2019 9:23:19 PM * */public class CustomInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"------ this is preHandle1 ------\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"------ this is postHandle1 ------\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"------ this is afterCompletion1 ------\"); &#125;&#125; CustomInterceptor2.java : 第二个自定义拦截器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;/** * @ClassName: CustomInterceptor2 * @Description: 自定义拦截器 * @author: HuangYuhui * @date: May 29, 2019 3:46:30 PM * */public class CustomInterceptor2 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"------ this is preHandle2 ------\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"------ this is postHandle2 ------\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"------ this is afterCompletion2------\"); &#125;&#125; springmvc-config.xml : Spring MVC配置文件 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.filter.controller\" /&gt; &lt;!-- 定义视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\" /&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 配置拦截器1 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--拦截所有路径下的请求 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!-- 拦截指定路径的请求 --&gt; &lt;bean class=\"pers.huangyuhui.springmvc.filter.interceptor.CustomInterceptor\" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!-- 配置拦截器2 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"pers.huangyuhui.springmvc.filter.interceptor.CustomInterceptor2\" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; MyController.java : 控制器 12345678910111213141516171819202122232425262728package pers.huangyuhui.springmvc.filter.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @ClassName: MyController * @Description: 控制器 * @author: HuangYuhui * @date: May 23, 2019 9:20:31 PM * */@Controller@RequestMapping(\"/myFilter\")public class MyController &#123; /** * @Title: doubleFilter * @Description: 测试多个拦截器的执行流程 * @return: String */ @RequestMapping(\"/doubleFilter\") public String doubleFilter() &#123; System.out.println(\"test my filter ~\"); return \"index\"; &#125;&#125; 新建WebContent/WEB-INF/view/index.jsp(仅测试) 将项目发布到Tomcat服务器并启动,在浏览器中访问地址: http://localhost:8080/springmvc_filter/myFilter/doubleFilter 即可得到程序运行结果,如下所示 : 1234567------ this is preHandle1 ------------ this is preHandle2 ------test my filter ~------ this is postHandle2 ------------ this is postHandle1 ------------ this is afterCompletion2------------ this is afterCompletion1 ------ 应用案例简介 : 通过拦截器来完成一个用户登录权限验证案例.在本案例中,要求如下 : 只有登录后的用户才能访问系统主页面,如果没有登录系统而直接访问主页面,则其请求会被拦截器所拦截,并转发到登录页面,同时在登录页面提出提示信息. 如果用户名或密码错误,会在登录页面给出相应的提示信息. 当已登录的用户在系统主页中单击”退出”按钮时,系统将会退回到登录页面. web.xml : 略.. User.java : 用户信息 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.springmvc.filter.bean;/** * @ClassName: User * @Description: 用户信息 * @author: HuangYuhui * @date: May 24, 2019 8:43:49 AM * */public class User &#123; private Integer id; private String name; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; login.jsp : 用户登录页面 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;应用案例-实现用户登录权限验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;用户登录页面 ($&#123;msg &#125;)&lt;/h2&gt;&lt;hr&gt; &lt;div align=\"center\"&gt; &lt;form action=\"$&#123;pageContext.request.contextPath &#125;/login\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"50px\"&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div align=\"center\"&gt; &lt;input style=\"margin-left:33px\" type=\"submit\" value=\"登录\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; main.jsp : 系统主页面 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;应用案例-实现用户登录权限验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;用户主页面&lt;/h2&gt;&lt;hr/&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;当前用户 $&#123;USER_SESSION.name &#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"$&#123;pageContext.request.contextPath &#125;/logout\"&gt;退出&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; UserController.java : 控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package pers.huangyuhui.springmvc.filter.controller;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import pers.huangyuhui.springmvc.filter.bean.User;/** * @ClassName: UserController * @Description: 控制器 * @author: HuangYuhui * @date: May 24, 2019 8:45:24 AM * */@Controllerpublic class UserController &#123; /** * @Title: toLogin * @Description: 跳转到用户登录页面 * @param: null * @return: String */ // @RequestMapping(value = \"/login\", method = RequestMethod.GET) @GetMapping(value = \"/login\") // 组合注解 public String toLogin() &#123; return \"login\"; &#125; /** * @Title: login * @Description: 用户登录 * @param: user * @param: model * @param: session * @return: String */ // @RequestMapping(value = \"/login\", method = RequestMethod.POST) @PostMapping(value = \"/login\") public String login(User user, Model model, HttpSession session) &#123; // 获取用户名及密码 String username = user.getName(); String password = user.getPassword(); // 此处模拟从数据库中获取用户名和密码后进行判断 if ((username != null &amp;&amp; username.equals(\"YUbuntu0109\")) &amp;&amp; (password != null &amp;&amp; password.equals(\"demo\"))) &#123; // 将用户对象添加到Sessoin session.setAttribute(\"USER_SESSION\", user); // 重定向到主页面 return \"redirect:main\"; &#125; model.addAttribute(\"msg\", \"用户名或密码错误,请重新登录哟 !\"); return \"login\"; &#125; /** * @Title: toMain * @Description: 跳转到用户主页 * @param: null * @return: String */ @RequestMapping(value = \"/main\") public String toMain() &#123; return \"main\"; &#125; /** * @Title: logout * @Description: 退出登录 * @param: session * @return: String */ @RequestMapping(value = \"/logout\") public String logout(HttpSession session) &#123; // 清除Session session.invalidate(); // 重定向到登录页面 return \"redirect:login\"; &#125;&#125; LoginInterceptor.java : 自定义拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import pers.huangyuhui.springmvc.filter.bean.User;/** * @ClassName: MyInterceptor * @Description: 用户登录拦截器 * @author: HuangYuhui * @date: May 24, 2019 8:59:20 AM * */public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 获取请求的URL String url = request.getRequestURI(); // 除了login.jsp可以公开访问外,其它URL都进行拦截控制 if (url.indexOf(\"/login\") &gt;= 0) &#123; return true; &#125; // 获取Session HttpSession session = request.getSession(); User user = (User) session.getAttribute(\"USER_SESSION\"); // 判断Session中是否有用户数据 if (user != null) &#123; return true; &#125; // 对不符合条件的给出提示信息并转发到登录页面 request.setAttribute(\"msg\", \"你尚未登录,请先登录哟 !\"); request.getRequestDispatcher(\"/WEB-INF/view/login.jsp\").forward(request, response); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"this is postHandle\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"this is afterCompletion\"); &#125;&#125; 将项目发布到Tomcat服务器并启动,在浏览器中访问地址: http://localhost:8080/springmvc_filter/main 其页面如下: 登录成功后,其页面如下 :","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring MVC之数据绑定","slug":"Spring-MVC之数据绑定","date":"2019-05-22T13:25:32.000Z","updated":"2019-08-25T06:31:01.048Z","comments":true,"path":"2019/05/22/Spring-MVC之数据绑定/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring-MVC之数据绑定/","excerpt":"","text":"学习笔记 : Spring MVC之数据绑定简介 : 在执行程序时,Spring MVC会根据客户端请求参数的不同,将请求消息中的信息以一定的方式转换并绑定到控制器类的方法参数中.这种将请求消息与后台方法参数建立连接的过程就是Sping MVC中的数据绑定. 数据绑定介绍在数据绑定过程中,Spring MVC框架会通过数据绑定组件(DataBinder)将请求参数串的内容进行类型转换,然后将和转换后的值赋给控制器类中方法的形参,这样后台就可以正确绑定并获取客户端请求携带的参数了.整个数据绑定过程如下图所示 : 上图信息处理过程的步骤如下 : Spring MVC将ServletsRequest对象传递给DataBinder. 将处理方法的入参对象传递给DataBinder. DataBinder调用ConversionService组件进行数据类型转换,数据格式化等工作,并将ServletRequest对象中的消息填充到参数对象中. 调用Validator组件对已经绑定了请求消息数据的参数对象进行数据合法性效验. 效验完成后生成数据绑定结果BindingResult对象,Spring MVC会将BindingResult对象中的内容赋给处理方法的相应形参.","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"MyBatis与Spring的整合","slug":"MyBatis与Spring的整合","date":"2019-05-22T13:23:28.000Z","updated":"2019-08-25T06:31:01.017Z","comments":true,"path":"2019/05/22/MyBatis与Spring的整合/","link":"","permalink":"http://yoursite.com/2019/05/22/MyBatis与Spring的整合/","excerpt":"","text":"学习笔记 : Spring与MyBatis整合传统DAO方式的开发整合简介 : 采用传统DAO开发方式进行MyBatis与Spring框架的整合时,需要编写DAO接口以及接口的实现类,并且需要向DAO实现类中注入SqlSessionFactory,然后通过SqlSessionFactory创建SqlSession. 下面通过一个使用客户id查询数据表中客户信息的案例来演示该开发方式. customer.sql : 客户信息表 123456789# 客户信息表create table t_customer ( id INT(20) PRIMARY KEY AUTO_INCREMENT, name VARCHAR(10) NOT NULL, job VARCHAR(10) NOT NULL, phone VARCHAR(12) NOT NULL ) db.properties : 数据库配置文件 12345678910111213##database configuration information#jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql:xxxxxx?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=xxxxxxjdbc.password=xxxxxx##DBCP configuration#jdbc.maxTotal=30 #最大连接数jdbc.maxIdle=10 #最大空闲连接数jdbc.initialSize=5 #初始化连接数 applicationContext.xml : Spring核心配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=\"maxTotal\" value=\"$&#123;jdbc.maxTotal&#125;\"/&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name=\"maxIdle\" value=\"$&#123;jdbc.maxIdle&#125;\"/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 事务管理器,依赖于数据源 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; &lt;!-- 配置MyBatis工厂: 构建SqlSessionFactory --&gt; &lt;!-- 指定数据源和配置文件: 使得Spring IOC容器在初始化id为sqlSessionFactory的Bean时解析MyBatis的配置文件,并与数据源一同保存到Spring的Bean中 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 指定核心配置文件位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 实例化Dao: 为SqlSessionDaoSupport类的子类对象注入一个SqlSessionFactory --&gt; &lt;bean id=\"customerDao\" class=\"pers.huangyuhui.sm.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml : MyBaits核心配置文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 通过扫描包的形式定义别名: mybatis会将所有该包中的POJO类以首字母小写的非限定类名来作为它的别名 --&gt; &lt;package name=\"pers.huangyuhui.sm.po\" /&gt; &lt;/typeAliases&gt; &lt;!-- 配置Mapper配置 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/sm/po/CustomerMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; Customer.java : 持久层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.sm.po;/** * @ClassName: Customer * @Description: 客户信息 * @author: HuangYuhui * @date: May 24, 2019 6:38:18 PM * */public class Customer &#123; private Integer id; private String name; private String job; private String phone; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Customer [id=\" + id + \", name=\" + name + \", job=\" + job + \", phone=\" + phone + \"]\"; &#125;&#125; CustomerMapper.xml : 映射文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.sm.po.CustomerMapper\"&gt; &lt;!-- 根据id查询客户信息,其中`customer`为Customer类的别名 --&gt; &lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"customer\"&gt; select id,name,job,phone from t_customer where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; CustomerDao.java : DAO层 123456789101112131415161718192021package pers.huangyuhui.sm.dao;import pers.huangyuhui.sm.po.Customer;/** * @ClassName: CustomerDao * @Description: TODO * @author: HuangYuhui * @date: May 24, 2019 6:52:30 PM * */public interface CustomerDao &#123; /** * @Title: findCustomerById * @Description: 根据id查找客户信息 * @param: id * @return: Customer */ public Customer findCustomerById(Integer id);&#125; CustomerDaoImpl.java : CustomerDao的实现类 12345678910111213141516171819202122232425262728package pers.huangyuhui.sm.dao.impl;import org.mybatis.spring.support.SqlSessionDaoSupport;import pers.huangyuhui.sm.dao.CustomerDao;import pers.huangyuhui.sm.po.Customer;/** * @ClassName: CustomerDaoImpl * @Description: 实现操作客户信息接口 * @author: HuangYuhui * @date: May 24, 2019 6:54:24 PM *///注意:SqlSessionDaoSupport类在使用时需要一个SqlSessionFactory或一个SqlSessionTemplate对象,所以需要通过//Spring给SqlSessionDaoSupport类的子类对象注入一个SqlSessionFactory或SqlSessionTemplate.这样,在子类中就//能够调用SqlSessionDaoSupport类的getSqlSession()方法来获取SqlSession对象,并使用SqlSession对象中的方法!public class CustomerDaoImpl extends SqlSessionDaoSupport implements CustomerDao &#123; private String mapperNamespace = \"pers.huangyuhui.sm.po.CustomerMapper.\"; @Override // 通过id查找客户信息 public Customer findCustomerById(Integer id) &#123; // 调用SqlSessionDaoSupport类的getSqlSession()方法来获取SqlSession对象,并使用SqlSession对象中的方法! return this.getSqlSession().selectOne(mapperNamespace + \"findCustomerById\", id); &#125;&#125; 在此步骤需要在Spring配置文件applicationContext.xml中编写实例化CustomerDaoImpl的配置(已添加),代码如下所示 :123&lt;bean id=\"customerDao\" class=\"pers.huangyuhui.sm.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; SMTest.java : 整合测试类 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.sm.test;import org.junit.BeforeClass;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.sm.dao.CustomerDao;import pers.huangyuhui.sm.po.Customer;/** * @ClassName: SMTest * @Description: MyBatis+Spring整合测试 * @author: HuangYuhui * @date: May 24, 2019 7:02:26 PM * */public class SMTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test public void findCustomerByIdTest() &#123; // CustomerDao customerDao = (CustomerDao) applicationContext.getBean(\"customerDao\"); CustomerDao customerDao = (CustomerDao) applicationContext.getBean(CustomerDao.class); Customer customer = customerDao.findCustomerById(1); System.out.println(customer); &#125;&#125; log4j.properties : 日志文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.sm.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 程序运行结果 12345678910Fetching JDBC Connection from DataSourceJDBC Connection [1334618867, URL=xxxxxx, MySQL Connector/J] will not be managed by Spring==&gt; Preparing: select id,name,job,phone from t_customer where id = ? ==&gt; Parameters: 1(Integer)&lt;== Total: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15c25153]Returning JDBC Connection to DataSourceCustomer [id=1, name=YUbuntu0109, job=student, phone=15111111111] Mapper接口方式的开发整合. . .","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring MVC的核心类和注解","slug":"Spring-MVC的核心类和注解","date":"2019-05-22T13:22:50.000Z","updated":"2019-08-25T06:31:01.058Z","comments":true,"path":"2019/05/22/Spring-MVC的核心类和注解/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring-MVC的核心类和注解/","excerpt":"","text":"学习笔记 : Spring MVC核心类与注解Controller 注解类型简介 : org.springframework.stereotype.Controller注解类型用于指示Spring类的实例是一个控制器,其注解形式为@Controller,使用该注解时只需要通过Spring的扫描机制找到标注了该注解的控制器即可,其操作如下 : 在配置文件的声明中引入spring-context. 使用&lt;context:component-scan&gt;元素指定需要扫描的类包. RequestMapping 注解类型简介 : Spring通过@Controller注解找到相应的控制器类后,还需要知道控制器内部对每一个请求是如何处理的,这时就需要使用org.springframework.web.bind.annotation.RequestMapping注解类型,该注解类型用于映射一个请求或一个方法,其注解形式为@RequestMapping,可以使用该注解标注在一个类或方法上. 标注在方法上 : 该方法将成为一个请求处理方法,它会在程序接收到对应的URL请求时被调用. 标注在类上 : 该类中的所有方法都将映射为相对于类级别的请求,表示该控制器所处理的所有请求都被映射到value属性值所指的路径下. ViewResolver 视图解析器简介 : Spring MVC中视图解析器负责解析视图,可以通过在配置文件中定义一个ViewResolver来配置视图解析器.其配置如下 :1234567&lt;!-- 定义视图解析器 --&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 应用案例 web.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;springmvc_core&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;!-- 设置前端过滤器 --&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化时加载配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 容器启动时立即加载Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc-config.xml : Spring MVC配置文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.controller\"/&gt; &lt;!-- 定义视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; MyController.java : 控制器 12345678910111213141516171819202122232425262728293031package pers.huangyuhui.springmvc.controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/** * @ClassName: FirstController * @Description: 控制器 * @author: HuangYuhui * @date: May 23, 2019 7:16:18 PM * */@Controller // 标注为控制器类@RequestMapping(value = \"/springmvc\") // 映射请求方法public class MyController &#123; @RequestMapping(value = \"/myController\") public String handleRequest(HttpServletRequest request, HttpServletResponse response, Model model) &#123; // 向模型对象中添加数据 model.addAttribute(\"msg\", \"Hi Spring MVC ~\"); // 返回视图页面 return \"hi-springmvc\"; &#125;&#125; 在WebContent/WEB-INF/目录下新建view文件,并在其中新建hi-springmvc.jsp. 将项目发布到Tomcat服务器并启动,在浏览器中访问: http://localhost:8080/springmvc_core/springmvc/myController 即可发现页面显示运行结果 : Hi Sping MVC ~","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring的事务管理","slug":"Spring的事务管理","date":"2019-05-22T13:22:12.000Z","updated":"2019-08-25T06:31:01.062Z","comments":true,"path":"2019/05/22/Spring的事务管理/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring的事务管理/","excerpt":"","text":"学习笔记 : Spring的事务管理","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring AOP","slug":"Spring-AOP","date":"2019-05-22T13:21:32.000Z","updated":"2019-08-25T06:31:01.032Z","comments":true,"path":"2019/05/22/Spring-AOP/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring-AOP/","excerpt":"","text":"学习笔记 : Spring AOP","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"MyBatis的关联映射","slug":"MyBatis的关联映射","date":"2019-05-17T02:21:48.000Z","updated":"2019-08-25T06:31:01.018Z","comments":true,"path":"2019/05/17/MyBatis的关联映射/","link":"","permalink":"http://yoursite.com/2019/05/17/MyBatis的关联映射/","excerpt":"","text":"学习笔记 : MyBatis关联映射简介 : 在实际的开发中,对数据库的操作常常会涉及多张表,这在面向对象中就涉及了对象与对象之间对的关联关系. 针对多表之间的操作,MyBatis提供了关联映射,通过关联映射就可以很好地处理对象与对象之间的关联关系. MyBatis在映射文件中加载关联关系对象主要通过两种方式 : 嵌套查询 : 指通过执行另一条SQL映射语句来返回预期的复杂类型. 嵌套结果 : 使用嵌套结果映射来处理复杂的联合结果的子集. 配置文件(为下面程序示例做准备) db.properties : 连接数据库的配置文件 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=xxxxxxjdbc.password=xxxxxx mybatis-config.xml : MyBatis核心配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;properties resource=\"db.properties\"/&gt; &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 将积极加载改为延迟加载,既按需加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;/settings&gt; &lt;!-- 使用扫描包的形式定义别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"pers.huangyuhui.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境.默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册SQL映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/IdCardMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/PersonMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/UserMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/OrderMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/ProductMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; log4j.properties : 日志配置文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.test=DEBUG#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 一对一以人与身份证之间的一对一关联关系为例,为简化代码使用嵌套结果方式加载关联关系对象,程序示例如下 : SQL 数据表文件 1234567891011121314151617-- auto-generated definition by Intellij IDEAcreate table tb_idcard( id int auto_increment primary key, code varchar(18) null);create table tb_person( id int auto_increment primary key, name varchar(10) null, age int null, sex char(1) null, card_id int null, constraint tb_person_card_id_uindex unique (card_id), constraint tb_person_tb_idcard_id_fk foreign key (card_id) references tb_idcard (id)); IdCard.java : 存储身份证信息, Person.java : 存储个人信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package pers.huangyuhui.mybatis.bean;/** * @project: mybatis_associated_mapping * @description: 身份证信息 * @author: HuangYuhui * @date: 6/1/2019-8:28 AM * @version: 1.0 */public class IdCard &#123; private Integer id; private String code; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; @Override public String toString() &#123; return \"IdCard&#123;\" + \"id=\" + id + \", code='\" + code + '&#125;'; &#125;&#125;package pers.huangyuhui.mybatis.bean;/** * @project: mybatis_associated_mapping * @description: 个人信息 * @author: HuangYuhui * @date: 6/1/2019-8:30 AM * @version: 1.0 */public class Person &#123; private Integer id; private String name; private Integer age; private String sex; private IdCard card; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public IdCard getCard() &#123; return card; &#125; public void setCard(IdCard card) &#123; this.card = card; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"id=\" + id + \", name='\" + name + \", age=\" + age + \", sex='\" + sex + \", card=\" + card + '&#125;'; &#125;&#125; PersonMapper.xml : SQL映射文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.PersonMapper\"&gt; &lt;!-- 嵌套查询：通过执行另一个SQL映射语句来返回预期的特殊类型 --&gt; &lt;select id=\"findPersonById\" parameterType=\"integer\" resultMap=\"PersonInfo\"&gt; SELECT * FROM tb_person WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"PersonInfo\" type=\"person\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;!-- 一对一: association使用select属性引入另一条SQL语句 --&gt; &lt;association property=\"card\" column=\"card_id\" javaType=\"idCard\" select=\"pers.huangyuhui.mybatis.mapper.IdCardMapper.findCodeById\"/&gt; &lt;/resultMap&gt; &lt;!-- 嵌套结果查询: 使用嵌套结果映射来处理重复的联合结果的子集 --&gt; &lt;select id=\"findPersonById2\" parameterType=\"integer\" resultMap=\"PersonInfo2\"&gt; SELECT p.*,c.code FROM tb_person p,tb_idcard c WHERE p.card_id=c.id AND p.id=#&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"PersonInfo2\" type=\"person\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;association property=\"card\" javaType=\"idCard\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"code\" column=\"code\"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; MyBatisTest.java : 测试类 12345678910111213141516171819/** * @project: mybatis_associated_mapping * @description: 测试 * @author: HuangYuhui * @date: 6/1/2019-9:43 AM * @version: 1.0 */public class MyBatisTest &#123; @Test // TODO: 6/8/2019 一对一: 嵌套查询方式 public void findPersonById() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); Person info = sqlSession.selectOne(\"pers.huangyuhui.mybatis.mapper.PersonMapper.findPersonById2\", 1); System.out.println(info); sqlSession.close(); &#125;&#125; 一对多以一个用户对应多个订单为例,示例程序如下 : SQL 数据表文件 123456789101112131415-- auto-generated definition by Intellij IDEAcreate table user( id int auto_increment primary key, name varchar(15) null, address varchar(50) null);create table tb_order( id int auto_increment primary key, number varchar(20) not null, user_id int(2) not null, constraint orders_user_id_fk foreign key (user_id) references user (id)); Java Bean : User.java and Order.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package pers.huangyuhui.mybatis.bean;import java.util.List;/** * @project: mybatis_associated_mapping * @description: 用户信息 * @author: HuangYuhui * @date: 6/1/2019-11:04 AM * @version: 1.0 */public class User &#123; private Integer id; private String name; private String address; private List&lt;Order&gt; orders; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public List&lt;Order&gt; getOrders() &#123; return orders; &#125; public void setOrders(List&lt;Order&gt; orders) &#123; this.orders = orders; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", address='\" + address + '\\'' + \", orders=\" + orders + '&#125;'; &#125;&#125;package pers.huangyuhui.mybatis.bean;import java.util.List;/** * @project: mybatis_associated_mapping * @description: 订单信息 * @author: HuangYuhui * @date: 6/1/2019-11:02 AM * @version: 1.0 */public class Order &#123; private Integer id; private String number; private List&lt;Product&gt; products; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public List&lt;Product&gt; getProducts() &#123; return products; &#125; public void setProducts(List&lt;Product&gt; products) &#123; this.products = products; &#125; @Override public String toString() &#123; return \"Order&#123;\" + \"id=\" + id + \", number='\" + number + '\\'' + \", products=\" + products + '&#125;'; &#125;&#125; UserMapper.xml : SQL映射文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.UserMapper\"&gt; &lt;!-- 一对多:查看某一用户及其关联的订单信息 注意:当关联查询出的列名相同时,需要使用别名区分 --&gt; &lt;select id=\"findUserWithOrders\" parameterType=\"integer\" resultMap=\"UserWithOrdersResult\"&gt; SELECT u.*, o.id as order_id, o.number FROM user u,tb_order o WHERE u.id = o.user_id AND u.id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"UserWithOrdersResult\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;!-- ofType:属性集合中的元素类型 --&gt; &lt;collection property=\"orders\" ofType=\"order\"&gt; &lt;!-- 'order_id':tb_order.id的字段别名 --&gt; &lt;id property=\"id\" column=\"order_id\"/&gt; &lt;result property=\"number\" column=\"number\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; MyBatisTest.java : 测试类 12345678910111213141516171819/** * @project: mybatis_associated_mapping * @description: 测试 * @author: HuangYuhui * @date: 6/1/2019-9:43 AM * @version: 1.0 */public class MyBatisTest &#123; @Test // TODO: 6/8/2019 一对多:测试查询客户及其订单信息操作 public void findUserWithOrders() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); User info = sqlSession.selectOne(\"pers.huangyuhui.mybatis.mapper.UserMapper.findUserWithOrders\", 1); System.out.println(info); sqlSession.close(); &#125;&#125; 多对多以订单与商品的关系为例(一个订单可以包含多个商品),示例程序如下 : SQL 数据表文件 123456789101112131415161718192021222324252627-- auto-generated definition by Intellij IDEA-- 商品表create table tb_product( id int auto_increment primary key, name varchar(25) null, price double null);-- 订单表create table tb_order( id int auto_increment primary key, number varchar(20) not null, user_id int(2) not null, constraint orders_user_id_fk foreign key (user_id) references user (id));-- 商品与订单表的中间表create table tb_order_product( id int auto_increment primary key, order_id int null, product_id int null, constraint tb_order_product_tb_order_id_fk foreign key (order_id) references tb_order (id), constraint tb_order_product_tb_product_id_fk foreign key (product_id) references tb_product (id)); ProductMapper.xml : SQL映射文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.ProductMapper\"&gt; &lt;!-- 根据商品id查询指定商品及其对应的订单信息,注意:当关联查询出的列名相同时,需要使用别名区分 --&gt; &lt;select id=\"findProductWithOrder\" resultMap=\"ProductWithOrder\"&gt; SELECT p.*, o.id as oid, o.number FROM tb_product p,tb_order o,tb_order_product op WHERE o.id = op.order_id AND p.id = op.product_id AND p.id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 自定义手动映射类型 --&gt; &lt;resultMap id=\"ProductWithOrder\" type=\"product\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"price\" column=\"price\"/&gt; &lt;!-- 多对多关联映射 --&gt; &lt;collection property=\"orders\" ofType=\"order\"&gt; &lt;!-- 'oid':tb_order.id的别名 --&gt; &lt;id property=\"id\" column=\"oid\"/&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"number\" column=\"number\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; MyBatisTest.java : 测试类 12345678910111213141516171819202122232425262728package pers.huangyuhui.mybatis.test;import org.apache.ibatis.session.SqlSession;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.mybatis.bean.Order;import pers.huangyuhui.mybatis.bean.Person;import pers.huangyuhui.mybatis.bean.Product;import pers.huangyuhui.mybatis.bean.User;import pers.huangyuhui.mybatis.util.MyBatisUtils;/** * @project: mybatis_associated_mapping * @description: 测试 * @author: HuangYuhui * @date: 6/1/2019-9:43 AM * @version: 1.0 */public class MyBatisTest &#123; @Test // TODO: 6/8/2019 多对多:根据商品id查询指定商品及其对应的订单信息 public void findProductWithOrder() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); Product info = sqlSession.selectOne(\"pers.huangyuhui.mybatis.mapper.ProductMapper.findProductWithOrder\", 3); System.out.println(info); &#125;&#125; 程序运行结果 123456==&gt; Preparing: SELECT p.*, o.id as oid, o.number FROM tb_product p,tb_order o,tb_order_product op WHERE o.id = op.order_id AND p.id = op.product_id AND p.id = ? ==&gt; Parameters: 3(Integer)&lt;== Total: 3Product&#123;id=3, name=&apos;&lt;book:Spring MVC&gt;&apos;, price=33.3, orders=[Order&#123;id=3, number=&apos;10000001&apos;, products=null&#125;, Order&#123;id=3, number=&apos;10000003&apos;, products=null&#125;, Order&#123;id=3, number=&apos;10000002&apos;, products=null&#125;]&#125;","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Hi SpringMVC ~","slug":"Hi-SpringMVC","date":"2019-05-16T07:01:48.000Z","updated":"2019-08-25T06:31:00.970Z","comments":true,"path":"2019/05/16/Hi-SpringMVC/","link":"","permalink":"http://yoursite.com/2019/05/16/Hi-SpringMVC/","excerpt":"","text":"学习笔记 : Spring MVC入门Spring MVC概述Spring MVC是Spring提供的一个实现了Web MVC设计模式的轻量级Web框架. Spring MVC具有如下特点 : 支持国际化. 支持多种视图技术. 灵活性强,易于与其它框架集成. 内置常见效验器,可以效验用户输入. 可自动绑定用户输入,并正确的转换数据类型. 使用基于XML的配置文件,编写后无需重新编译应用程序. 提供了一个前端控制器DispatcherServlet,使开发人员无须额外开发控制器对象. Spring MVC的工作流程Spring MVC的工作原理图如下所示. 第一个Spring MVC应用程序 第一步: 配置前端控制器 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Hi_SpringMVC&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;!-- 配置前端过滤器 --&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化时加载配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使容器在启动时立即加载Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 第二步: 创建Controller类 12345678910111213141516171819202122232425262728293031package pers.huangyuhui.springmvc.controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;/** * @ClassName: FirstController * @Description: 控制器 * @author: HuangYuhui * @date: May 22, 2019 2:51:16 PM * */public class FirstController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; // 创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); // 向模型中添加数据 modelAndView.addObject(\"msg\", \"This is my first Spring MVC program ~\"); // 设置了逻辑视图名 modelAndView.setViewName(\"/WEB-INF/view/HiSpringMVC.jsp\"); return modelAndView; &#125;&#125; 第三步: 创建Spring MVC的配置文件,配置控制器映射信息 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置处理器Handle,映射 `/firstController`请求 --&gt; &lt;bean name=\"/FirstController\" class=\"pers.huangyuhui.springmvc.controller.FirstController\" /&gt; &lt;!-- 处理器映射器:将处理器Handle的name作为url进行查找 --&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" /&gt; &lt;!-- 处理器适配器:配置对处理器中handleRequest()方法的调用 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; &lt;!-- 截图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" /&gt;&lt;/beans&gt; 注意: 在Spring 4.0以后,如果不配置处理器映射器,处理器适配器和视图解析器,也会使用Spring内部默认的配置来完成相应的工作呦~ 这里没有省略是为了更清晰地展示Spring MVC的工作流程. 第四步: 创建视图页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Hi SpringMVC ~&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;$&#123;msg &#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 第五步: 启动Tomcat服务器,在浏览器中访问地址: http://localhost:8080/Hi_SpringMVC/FirstController 其效果图如下.","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"MyBatis:动态SQL","slug":"MyBatis-动态SQL","date":"2019-05-16T07:01:11.000Z","updated":"2019-08-25T06:31:01.017Z","comments":true,"path":"2019/05/16/MyBatis-动态SQL/","link":"","permalink":"http://yoursite.com/2019/05/16/MyBatis-动态SQL/","excerpt":"","text":"学习笔记 : MyBatis之动态SQL简介 : MyBatis提供的对SQL语句动态组装的功能解决了开发人员在使用JDBC或其他的框架进行数据库开发时,需要手动拼装SQL的繁琐问题. 动态SQL元素动态SQL是MyBatis强大特性之一,MyBatis 3采用了功能强大的基于OGNL的表达式来完成动态SQL,其主要元素如下. &lt;if&gt; : 判断语句,用于单条分支判断. &lt;choose&gt;(&lt;when&gt;,&lt;otherwise&gt;) : 相当于Java中的swith…case…default语句,用于多条件分支判断. &lt;where&gt;,&lt;trim&gt;,&lt;set&gt; : 辅助元元素,用于处理一些SQL拼装,特殊字符问题. &lt;foreach&gt; : 循环语句,常用于in语句等列举条件中. &lt;bind&gt; : 从OGNL表达式中创建一个变量,并将其绑定到上下文,常用于模糊查询的sql中. 扩展 : OGNL是Object-Graph Navigation Language的缩写,它是一种功能强大的表达式语言,通过它简单一致的表达式语法,可以存取对象的任意属性,调用对象的方法,遍历整个对象的结构图,实现字段类型转化等功能.它使用相同的表达式去存取对象的属性.这样可以更好的取得数据. 应用案例下面通过一个操作客户信息的综合案例来学习SQL动态元素 (っ•̀ω•́)っ✎⁾⁾ ~ 客户信息表结构 12345678create table t_customer ( id INT(32) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, jobs VARCHAR(45) NOT NULL, phone VARCHAR(16) NOT NULL ) db.properties : 数据库配置文件 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=GoodTime mybatis-config.xml : MyBatis核心配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 数据库配置文件 --&gt; &lt;properties resource=\"db.properties\" /&gt; &lt;!-- 配置环境.默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将SQL映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/CustomerMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; Customer.java : 封装客户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.mybatis.bean;/** * @ClassName: Customer * @Description: 客户信息实体表 * @author: HuangYuhui * @date: May 18, 2019 11:37:59 AM * */public class Customer &#123; private Integer id; private String username; private String job; private String phone; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Customer [id=\" + id + \", username=\" + username + \", job=\" + job + \", phone=\" + phone + \"]\"; &#125;&#125; CustomerMapper.xml : 操作’t_customer’数据表的映射文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.CustomerMapper\"&gt; &lt;!-- (&lt;if&gt;)将客户名和职业组合作为查询客户信息列表的条件 --&gt; &lt;select id=\"findCustomerByNameAndJob\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer where 1=1 &lt;if test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"job!=null and job!=''\"&gt; and job=#&#123;job&#125; &lt;/if&gt; &lt;/select&gt; &lt;!-- (&lt;where&gt;+&lt;if&gt;)将客户名和职业组合作为查询客户信息列表的条件 --&gt; &lt;select id=\"findCustomerByNameAndJob_where\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer &lt;where&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"job!=null and job!=''\"&gt; and job=#&#123;job&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- (&lt;trim&gt;+&lt;if&gt;)将客户名和职业组合作为查询客户信息列表的条件 --&gt; &lt;select id=\"findCustomerByNameAndJob_trim\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer &lt;trim prefix=\"where\" prefixOverrides=\"and\"&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"job!=null and job!=''\"&gt; and job=#&#123;job&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!-- (&lt;where&gt;+&lt;when&gt;+&lt;otherwise&gt;)将客户名或职业其中一项作为查询客户信息的条件 --&gt; &lt;select id=\"findCustomerByNameOrJob\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer &lt;where&gt; &lt;choose&gt; &lt;when test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/when&gt; &lt;when test=\"job!=null and job!=''\"&gt; and job = #&#123;job&#125; &lt;/when&gt; &lt;otherwise&gt; and phone is not null &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- (&lt;set&gt;+&lt;if&gt;)根据id更新客户信息 --&gt; &lt;update id=\"updateCustomer\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; update t_customer &lt;set&gt; &lt;if test=\"username !=null and username !=''\"&gt; username=#&#123;username&#125; &lt;/if&gt; &lt;if test=\"job !=null and job !=''\"&gt; job=#&#123;job&#125; &lt;/if&gt; &lt;if test=\"phone !=null and phone !=''\"&gt; phone=#&#123;phone&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- (&lt;foreach&gt;)根据客户id批量查询客户信息 --&gt; &lt;select id=\"findCustomerByIds\" parameterType=\"List\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer where id in &lt;foreach item=\"id\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!-- (&lt;bind&gt;)替换$&#123;&#125;,防止SQL注入问题.根据客户名模糊查询客户信息 --&gt; &lt;select id=\"findCustomerByName\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; &lt;bind name=\"pattern_username\" value=\" '%' + _parameter.getUsername + '%' \"/&gt; select id,username,job,phone from t_customer where username like #&#123;pattern_username&#125; &lt;/select&gt;&lt;/mapper&gt; MyBatisUtils.java : MyBatis工具类 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.mybatis.util;import java.io.IOException;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * @ClassName: MyBatisUtils * @Description: MyBatis工具类 * @author: HuangYuhui * @date: May 18, 2019 11:43:31 AM * */public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; private static SqlSessionFactory sqlSessionFactory = null; static &#123; // 使用MyBatis提供的Resources类加载MyBatis的配置文件 try (Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");) &#123; // 构建SqlSessionFactory工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 获取SqlSession对象的静态方法 public static SqlSession getSession() &#123; return sqlSessionFactory.openSession(); &#125;&#125; MyBatisTest.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package pers.huangyuhui.mybatis.test;import java.io.IOException;import java.util.ArrayList;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.mybatis.bean.Customer;import pers.huangyuhui.mybatis.util.MyBatisUtils;/** * @ClassName: MyBatisTest * @Description: 测试 * @author: HuangYuhui * @date: May 18, 2019 8:41:39 AM * */public class MyBatisTest &#123; private static Customer customer; private static String namespace = \"pers.huangyuhui.mybatis.mapper.CustomerMapper.\"; @BeforeClass public static void init() throws IOException &#123; customer = new Customer(); &#125; @Test @Ignore // 将客户名和职业组合作为查询客户信息列表的条件 public void findCustomerByNameAndJobTest() &#123; // 获取SqlSession对象 SqlSession sqlSession = MyBatisUtils.getSession(); // 封装需要组合查询的条件 customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"programmer\"); // 执行SqlSession的查询方法,并返回结果集 List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByNameAndJob\", customer); // 输出查询结果信息 for (Customer customer : customers) &#123; System.out.println(customer); &#125; // 关闭SqlSession sqlSession.close(); &#125; @Test @Ignore // 将客户名或职业其中一项作为查询客户信息的条件 public void findCustomerByNameOrJobTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"student\"); List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByNameOrJob\", customer); for (Customer customer : customers) &#123; System.out.println(customer); &#125; sqlSession.close(); &#125; @Test @Ignore // 根据客户id更新客户信息 public void updateCustomerTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setId(1); customer.setPhone(\"15711111111\"); int rows = sqlSession.update(namespace + \"updateCustomer\", customer); if (rows &gt; 0) &#123; System.out.println(\"成功更新了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"数据更新操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 根据客户id批量查询客户信息 public void findCustomerByIdsTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); // 创建List集合,封装查询id List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(2); ids.add(3); // 查询id为1,2,3的客户信息 List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByIds\", ids); for (Customer customer : customers) &#123; System.out.println(customer); &#125; sqlSession.close(); &#125; @Test @Ignore // 根据客户名模糊查询客户信息 public void findCustomerByNameTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"Y\"); List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByName\", customer); for (Customer customer : customers) &#123; System.out.println(customer); &#125; sqlSession.close(); &#125;&#125; log4j.properties : 日志配置文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring:数据库开发","slug":"Spring-数据库开发","date":"2019-05-16T07:00:49.000Z","updated":"2019-08-25T06:31:01.059Z","comments":true,"path":"2019/05/16/Spring-数据库开发/","link":"","permalink":"http://yoursite.com/2019/05/16/Spring-数据库开发/","excerpt":"","text":"学习笔记 : Spring 数据库开发Spring JDBC简介 : Spring框架降低了Java EE API的使用难度,例如JDBC. Spring的JDBC模块负责数据库资源管理和错误处理,简化了开发人员对数据库的操作,从而将更多的精力投入到编写业务逻辑中. Spring JdbcTemplate 的解析针对数据库操作,Spring框架提供了JdbcTemplate类,该类是Spring框架数据抽象层的基础,Spring JDBC的核心类. 它继承自抽象类JdbcAccessor,同时实现了JdbcOperations接口. JdbcAccessor : 该类为子类提供了一些访问是数据库时使用的公共属性. JdbcOperations : 该接口定义了在JdbcTemplate类中可以使用的操作集合,包括增删改查等操作. Spring JDBC 的配置Spring JDBC模块主要由4个包组成,如下所示哟 ~ core(核心包) : 包含了JDBC的核心功能,包括JdbcTemplate,SimpleJdbcInsert,SimpleJdbcCall类,以及NamedParameterJdbcTemplate类. dataSource(数据源包) : 访问数据源的实用工具类,它有多种数据源的实现,可以在Java EE容器外部测试JDBC代码. object(对象包) : 以面向对象的方式访问数据库,它允许执行查询并将返回结果作为业务对象,可以在数据表的列和业务对象的属性之间映射查询结果. support(支持包) : 包含了core和object包的支持类,例如: 提供异常转换功能的SQLException类. 由此可知,Spring对数据库的操作都封装在这几个包中,Spring JDBC的配置是在配置文件applicationContext.xml中完成的哟 ~ 其模板如下所示 : 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 1: 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/xxxxxx\"/&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"xxxxxx\" /&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"xxxxxx\" /&gt; &lt;/bean&gt; &lt;!-- 2: 配置JDBC模板 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!-- 默认必须使用数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 3: 配置注入类 --&gt; &lt;bean id=\"xxxxxx\" class=\"xxxxxx\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt; ······&lt;/beans&gt; 定义JdbcTemplate时,需要将dataSource注入到JdbcTemplate中,而其它需要使用JdbcTemplate的Bean,也需要将JdbcTemplate注入到该Bean中(通常注入到Dao类中,在Dao类中进行与数据库的相关操作). Spring JdbcTempalte 的常用方法JdbcTemplate类中提供了大量的操作数据库的方法,下面通过一个简单的CURE来体现一下Spring JDBC代码的简洁美 ~ applicationContext.xml : 配置文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 1: 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost/Spring?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true\" /&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"xxxxxx\" /&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"xxxxxx\" /&gt; &lt;/bean&gt; &lt;!-- 2: 配置JDBC模板 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!-- 默认必须使用数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 3: 配置注入类 --&gt; &lt;bean id=\"accountDao\" class=\"pers.huangyuhui.spring.jdbc.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 将jbdcTemplate注入到accountDao实例中 --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt;&lt;/beans&gt; Account.java : 封装用户账户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.spring.jdbc.bean;/** * @ClassName: Account * @Description: 用户账户信息实体表 * @author: HuangYuhui * @date: May 17, 2019 11:56:41 AM * */public class Account &#123; private Integer id; private String username; private Double balance; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Double getBalance() &#123; return balance; &#125; public void setBalance(Double balance) &#123; this.balance = balance; &#125; @Override public String toString() &#123; return \"Account [id=\" + id + \", username=\" + username + \", balance=\" + balance + \"]\"; &#125;&#125; AccountDao.java : 操作账户信息的接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package pers.huangyuhui.spring.jdbc.dao;import java.util.List;import pers.huangyuhui.spring.jdbc.bean.Account;/** * @ClassName: AccountDao * @Description: 操作用户账户表信息 * @author: HuangYuhui * @date: May 17, 2019 12:00:43 PM * */public interface AccountDao &#123; /** * @Title: createTable * @Description: 创建数据表 * @param: sql * @return: void */ public void createTable(String sql); /** * @Title: findAccountById * @Description: 查找表数据 * @param: id * @return: Account */ public Account findAccountById(int id); /** * @Title: findAllAccount * @Description: 查找全部表数据 * @return: List&lt;Account&gt; */ public List&lt;Account&gt; findAllAccount(); /** * @Title: addAccount * @Description: 添加表数据 * @param: account * @return: int */ public int addAccount(Account account); /** * @Title: updateAccount * @Description: 更新表数据 * @param: account * @return: int */ public int updateAccount(Account account); /** * @Title: deleteAccount * @Description: 删除表数据 * @param: id * @return: int */ public int deleteAccount(int id);&#125; AccountDaoImpl.java : AccountDao的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package pers.huangyuhui.spring.jdbc.dao.impl;import java.util.List;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import pers.huangyuhui.spring.jdbc.bean.Account;import pers.huangyuhui.spring.jdbc.dao.AccountDao;/** * @ClassName: AccountDaoImpl * @Description: AccountDao接口的实现类 * @author: HuangYuhui * @date: May 17, 2019 12:05:34 PM * */public class AccountDaoImpl implements AccountDao &#123; // 声明JdbcTemplate属性及其setter方法 private JdbcTemplate jdbcTemplate; // 获取JdbcTemplate实例 public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public void createTable(String sql) &#123; jdbcTemplate.execute(sql); &#125; @Override public int addAccount(Account account) &#123; String sql = \"insert into account(username,balance) value(?,?)\"; // 定义数组来存储SQL语句中的参数. Good idea ~ Object[] objects = new Object[] &#123; account.getUsername(), account.getBalance() &#125;; // 执行添加操作,返回受SQL语句影响的条数 return jdbcTemplate.update(sql, objects); &#125; @Override public int updateAccount(Account account) &#123; String sql = \"update account set username=? , balance=? where id = ?\"; // 注意: `?`需与设置的参数顺序对应哟 ! Object[] objects = new Object[] &#123; account.getUsername(), account.getBalance(), account.getId() &#125;; return this.jdbcTemplate.update(sql, objects); &#125; @Override public int deleteAccount(int id) &#123; String sql = \"delete from account where id = ?\"; return this.jdbcTemplate.update(sql, id); &#125; @Override public Account findAccountById(int id) &#123; String sql = \"select id,username,balance from account where id = ?\"; // 创建BeanPropertyRowMapper对象 // 它可以自动地将数据表中的数据映射到用户自定义的类中(前提是:用户自定义类中的字段要与数据表中的字段相对应) RowMapper&lt;Account&gt; rowMapper = new BeanPropertyRowMapper&lt;Account&gt;(Account.class); // 将id绑定到SQL语句中,并通过RowMapper返回一个Object类型的单行记录 return this.jdbcTemplate.queryForObject(sql, rowMapper, id); &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; String sql = \"select id,username,balance from account\"; RowMapper&lt;Account&gt; rowMapper = new BeanPropertyRowMapper&lt;Account&gt;(Account.class); // 执行静态的SQL查询,并通过RowMapper返回结果集 return this.jdbcTemplate.query(sql, rowMapper); &#125;&#125; 5.CURETest.java : 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package pers.huangyuhui.spring.jdbc.test;import java.util.List;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.jdbc.bean.Account;import pers.huangyuhui.spring.jdbc.dao.AccountDao;/** * @ClassName: CURDTest * @Description: 测试Spring JDBC的增删改查功能 * @author: HuangYuhui * @date: May 17, 2019 12:26:43 PM * */public class CURDTest &#123; private static Account account; private static AccountDao accountDao; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; account = new Account(); // 加载配置文件 applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 获取AccountDao实例 accountDao = (AccountDao) applicationContext.getBean(\"accountDao\"); &#125; @Test // 创建用户账户信息数据表 public void createTableTest() &#123; String sql = \"create table account\\r\\n\" + \"(\\r\\n\" + \" id int primary key auto_increment,\\r\\n\" + \" username varchar(10) not null,\\r\\n\" + \" balance double not null\\r\\n\" + \")\"; accountDao.createTable(sql); System.out.println(\"success to create the table of account ~\"); &#125; @Ignore @Test // 添加账户信息 public void addAccountTest() &#123; // 向Account对象中添加数据 account.setUsername(\"YUbuntu0109\"); account.setBalance(666666.0); // 获取添加操作返回的结果 int num = accountDao.addAccount(account); if (num &gt; 0) &#123; System.out.println(\"成功添加了 \" + num + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"添加数据失败 !\"); &#125; &#125; @Ignore @Test // 更新指定账户信息 public void updateAccountTest() &#123; account.setId(3); account.setUsername(\"update\"); account.setBalance(999999.0); int num = accountDao.updateAccount(account); if (num &gt; 0) &#123; System.out.println(\"更新成功了 \" + num + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"更新数据失败 ! \"); &#125; &#125; @Ignore @Test // 删除指定账户信息 public void deleteAccountTest() &#123; int num = accountDao.deleteAccount(1); if (num &gt; 0) &#123; System.out.println(\"删除了 \" + num + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"删除数据失败 !\"); &#125; &#125; @Ignore @Test // 查询指定账户信息 public void findAccountByIdTest() &#123; account = accountDao.findAccountById(2); System.out.println(account); &#125; @Ignore @Test // 查询所有账户信息 public void findAllAccount() &#123; List&lt;Account&gt; accountInfo = accountDao.findAllAccount(); System.out.println(accountInfo); &#125;&#125;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"VOA:One Hour of Exercise a Day Fights Damage of Sitting","slug":"VOA-One-Hour-of-Exercise-a-Day-Fights-Damage-of-Sitting","date":"2019-05-15T04:50:00.000Z","updated":"2019-08-25T06:31:01.093Z","comments":true,"path":"2019/05/15/VOA-One-Hour-of-Exercise-a-Day-Fights-Damage-of-Sitting/","link":"","permalink":"http://yoursite.com/2019/05/15/VOA-One-Hour-of-Exercise-a-Day-Fights-Damage-of-Sitting/","excerpt":"","text":"One Hour of Exercise a Day Fights Damage of SittingFrom VOA Learning English,this is Health&amp;Lifestyle report. When it comes to your health,it seems that sitting too much may be as bad for you as smoking. 说到健康,久坐不起可能与抽烟一样对身体不利. If you sit for many hours a day in a traditional office job,you may be interested in a new study. This study suggests that you should get an hour of “brisk exercise” every day. 如果你从事传统办公室工作,每日都要坐几个小时,你可能会对一项新研究感兴趣.这项研究建议你每天都花一个小时做轻快运动. Reasearchers says this brisk exercise can help offices workers reduce their risk of an early death. Many offices workers spend a large part of their time seated and physically inactive. 研究人员表明,这样的轻快运动能够帮助上班族降低过早死亡的风险.很多上班族大部分时间都是坐着,没有过多行动. A lack of physical activity is linked to some 5.3 million deaths worldwide each year. The researchers say that makes a sedentary lifestyle more deadly than smoking. 全球每年530万例死亡都与缺乏体育锻炼有关.研究人员表示,久坐不动的生活方式比吸烟更致命. The new report said that a sedentary lifestyle can cause many diseases,including heart disease,diabetes and even some cancers. These diseases cost the world economy $67.5 billion every year. 最新的报道表明,静态的生活方式可能会导致很多疾病,其中包括心脏病,糖尿病,甚至是癌症.每年,全球在这些疾病上等的话费约有675美元. The U.S. Centers for Disease Control and Prevention suggests adults get 150 minutes of moderate aerobic exercise every week. In addition,CDC offcials advise adults to get an additional two hours of muscle strengthening per week. 美国疾病预防与控制中心建议成年人每周做150分钟有氧运动.此外,疾病防治中心官员建议成年人每周花两个小时做肌肉训练. Ulf Ekeslund is with the Norwegian School of Sports Sciences and the University of Cambridge. He was the lead writer of the report. Elf Ekeslund同时在挪威体育学院以及剑桥大学任职.他是该报告的首席作者. Ekelund says that “For many people who commute to work and have offices-based jobs,there is no way to escape sitting for prolonged periods of time.” Ekelund表示: “对于乘车上下班到办公室的很多人来说,都无可避免在办公室久坐.” He says he and the other reasearchers “cannot stress enough” the importance of getting exercise. Ekelund suggests going for a run in the morning,riding a bicycle to work,or taking a walk in the middle of the work day. 他表示他和其他研究人员一直都在强调锻炼的重要性. Ekelund建议人们晨跑,骑车上班,并在午间散步. An hour of physical activity is “ideal”,he adds. But if this is not possible,he suggests doing at least some exercise each day to reduce the risk of diease and an early death. 每天锻炼一小时是理想的,他补充道.但如果不能做到这点,他建议人们每天至少做些运动以降低患病以及过早死亡的风险. For the study,researchers looked at 13 earlier studies on the effect of inactivity. Study subjects were grouped according to the amount of activity they reported. The range of activity reported varied greatly——from less than 5 minutes a day to up 75 minutes a day. 此项研究中,研究人员参考了13个不活动带来影响的早期案例.根据他们报告的活动量对研究对象进行了分组.报告说,活动量的幅度差别非常大,从每天至少5分钟到每天75分钟不等. The study found that those who sat for eight hours a day,but got the suggested amount of exercise reduced their chances of dying at an early age. 研究发现每天至少坐8小时,但按照建议做了适量运动的人降低了过早死亡的风险. These people did better than those who sat less but were not active. 与那些坐的时间少但不做运动的人相比,这些人的情况更好. Ekelund says, “These has been a lot of concern about the health risks” linked “with today’s more sedentary lifestyle.” He says the message from his team is a positive one: it’s possible to reduce,or even eliminate these risks if we are active enough, “even without taking up sports or going to the gym.” Ekelund表示,如今很多健康问题都与静态生活方式有关.他表示他们团队带来的信息是非常积极的: 我们有可能降低甚至消除这些风险,只要我们经常活动,即使不从事体育运动或不去健身房. A report on the study appeared in the pulication Lancet. I’m Anna Matteo. 重点词汇 brisk (a) 轻快的. inactive (a) 不活跃的. sedentary (a) 久坐的,静坐的. moderate (a) 稳健的. aerobic (a) 需氧的. prolonged (a) 延长的,拖延的. varied (a) 多变的,各式各样的. diabetes (n) 糖尿病,多尿症. economy (n) 经济. prevention (n) 预防,阻止. strengthening (n) 加强,加固. period (n) 周期,期间. inactivity (n) 不活动,静止. lancet (n) [外科]柳叶刀. commute (v) 通勤. stress (v) 强调. 重点短语 taking up : 占用了,占用","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"MyBatis的核心配置","slug":"MyBatis的核心配置","date":"2019-05-15T04:45:09.000Z","updated":"2019-08-25T06:31:01.019Z","comments":true,"path":"2019/05/15/MyBatis的核心配置/","link":"","permalink":"http://yoursite.com/2019/05/15/MyBatis的核心配置/","excerpt":"","text":"学习笔记 : MyBatis的核心配置MyBatis的核心对象SqlSessionFactorySqlSessionFactory是MyBatis中十分重要的对象,它是单个数据库映射关系经过编译后的内存镜像,其作用是创建SqlSession. SqlSessionFactory对象是线程安全的,它一旦被创建,在整个应用执行期间都会存在.如果我们多次地创建同一个数据库的SqlSessionFactory势必会耗尽数据库资源! 通常每一个数据库都会只对应一个SqlSessionFactory,所以在构建SqlSessionFactory时建议使用单例模式哟 ! SqlSessionSqlSession是MyBatis框架中另一个重要的对象,它是应用程序与持久层之间执行交互操作的一个单线程对象,其主要作用是执行持久化操作. 注意: 每一个线程都应该有一个自己的SqlSession实例,并且该实例是不能被共享的,同时SqlSession实例也是线程不安全的,因此其使用范围最好在一次请求或一个方法中,绝不能将其放在一个类的静态字段,实例或任何类型的管理范围中使用.使用后理应及时地关闭它 ! 配置文件主要元素结构图 映射文件官方简介 : MyBatis的真正强大在于它的映射语句,这是它的魔力所在.由于它的异常强大,映射器的XML文件就显得相对简单.如果拿它跟具有相同功能的JDBC代码进行对比,你会立即发现省掉了将近95%的代码! 俺喜欢简洁(✪ω✪) ~ 主要元素在映射文件中,&lt;mapper&gt;元素是映射文件的根元素,其它元素都是它的子元素,其子元素及其作用如下所示 : &lt;select&gt; : 映射查询语句,可自定义参数,返回结果等. &lt;insert&gt; : 映射插入语句,执行后返回一个整数,代表插入到条数. &lt;update&gt; : 映射更新语句,执行后返回一个整数,代表更新的条数. &lt;delete&gt; : 映射删除语句,执行后返回一个整数,代表删除的条数. &lt;sql&gt; : 用于定义一部分SQL,然后可被其它语句引用此SQL. &lt;cache-ref&gt; : 其他命名空间缓存配置的引用. &lt;resultMap&gt; : 用于描述如何从数据库结果集中来加载数据. 简单案例MyBatis框架的强大之处体现在映射文件,下面使用上述主要元素来编写一个简单的CURE程序 ~ 数据表 1234567891011121314151617# 客户信息表(用于测试增删改查元素)create table t_customer ( id INT(32) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, job VARCHAR(45) NOT NULL, phone VARCHAR(16) NOT NULL )# 用户信息表(用于测试&lt;resultMap&gt;元素)CREATE TABLE t_user( t_id INT PRIMARY KEY AUTO_INCREMENT, t_name VARCHAR(20) NOT NULL, t_age INT NOT NULL) db.properties : 数据库配置信息 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=GoodTime mybatis-config.xml : MyBatis核心配置文件 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 数据库配置文件 --&gt; &lt;properties resource=\"db.properties\" /&gt; &lt;!-- 配置环境.默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将SQL映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/UserMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/CustomerMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; CustomerMapper.xml : 操作’t_customer’数据表的映射文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.CustomerMapper\"&gt; &lt;!-- 使用&lt;sql&gt;元素定义可重用的sql代码片段,简化代码 --&gt; &lt;sql id=\"customerColumns\"&gt;id,username,job,phone&lt;/sql&gt; &lt;!-- 使用&lt;insert&gt;元素查询客户信息 --&gt; &lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select &lt;include refid=\"customerColumns\"/&gt; from t_customer where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 使用&lt;insert&gt;元素添加客户信息并返回数据库生成的主键值 --&gt; &lt;insert id=\"addCustomer\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; insert into t_customer(username,job,phone) values(#&#123;username&#125;,#&#123;job&#125;,#&#123;phone&#125;) &lt;/insert&gt; &lt;!-- 使用&lt;insert&gt;元素添加客户信息并使用MyBatis提供的方式生成主键值 --&gt; &lt;insert id=\"addCustomer2\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" &gt; &lt;selectKey keyProperty=\"id\" resultType=\"Integer\" order=\"BEFORE\"&gt; select if(max(id) is null,1,max(id)+1) as newId from t_customer &lt;/selectKey&gt; insert into t_customer(id,username,job,phone) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;job&#125;,#&#123;phone&#125;) &lt;/insert&gt; &lt;!-- 使用&lt;update&gt;元素更新客户信息 --&gt; &lt;update id=\"updateCustomerById\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; update t_customer set username=#&#123;username&#125;,job=#&#123;job&#125;,phone=#&#123;phone&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 使用&lt;delete&gt;元素删除客户信息 --&gt; &lt;delete id=\"deleteCustomerById\" parameterType=\"Integer\"&gt; delete from t_customer where id = #&#123;id&#125; &lt;/delete&gt; &lt;/mapper&gt; UserMapper.xml : 操作’t_user’数据表的映射文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.UserMapper\"&gt; &lt;!-- &lt;resultMap&gt;元素可解决数据表中的列与需要返回的对象的属性名可能不一致的问题 --&gt; &lt;resultMap type=\"pers.huangyuhui.mybatis.bean.User\" id=\"resultMap\"&gt; &lt;id property=\"id\" column=\"t_id\"/&gt; &lt;result property=\"name\" column=\"t_name\"/&gt; &lt;result property=\"age\" column=\"t_age\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findAllUser\" resultMap=\"resultMap\"&gt; select t_id,t_name,t_age from t_user &lt;/select&gt;&lt;/mapper&gt; MyBatisUtils.java : MyBatis工具类 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.mybatis.util;import java.io.IOException;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * @ClassName: MyBatisUtils * @Description: MyBatis工具类 * @author: HuangYuhui * @date: May 18, 2019 3:59:18 PM * */public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; private static SqlSessionFactory sqlSessionFactory = null; static &#123; // 使用MyBatis提供的Resources类加载MyBatis的配置文件 try (Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");) &#123; // 构建SqlSessionFactory工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 获取SqlSession对象的静态方法 public static SqlSession getSession() &#123; return sqlSessionFactory.openSession(); &#125;&#125; MyBatisTest.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package pers.huangyuhui.mybatis.test;import java.io.IOException;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.mybatis.bean.Customer;import pers.huangyuhui.mybatis.bean.User;import pers.huangyuhui.mybatis.util.MyBatisUtils;/** * @ClassName: MyBatisTest * @Description: MyBatis核心配置: CURE * @author: HuangYuhui * @date: May 18, 2019 4:03:47 PM * */public class MyBatisTest &#123; private static Customer customer; private static String namespace = \"pers.huangyuhui.mybatis.mapper.CustomerMapper.\"; @BeforeClass public static void init() throws IOException &#123; customer = new Customer(); &#125; @Test @Ignore // 根据客户编id查询客户信息 public void findCustomerByIdTest() &#123; // 获取SqlSession对象 SqlSession sqlSession = MyBatisUtils.getSession(); // 执行SqlSession的查询方法,并返回结果 Customer customerInfo = sqlSession.selectOne(namespace + \"findCustomerById\", 1); // 输出查询结果信息 System.out.println(customerInfo); // 关闭SqlSession sqlSession.close(); &#125; @Test @Ignore // 插入客户信息并获取由数据库生成的主键值 public void addCustomerTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"student ~\"); customer.setPhone(\"15111111111\"); int rows = sqlSession.insert(namespace + \"addCustomer\", customer); if (rows &gt; 0) &#123; System.out.println(\"插入数据的主键id值为: \" + customer.getId()); System.out.println(\"成功插入了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"插入数据操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 添加客户信息并使用MyBatis提供的方式生成主键值 public void addCustomer2Test() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"student ~\"); customer.setPhone(\"13111111111\"); int rows = sqlSession.insert(namespace + \"addCustomer2\", customer); if (rows &gt; 0) &#123; System.out.println(\"mybatis生成的主键为: \" + customer.getId()); System.out.println(\"成功插入了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"插入数据操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 根据客户id更新客户信息 public void updateCustomerByIdTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setId(1); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"speaker\"); int rows = sqlSession.update(namespace + \"updateCustomerById\", customer); if (rows &gt; 0) &#123; System.out.println(\"成功更新了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"数据更新操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 根据客户id删除客户信息 public void deleteCustomerById() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); int rows = sqlSession.delete(namespace + \"deleteCustomerById\", 1); if (rows &gt; 0) &#123; System.out.println(\"成功删除了 \" + rows + \" 条记录哟 ~\"); &#125; else &#123; System.out.println(\"删除数据操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 使用&lt;resultMap&gt;元素查找`t_user`表中所有用户信息 public void findAllUserTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); List&lt;User&gt; users = sqlSession.selectList(\"pers.huangyuhui.mybatis.mapper.UserMapper.findAllUser\"); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125; log4j.properties : 日志配置文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring:Bean","slug":"Spring-Bean","date":"2019-05-14T14:04:41.000Z","updated":"2019-08-25T06:31:01.033Z","comments":true,"path":"2019/05/14/Spring-Bean/","link":"","permalink":"http://yoursite.com/2019/05/14/Spring-Bean/","excerpt":"","text":"学习笔记 : Spring BeanBean 的配置简介 : Spring可以被看成一个大型工厂,其作用是生产和管理Spring容器中的Bean,前提是需要在Sring配置文件中进行配置. Spring容器支持XML和Properties两种格式的配置文件.其前者最为常用哟! 在配置文件中,通常为一个Bean配置id或name和class两个属性即可,注意的是如果Bean中未指定id和name,则Spring会将class值当做id使用. Bean 的实例化简介 : 在Spring中,想要使用容器中的Bean时需要先将其实例化,其实例化的方式有三种,如下所示. 构造器实例化(最常用) : Spring容器通过Bean对应类中默认的无参构造方法来实例化Bean. 静态工厂方式实例化 : 将Bean配置中的class属性指定静态工厂类,然后使用factory-method属性来指定所创建的静态工厂方法. 实例工厂方式实例化 : 将需要实例化的Bean通过factory-bean属性指向配置的实例工厂,然后使用factory-method属性确定使用工厂中的具体方法. Bean 的实例化案例通过一个示例程序来演示实例化Bean的三种方式. Bean类 1234567891011121314151617181920package pers.huangyuhui.spring.bean.instance;//构造器实例化public class Bean1 &#123;&#125;package pers.huangyuhui.spring.bean.instance;//静态工厂方式实例化 public class Bean2 &#123;&#125;package pers.huangyuhui.spring.bean.instance;//实例工厂方式实例化public class Bean3 &#123;&#125; MyBean2Factory.java : 静态工厂 1234567891011121314151617package pers.huangyuhui.spring.bean.factory;import pers.huangyuhui.spring.bean.instance.Bean2;/** * @ClassName: MyBean2Factory * @Description: 静态工厂方式实例化 * @author: HuangYuhui * @date: May 24, 2019 2:08:00 PM * */public class MyBean2Factory &#123; public static Bean2 createBean() &#123; return new Bean2(); &#125;&#125; MyBean3Factory.java : 实例工厂 123456789101112131415161718192021package pers.huangyuhui.spring.bean.factory;import pers.huangyuhui.spring.bean.instance.Bean3;/** * @ClassName: MyBean3Factory * @Description: 实例工厂方式实例化 * @author: HuangYuhui * @date: May 24, 2019 2:16:03 PM * */public class MyBean3Factory &#123; public MyBean3Factory() &#123; System.out.println(\"this is constructor ~\"); &#125; public Bean3 createBean() &#123; return new Bean3(); &#125;&#125; applicationContext.xml : Spring核心配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 构造器实例化 --&gt; &lt;bean id=\"bean1\" class=\"pers.huangyuhui.spring.bean.instance.Bean1\"/&gt; &lt;!-- 静态工厂方式实例化 --&gt; &lt;!-- factory-method: 指定工厂方法 --&gt; &lt;bean id=\"bean2\" class=\"pers.huangyuhui.spring.bean.factory.MyBean2Factory\" factory-method=\"createBean\"/&gt; &lt;!-- 实例工厂方式实例化 --&gt; &lt;!-- factory-bean:指定配置的实例工厂 --&gt; &lt;bean id=\"myBean3Factory\" class=\"pers.huangyuhui.spring.bean.factory.MyBean3Factory\"/&gt; &lt;bean id=\"bean3\" factory-bean=\"myBean3Factory\" factory-method=\"createBean\"/&gt; &lt;/beans&gt; InstanceTest.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package pers.huangyuhui.spring.bean.instance.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.bean.instance.Bean1;/** * @ClassName: InstanceTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 1:57:41 PM * */public class InstanceTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test @Ignore // 构造器实例化 public void instanceTest1() &#123; Bean1 bean1 = applicationContext.getBean(Bean1.class); // result : pers.huangyuhui.spring.bean.instance.Bean1@59402b8f System.out.println(bean1); &#125; @Test @Ignore // 静态工厂方式实例化 public void instanceTest2() &#123; // result : pers.huangyuhui.spring.bean.instance.Bean2@70ed52de System.out.println(applicationContext.getBean(\"bean2\")); &#125; @Test @Ignore // 实例工厂方式实例化 public void instanceTest3() &#123; // result : // this is constructor ~ // pers.huangyuhui.spring.bean.instance.Bean3@70ed52de System.out.println(applicationContext.getBean(\"bean3\")); &#125;&#125; Bean 的作用域简介 : 在Spring 4.3中为Bean定义了七种作用域,如下所示. Singleton(单例) : 使用Singleton定义的Bean在Spring容器中将只有一个实例,也就是说,无论有多少个Bean引用它,始终指向同一个对象,其也是Spring默认的作用域. prototype(原型) : 每次通过Spring容器获取prototype定义的Bean时,容器都将创建一个新的Bean实例. request : .. session : .. globalSession : .. application : .. websocket : .. Bean 的作用域案例下面通过简单程序来分别演示singleton和prototype作用域 Bean类 123456789101112package pers.huangyuhui.spring.bean.scope;//Bean的作用域: singleton public class Bean4 &#123;&#125;package pers.huangyuhui.spring.bean.scope;//Bean的作用域: prototypepublic class Bean5 &#123;&#125; Spring核心配置文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- singleton(default) --&gt; &lt;bean id=\"bean4\" class=\"pers.huangyuhui.spring.bean.scope.Bean4\" scope=\"singleton\"/&gt; &lt;!-- prototype --&gt; &lt;bean id=\"bean5\" class=\"pers.huangyuhui.spring.bean.scope.Bean5\" scope=\"prototype\"/&gt;&lt;/beans&gt; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.spring.bean.scope.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @ClassName: ScopeTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 2:53:10 PM * */public class ScopeTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test @Ignore // Bean的作用域: singleton public void singletonTest() &#123; // result: // pers.huangyuhui.spring.bean.scope.Bean4@7c137fd5 // pers.huangyuhui.spring.bean.scope.Bean4@7c137fd5 System.out.println(applicationContext.getBean(\"bean4\")); System.out.println(applicationContext.getBean(\"bean4\")); &#125; @Test @Ignore // Bean的作用域: prototype public void prototypeTest() &#123; // result: pers.huangyuhui.spring.bean.scope.Bean5@3e08ff24 System.out.println(applicationContext.getBean(\"bean5\")); &#125;&#125; Bean 的装配方式简介 : Bean的装配方式可以理解为依赖注入,Bean的装配方式既Bean依赖注入的方式. Spring容器支持多种形式的Bean的装配方式,如基于XML的装配,基于Annotation的装配等.. 基于XML的装配Spring提供了两种基于XML的装配方式: 设值注入(Setter Injection)和构造注入(Constructor Injection). 在Spring实例化Bean的过程中,Spring首先会调用Bean的默认构造方法来实例化Bean对象,然后通过反射的方式调用setter方式来注入属性值.因此,设值注入要求一个Bean必须满足一下两点要求. Bean类必须提供一个默认的无参构造方法. Bean类必须为需要注入的属性提供对应的setter方法. 下面通过一个简单示例程序来展示基于XML的Bean的装配方式. User.java : Java bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pers.huangyuhui.spring.assemble.bean;import java.util.List;/** * @ClassName: User * @Description: 用户信息 * @author: HuangYuhui * @date: May 24, 2019 3:37:58 PM * */public class User &#123; private String name; private List&lt;String&gt; phone; public User() &#123; &#125; public User(String name, List&lt;String&gt; phone) &#123; super(); this.name = name; this.phone = phone; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getPhone() &#123; return phone; &#125; public void setPhone(List&lt;String&gt; phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"User [name=\" + name + \", phone=\" + phone + \"]\"; &#125;&#125; applicationContext.xml : Spring核心配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 利用构造注入方式装配User实例 --&gt; &lt;bean id=\"user1\" class=\"pers.huangyuhui.spring.assemble.bean.User\"&gt; &lt;constructor-arg index=\"0\" value=\"YUbuntu0109-1\"/&gt; &lt;constructor-arg index=\"1\"&gt; &lt;list&gt; &lt;value&gt;\"15111111111\"&lt;/value&gt; &lt;value&gt;\"15211111111&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 使用设值注入方式装配User实例 --&gt; &lt;bean id=\"user2\" class=\"pers.huangyuhui.spring.assemble.bean.User\"&gt; &lt;property name=\"name\" value=\"YUbuntu0109-2\"/&gt; &lt;property name=\"phone\"&gt; &lt;list&gt; &lt;value&gt;\"13111111111\"&lt;/value&gt; &lt;value&gt;\"18111111111\"&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; AssembleTest.java : 测试类 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.spring.assemble.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.assemble.controller.UserController;/** * @ClassName: AssembleTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 3:49:42 PM * */public class AssembleTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test // @Ignore // 测试基于XML的Bean配置 public void xmlBeanAssembleTest() &#123; // result: User [name=YUbuntu0109-1, phone=[\"15111111111\", \"15211111111]] System.out.println(applicationContext.getBean(\"user1\")); // result: User [name=YUbuntu0109-2, phone=[\"13111111111\", \"18111111111\"]] System.out.println(applicationContext.getBean(\"user2\")); &#125;&#125; 基于Annotation的装配简介 : 通过注解(Annotation)来实现Bean的装配工作可以解决XML配置文件过于臃肿的问题,且便于后期维护. 其常用注解如下. @Repository : 用于将数据访问层(DAO层)的类标识为Spring中的Bean. @Service : 通常作用在业务层(Service层),用于将业务层的类标识为Spring中的Bean. @Controller : 通过作用在控制层(如Spring MVC的Controller),用于将控制层的类标识为Spring中的Bean. @Autowired : 用于对Bean的属性变量,属性的setter方法及构造方法进行标注,配合对用的注解处理器来完成Bean的自动配置工作. 下面通过一个简单案例来演示如何通过这些注解来装配Bean. UserDao.java 123456package pers.huangyuhui.spring.assemble.dao;public interface UserDao &#123; public void save();&#125; UserDaoImple.java 12345678910111213141516171819202122package pers.huangyuhui.spring.assemble.dao.impl;import org.springframework.stereotype.Repository;import pers.huangyuhui.spring.assemble.dao.UserDao;/** * @ClassName: UserDaoImpl * @Description: UserDao的实现类 * @author: HuangYuhui * @date: May 24, 2019 4:13:53 PM * */@Repository(\"userDao\") // 将UserDaoImpl类标识为Spring中的Beanpublic class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(\"UserDao : Save function ~\"); &#125;&#125; 其中使用@Respository注解将UserDaoImpl类标识为Spring中的Bean,其写法相当于配置文件中的&lt;bean id=&quot;userDao&quot; class=&quot;pers.huangyuhui.spring.assemble.dao.impl.UserDaoImpl&quot;/&gt; UserService.java 123456package pers.huangyuhui.spring.assemble.dao;public interface UserService &#123; public void save();&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728package pers.huangyuhui.spring.assemble.dao.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import pers.huangyuhui.spring.assemble.dao.UserDao;import pers.huangyuhui.spring.assemble.dao.UserService;/** * @ClassName: UserServiceImpl * @Description: UserService的实现类 * @author: HuangYuhui * @date: May 24, 2019 4:20:15 PM * */@Service // 将UserServiceImpl类标识为Spring中的Beanpublic class UserServiceImpl implements UserService &#123; @Autowired // 自动配置Bean private UserDao userDao; @Override public void save() &#123; userDao.save(); System.out.println(\"UserService : Save function ~\"); &#125;&#125; UserController.java 1234567891011121314151617181920212223242526package pers.huangyuhui.spring.assemble.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import pers.huangyuhui.spring.assemble.dao.UserService;/** * @ClassName: UserController * @Description: TODO * @author: HuangYuhui * @date: May 24, 2019 4:33:56 PM * */@Repository /// 将UserController类标识为Spring中的Beanpublic class UserController &#123; @Autowired // 自动配置Bean private UserService userService; public void save() &#123; userService.save(); System.out.println(\"UserController : Save function ~\"); &#125;&#125; AssembleTest.java : 测试类 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.spring.assemble.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.assemble.controller.UserController;/** * @ClassName: AssembleTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 3:49:42 PM * */public class AssembleTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test public void annotationAssembleTest() &#123; UserController userController = (UserController) applicationContext.getBean(\"userController\"); userController.save(); &#125;&#125; Spring核心配置文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 扫描指定包下的所有Bean类,进行注解解析 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.spring.assemble\"/&gt; &lt;/beans&gt; 程序运行结果 123UserDao : Save function ~UserService : Save function ~UserController : Save function ~","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"VOA:Facebook Co-founder Calls for New Laws Limiting Big Tech","slug":"VOA-Facebook-Co-founder-Calls-for-New-Laws-Limiting-Big-Tech","date":"2019-05-12T14:01:54.000Z","updated":"2019-08-25T06:31:01.092Z","comments":true,"path":"2019/05/12/VOA-Facebook-Co-founder-Calls-for-New-Laws-Limiting-Big-Tech/","link":"","permalink":"http://yoursite.com/2019/05/12/VOA-Facebook-Co-founder-Calls-for-New-Laws-Limiting-Big-Tech/","excerpt":"","text":"Facebook Co-founder Calls for New Laws Limiting Big TechFacebook co-founder Chris Hughes has called for the breakup of Facebook,the world’s largest social media company. 脸书联合创始人克里斯·休斯(Chris Hughes)呼吁分拆这家全国最大的社交媒体公司. Hughes says the United States has laws to control monopolies——businesses that control too much of an industry. He wants the U.S. goverment to user those laws to help protect people from technology and social media companies. 休斯表示,美国有反垄断法律,垄断企业是指在某行业占据过多市场份额的企业.他希望美国政府利用这些法律帮助人们免受科技和社交媒体的侵害. His comments appeared Thursday in an opinion in The New York Times. 他的这番话出现在周四《纽约时报》的一篇评论文章中. Facebook Inc. quickly rejecte his call. Facebook公司很快拒绝了他的这一呼吁. Hughes once shared a room in college with Mark Zuckerberg,who later became Facebook’s chief executive officer. 休斯曾经在大学里和马克·扎克伯格同一寝室,后来马克·扎克伯格称为了Facebook的首席执行官. “We are a nation with a tradition of reining in monopolies,no matter how well intentioned the leader of these of companies may be.Mark’s power is unprecedented and un-American,” Hughes wrote. “我们是一个有着控制垄断传统的国家,不管这些公司的领导人的意图有多好.马克的权利是前所未有的,非美式的.” 休斯写到. More than 2 billion people worldwide currently use Facebook,The company also owns WhatApp,Messenger and Instagram. Each service has more than 1 billion users. 目前全世界有超过20亿人在使用Facebook,该公司还拥有What’s App,Messenger和Instagram三大平台.每项服务都有超过10亿的用户. Chris Hughes co-founded Facebook with Zuckerberg and Dustin Moskovitz at Harvard University in 2004,He left the company in 2007. He later said in a Linkedln post that he earned $500 million for his three years of work. 2004,克里斯·休斯,扎克伯格和达斯汀·莫斯科维茨在哈佛大学共同创办了Facebook.休斯于2007年离开了公司,他后来在领英(LinkedIn)的一篇帖子中说:三年的工作让它赚了5亿美元. It’s been 15 years since I co-founder Facebook at Harvard,and I haven’t worked at the company in a decade. But I feel a sense of anger and responsibility,he wrote. “从我在哈佛与他们联合创办Facebook已经有15年了,我已经有10年没有在这家公司工作了,但我感到愤怒和一定的责任.” 他写到. Hughes helped Barack Obama with his presidential election campaign‘s online strategy during the 2008 political campaign. 休斯在2008年大选中帮助巴卡拉·奥巴马制定了他的总统竞选网络策略. Over the past two years,several security and privacy scandals have hit Facebook. Investigators found that the company,working with a now-closed consulting business,called Cambridge Analytica,shared information about 87 million users. In 2016,the election campaign of then presidential candidate Donald Trump used that information to target its advertising to Facebook users. 在过去的两年里,Facebook涉及数起安全和隐私丑闻.调查人员发现,该公司与一家目前已经关闭的名为剑桥分析的咨询公司合作,共享了8700万用户的信息,2016年,当时的总统候选人唐纳特·特朗普的竞选团队利用这些信息,将其宣传目标对准了Facebook用户. Hughes helped to design what Facebook called the “News Feed.” He said that his team should have thought more carefully about how that might be used. 休斯帮助设计了Facebook的”新闻推送”,他说,它的团队应该更仔细地考虑如何使用这一技术. Hughes said he last met with Zuckerberg in the summer of 2017,several months before the news came out about the Cambridge Analytica scandal. 休斯说,他最后一次见到马克伯格是在2017年的夏天,几个月后,剑桥分析公司的丑闻曝光. Mark is good,kind person. But I’m angry that his focus on growth led him to sacrifice security and civility for clicks,Hughes said. 休斯说: “马克是个善良的好人.但令我愤怒的是,他太关注公司的发展导致他为了点击量而牺牲了网络安全和文明.” He also said he worries that the people around Zuckerberg always agree with him and never question his ideas. Zuckerbeg cannot be dismissed,so he has total control of the company. 他还说,他担心扎克伯格身边的人总是时顺从他,从不质疑他的想法,扎克伯格不能被解雇,所以他拥有公司的完全控制权. Hughes is not alone in asking for backup of Facebook. Some U.S. lawmakers have called for federal privacy rules and new laws to break up big tech companies. 休斯并不是唯一一个要求拆分Facebook的人.一些美国会议员呼吁制定联邦隐私法规和新法律来削弱大型科技公司. Senator Richard Blumenthal of Connecticut said on Thursday he thinks Facebook needs to be broken up. He also called for the Justice Department’s antitrust to launch an investigation. 康涅狄克州参议员查德·不卢门撒尔周四表示,他认为Facebook需要拆分.他还呼吁司法部反垄断部门对其展开调查. In March,Massachusetts Senator Elizabeth Warren promised to break up Facebook,Amazon.com Inc. and Alphabet Inc.’s Google,if elected president.She thinks that action would help to support competition in the tech field. 今年三月,马萨诸塞州参议员伊丽莎白·沃伦承若,如果当选总统,她将拆分Facebook,亚马逊和谷歌,他认为,这一行动将有助于支持科技领域的竞争. Facebook rejected Hughes’call for WhatApp and Instagram to be made into separate businesses. The social media company said that attention should be directed instead on creating rules for the internet. Facebook拒绝了休斯将WhatApp和Instagram拆分成两家公司的提议.这家社交媒体公司表示,应该把注意力转向为制定互联网规则. Facebook accepts that with success comes accountability. But you don’t enforce accountability by calling for the break up of a successful American company,a spokesperson said in the statement. “Facebook承认,成功伴随着责任.但拆分一家成功的美国公司并不能强化问责制,” 一位发言人在声明表示. I’m Jill Robbins. 重点词汇 breakup (n) 解体,分裂. monopoly (n) 垄断,垄断者. industry (n) 产业,工业. election (n) 选举,当选. campaign (n) 运动,活动. scandal (n) 丑闻,流言蜚语. investigator (n) 研究者,调查者. investigation (n) 调查研究. advertising (n) 广告. lawmaker (n) 立法者. justice (n) 司法. field (n) 领域. spokesperson (n) 发言人,代言人. accountability (n) 有义务,有责任 intentioned (a) 出于..意向的,有..企图的 unprecedented (a) 空前的,无前例的. executive (a) 行政的,经营的. presidential (a) 总统的,首长的. political (a) 政治的,党派的. several (a) 几个的,各自的. consulting (a) 咨询的,商议的. federal (a) 联邦的. antitrust (a) [经]反垄断的. rein (v) 控制. dismiss (v) 解散,解雇. separate (v) 分开,隔开. enforce (v) 强迫,强制. chief (adv) 主要地,首要地. Inc (abbr) 股份有限公司(incorporated) 重点短语 called for : 提倡,要求. break up : 拆分,解散.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"Hi MyBatis ~","slug":"Hi-MyBatis","date":"2019-05-09T13:02:06.000Z","updated":"2019-08-25T06:31:00.963Z","comments":true,"path":"2019/05/09/Hi-MyBatis/","link":"","permalink":"http://yoursite.com/2019/05/09/Hi-MyBatis/","excerpt":"","text":"学习笔记 : 初识MyBatis简介 : MyBatis的前身是iBATIS,是Clinton Begin在2001年发起的一个开源项目,最初侧重于密码软件的开发,后来发展成为一款基于Java的持久层框架.2004年,Clinton将iBATIS的名字和源码捐赠给了Apache软件基金会.2010年,核心开发团队决定离开Apache软件基金会,并且将iBATIS该名为MyBatis. MyBatis 工作原理MyBatis框架执行流程图如下所示 : 从MyBatis框架执行流程图中可得知,MyBatis框架在操作数据库时,大体经过了8个步骤.下面对每一步进行详解哟 ~ 读取MyBatis配置文件mybatis-config.xml.其作为MyBatis的全局配置文件,配置了MyBatis的运行环境等信息,其中主要内容是获取数据库连接. 加载映射配置文件Mapper.xml.既SQL映射文件,该文件配置了操作数据库的SQL语句,需要在mybatis-config.xml中加载才能执行.mybatis-config.xml可以加载多个配置文件,每个配置文件对应数据库中的一张表. 构建会话工厂.通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory. 创建SqlSession对象.由会话工厂创建SqlSession对象,该对象中包含了执行SQL的所有方法. MyBatis底层定义了一个Executor接口来操作数据库,它会根据SqlSession传递的参数动态地生成需要执行的SQL语句,同时负责查询缓存的维护. 在Executor接口的执行方法中,包含一个MappedStatement类型的参数,该参数是对映射信息的封装,用于存储要映射的SQL语句的id,参数等.. Mapper.xml文件中一个SQL对应一个MappedStatement对象,SQL的id既是MappedStatement的id. 输入参数映射,其过程类似于JDBC编程中对preparedStatement对象设置参数的过程. 输出参数映射,其过程类似于JDBC编程中对结果的解析处理过程. MyBatis 入门程序 User.java : 一个简单Java bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.mybatis.bean;/** * @ClassName: User * @Description: 封装用户信息 * @author: HuangYuhui * @date: May 9, 2019 5:07:23 PM * */public class User &#123; private Integer id; private String name; private String gender; private String email; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", name=\" + name + \", gender=\" + gender + \", email=\" + email + \"]\"; &#125;&#125; db.properties : 数据库配置信息文件. 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=GoodTime mybatis-config.xml : MyBatis核心配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;properties resource=\"db.properties\" /&gt; &lt;!-- 配置环境-默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将sql映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; UserTest.java : 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pers.huangyuhui.mybatis.bean.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import pers.huangyuhui.mybatis.bean.User;/** * @ClassName: UserTest * @Description: Test Mybatis * @author: HuangYuhui * @date: May 9, 2019 5:26:52 PM * */public class UserTest &#123; InputStream inputStream; SqlSessionFactory sqlSessionFactory; SqlSession sqlSession; @Test public void test() &#123; try &#123; // 读取配置文件 inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); // 根据配置文件构建会话工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 通过SqlSessionFactory创建SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行映射文件中定义的SQL并返回映射结果 User user = sqlSession.selectOne(\"Namespace.UserInfoMapper.SelectUserInfoByID\", 1); System.out.println(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125;&#125; log4j.properties : 日志文件(便于查看MyBatis操作数据库的过程). 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.bean.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 程序运行结果如下所示 1234567891011121314151617Logging initialized using &apos;class org.apache.ibatis.logging.log4j.Log4jImpl&apos; adapter.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.Opening JDBC ConnectionCreated connection 1238080693.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@49cb9cb5]==&gt; Preparing: select id,name,gender,email from Test_MyBatis where id = ? ==&gt; Parameters: 1(Integer)&lt;== Total: 1User [id=1, name=YUbuntu0109, gender=M, email=Gentleman_0109@outlook.com]Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@49cb9cb5]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@49cb9cb5]Returned connection 1238080693 to pool.","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Hi Spring ~","slug":"Hi-Spring","date":"2019-05-09T13:01:53.000Z","updated":"2019-08-25T06:31:00.969Z","comments":true,"path":"2019/05/09/Hi-Spring/","link":"","permalink":"http://yoursite.com/2019/05/09/Hi-Spring/","excerpt":"","text":"学习笔记 : 初识 SpringSpring 简介Spring是由Rod Johnson组织和开发的一个分层的Java SE/EE full-stack(一站式)轻量级开源框架,它以IoC(Inversoin of Control,控制反转)和AOP(Aspect Oriented Programming,面向切面编程)为内核,使用基本的JavaBean来完成以前只可能由EJB(Enterprise Java Beans,Java企业Bean)完成的工作.取代了EJB的臃肿,低效的开发模式哟 ! Spring 框架优点Spring 具有简单,可测试和松耦合等特点,从这个角度出发,Spring可适用于服务器端/任何Java应用的开发. 非侵入式设计 方便耦合,简化开发 支持AOP 支持声明式事务处理 方便程序的测试 方便集成各种优秀的框架 降低Java EE API的使用难度 Spring 核心容器Spring框架的主要功能是通过其核心容器来实现.Spring框架提供了两种核心容器,分别是BeanFatory和ApplicatoinContext. BeanFactoryBeanFactory为基础类型的Ioc容器,简单的说就是一个管理Bean的工厂,它主要负责初始化各种Bean,并调用它们的生命周期方法. ApplicationContextApplicationContext是BeanFactory的子接口,也称为应用上下文,不仅包含了BeanFactory的所有功能,还添加了对国际化,资源访问,事件传播等方面的支持.有两种创建ApplicatoinContext接口实例的方法. 通过ClassPathXmlApplicationContext创建通过类路径classPath中寻找指定的XML配置文件,找到并装载完成ApplicationContext的实例化工作. 通过FileSystemXmlApplicatoinContext创建通过指定的文件系统路径(绝对路径)中寻找指定的XML配置文件,找到并装载完成ApplicationContext的实例化工作. 依赖注入依赖注入的作用就是在使用Spring框架创建对象时,动态地将其所依赖的对象注入Bean组件中,其实现方式通常有两种,一种是属性setter方法注入,另一种是构造方法注入. 属性setter方法注入指Spring容器使用setter方法注入被依赖的实例.通过调用无参的构造器或无参静态工厂方法实例化Bean后,调用该Bean的setter方法,即可实现基于setter方法的依赖注入. 构造方法注入指Spring容器使用的构造方法注入被依赖的实例.基于构造方法的依赖注入通过带参数的构造方法来实现,每个参数代表着一个依赖. Spring 简单示例程序 创建一个简单的Java bean 12345678910111213141516171819package pers.huangyuhui.spring.bean;public class HiSpring5 &#123; private String name; public HiSpring5() &#123; System.out.println(\"The Constructor be called !\"); &#125; public void setName(String name) &#123; System.out.println(\"setName(String name) method be called !\"); this.name = name; &#125; public void ouputName() &#123; System.out.println(\"ouputName() method: my name is \" + name + \" !\"); &#125;&#125; 创建Spring的配置文件: applicationContext.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- id: IOC容器中Bean的唯一标识 class: 通过反射机制在IOC容器中创建Bean(所以要求Bean中必须有无参的构造器). --&gt; &lt;bean id=\"SpringTestID\" class=\"pers.huangyuhui.spring.bean.HiSpring5\"&gt; &lt;!-- 初始化HiSpring类中的属性名为name的值 --&gt; &lt;property name=\"name\" value=\"Spring\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213141516171819202122232425package pers.huangyuhui.spring.bean.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.bean.HiSpring5;public class Spring5Test &#123; @Test public void test() &#123; // 创建Spring的IOC对象 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 从IOC容器中获取Bean实例 HiSpring5 hiSpring5 = (HiSpring5) applicationContext.getBean(\"SpringTestID\"); hiSpring5.ouputName(); &#125;&#125; 程序运行结果如下 12345678May 14, 2019 4:23:28 PM org.springframework.context.support.ClassPathXmlApplicationContext prepareRefreshINFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@a2431d0: startup date [Tue May 14 16:23:28 CST 2019]; root of context hierarchyMay 14, 2019 4:23:28 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitionsINFO: Loading XML bean definitions from class path resource [applicationContext.xml]The Constructor be called !setName(String name) method be called !ouputName() method: my name is Spring !","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Java web:JSP Model","slug":"Java-web-JSP-Model","date":"2019-05-05T14:11:44.000Z","updated":"2019-08-25T06:31:01.002Z","comments":true,"path":"2019/05/05/Java-web-JSP-Model/","link":"","permalink":"http://yoursite.com/2019/05/05/Java-web-JSP-Model/","excerpt":"","text":"学习笔记 : Java web之JSP 开发模型JSP Model1简介 : JSP Model1采用JSP+JavaBean的技术,将页面显示和业务逻辑分开.其中,JSP实现流程控制和页面显示,JavaBean对象封装数据和业务逻辑.这种设计实现了数据,业务逻辑和页面显示的分离,在一定程度上实现了程序开发的模块化,降低了程序修改和维护的难度. JSP Model1 案例案例描述 : 通过一个简单的网络计算器程序来深化对JSP Model1模型的理解. Calculator.java : 封装计算器中的数据,处理业务逻辑. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package pers.huangyuhui.jspmodel.model1.calculator;import java.math.BigDecimal;import java.util.HashMap;import java.util.Map;import java.util.regex.Pattern;/** * @ClassName: Calculator * @Description: 封装计算器中的数据及处理业务逻辑 * @author: HuangYuhui * @date: May 5, 2019 10:10:43 AM * */public class Calculator &#123; private char operator; private String firstNumber; private String secondNumber; private Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;();// 封装错误信息 public String getFirstNumber() &#123; return firstNumber; &#125; public void setFirstNumber(String firstNumber) &#123; this.firstNumber = firstNumber; &#125; public String getSecondNumber() &#123; return secondNumber; &#125; public void setSecondNumber(String secondNumber) &#123; this.secondNumber = secondNumber; &#125; public char getOperator() &#123; return operator; &#125; public void setOperator(char operator) &#123; this.operator = operator; &#125; public Map&lt;String, String&gt; getErrors() &#123; return errors; &#125; public void setErrors(Map&lt;String, String&gt; errors) &#123; this.errors = errors; &#125; // 运算操作 public String caculate() &#123; BigDecimal result = null; BigDecimal firstNum = new BigDecimal(firstNumber); BigDecimal secondNum = new BigDecimal(secondNumber); switch (operator) &#123; case '+': result = firstNum.add(secondNum); break; case '-': result = firstNum.subtract(secondNum); break; case '*': result = firstNum.multiply(secondNum); break; case '/': if (\"0\".equals(secondNumber)) &#123; // throw new RuntimeException(\"除数不能为 0 !\"); return null; &#125; result = firstNum.divide(secondNum); break; default: break; &#125; return result.toString(); &#125; // 验证表单传入的数据是否合法 public boolean validate() &#123; boolean flag = true; Pattern pattern = Pattern.compile(\"\\\\d+\");// 匹配数字 if (firstNumber == null || \"\".equals(firstNumber)) &#123; errors.put(\"firstNumberErrorInfo\", \"第一个运算数不能为空 !\"); flag = false; &#125; else if (!pattern.matcher(firstNumber).matches()) &#123; errors.put(\"firstNumberErrorInfo\", \"第一个运算数必须为数字 !\"); flag = false; &#125; if (secondNumber == null || \"\".equals(secondNumber)) &#123; errors.put(\"secondNumberErrorInfo\", \"第二个运算数不能为空 !\"); flag = false; &#125; else if (!pattern.matcher(secondNumber).matches()) &#123; errors.put(\"secondNumberErrorInfo\", \"第二个运算数必须为数字 !\"); flag = false; &#125; else if (\"0\".equals(secondNumber)) &#123; errors.put(\"secondNumberErrorInfo\", \"被除数不能为 0 !\"); flag = false; &#125; return flag; &#125;&#125; calculator.jsp : 显示网络计算机的页面. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.Map\"%&gt;&lt;jsp:useBean id=\"calculator\" class=\"pers.huangyuhui.jspmodel.model1.calculator.Calculator\"/&gt;&lt;jsp:setProperty property=\"*\" name=\"calculator\"/&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSP Model 1&lt;/title&gt; &lt;style&gt; span&#123; font-size:13px; color:red; &#125; #main&#123; width:600px; margin-left: 425px; &#125; #main tr&#123; height:40px; &#125; #main tr td&#123; width: 50px; &#125; #main tr td input&#123; width: 200px; &#125; .buttom &#123; text-align: center; padding-top: 25px; &#125; .buttom .calculate&#123; margin-right: 65px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;JSP Mode 1 : 计算器&lt;/h3&gt;&lt;hr/&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;table id=\"main\"&gt; &lt;tr&gt; &lt;td&gt; 第一个运算数&lt;/td&gt; &lt;td &gt; &lt;input type=\"text\" name=\"firstNumber\"/&gt; &lt;span&gt;$&#123;errors.firstNumberErrorInfo &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 运算符&lt;/td&gt; &lt;td&gt; &lt;select name=\"operator\" style=\"margin-left:65px\"&gt; &lt;option value=\"+\"&gt;+&lt;/option&gt; &lt;option value=\"-\"&gt;-&lt;/option&gt; &lt;option value=\"*\"&gt;*&lt;/option&gt; &lt;option value=\"/\"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第二个运算符&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"secondNumber\"/&gt; &lt;span&gt;$&#123;errors.secondNumberErrorInfo &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;运算结果: &lt;/td&gt; &lt;td&gt; &lt;% Map&lt;String,String&gt; errorInfo = calculator.getErrors(); if(calculator.validate())&#123; pageContext.getSession().removeAttribute(\"errors\"); %&gt; &lt;font color=\"green\"&gt; &lt;jsp:getProperty property=\"firstNumber\" name=\"calculator\"/&gt; &lt;jsp:getProperty property=\"operator\" name=\"calculator\"/&gt; &lt;jsp:getProperty property=\"secondNumber\" name=\"calculator\"/&gt; = &lt;%=calculator.caculate() %&gt; &lt;% &#125;else&#123; pageContext.getSession().setAttribute(\"errors\",errorInfo); &#125; %&gt; &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=\"buttom\"&gt; &lt;input class=\"calculate\" type=\"submit\" value=\"计算\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果示例图. JSP Model2简介 : JSP Model2架构模型采用JSP+Servlet+JavaBean技术,其将JSP Model1中JSP页面里的流程控制代码提取出来.封装到Servlet中,从而实现了整个程序页面显示,流程控制和业务逻辑的分离.实际上JSP Model2就是MVC设计模式,其中控制器(Colltroller)的角色由Servlet实现,视图(View)的角色由JSP实现,模型(Model)的角色由JavaBean实现. JSP Model2 案例案例描述 : 按照JSP Model2的模型思想编写一个用户注册的简单示例程序. UserBean.java : 封装用户的注册信息. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.jspmodel.model2.register;/** * @ClassName: UserBean * @Description: 封装用户注册信息 * @author: HuangYuhui * @date: May 5, 2019 4:35:21 PM * */public class UserBean &#123; private String name; private String password; private String email; public UserBean(String name, String password, String email) &#123; super(); this.name = name; this.password = password; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; RegisterFormBean.java : 封装并效验注册表单信息的JavaBean. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package pers.huangyuhui.jspmodel.model2.register;import java.util.HashMap;import java.util.Map;/** * @ClassName: RegisterFormBean * @Description: 效验注册表单信息 * @author: HuangYuhui * @date: May 5, 2019 4:37:33 PM * */public class RegisterFormBean &#123; private String name; private String password; private String password2; private String email; // 存储验证表单时发生的错误信息 private Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;(); public RegisterFormBean(String name, String password, String password2, String email) &#123; super(); this.name = name; this.password = password; this.password2 = password2; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getPassword2() &#123; return password2; &#125; public void setPassword2(String password2) &#123; this.password2 = password2; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; // 获取注册信息效验时发生的错误信息 public Map&lt;String, String&gt; getErrors() &#123; return errors; &#125; // 添加注册信息效验时发生的错误信息 public void setErrorsMsg(String error, String errorMsg) &#123; if ((error) != null &amp;&amp; (errorMsg != null)) &#123; errors.put(error, errorMsg); &#125; &#125; // 校验用户注册信息 public boolean validate() &#123; boolean flag = true; if (name == null || name.trim().equals(\"\")) &#123; errors.put(\"nameErrorInfo\", \"请输入用户名 !\"); flag = false; &#125; if (password == null || password.trim().equals(\"\")) &#123; errors.put(\"passwordErrorInfo\", \"请输入密码 !\"); flag = false; &#125; else if (password.length() &gt; 16 || password.length() &lt; 6) &#123; errors.put(\"passwordErrorInfo\", \"请输入6-12位的密码 !\"); flag = false; &#125; if (password != null &amp;&amp; !password.equals(password2)) &#123; errors.put(\"password2ErrorInfo\", \"两次输入的密码不相同 !\"); flag = false; &#125; if (email == null || email.trim().equals(\"\")) &#123; errors.put(\"emailErrorInfo\", \"请输入邮箱地址 !\"); flag = false; &#125; else if (!email.matches(\"[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\\\.[a-zA-Z0-9_-]+)+\")) &#123; errors.put(\"emailErrorInfo\", \"邮箱地址格式错误 !\"); flag = false; &#125; return flag; &#125;&#125; DBUtil.java : 访问数据库的辅助类,充当DAO. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pers.huangyuhui.jspmodel.model2.register;import java.util.HashMap;/** * @ClassName: DBUtil * @Description: 模拟数据库,充当DAO * @author: HuangYuhui * @date: May 5, 2019 4:50:10 PM * */public class DBUtil &#123; private static DBUtil instance = new DBUtil(); private HashMap&lt;String, UserBean&gt; users = new HashMap&lt;String, UserBean&gt;(); private DBUtil() &#123; // 向数据库中添加一条用户数据 UserBean firstUser = new UserBean(\"YUbuntu0109\", \"myPassword\", \"Gentleman_0109@outlook.com\"); users.put(\"YUbuntu0109\", firstUser); &#125; public static DBUtil getInstance() &#123; return instance; &#125; // 获取数据库中指定用户名的数据 public UserBean getUser(String userName) &#123; UserBean user = users.get(userName); return user; &#125; // 向数据库中添加新的用户数据 public boolean insertUser(UserBean user) &#123; if (user == null) &#123; return false; &#125; String userName = user.getName(); if (users.get(userName) != null) &#123; return false; &#125; users.put(userName, user); return true; &#125;&#125; ControllerServlet.java : 控制器,负责处理用户注册的请求. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package pers.huangyuhui.jspmodel.model2.register;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: ColltrollerServlet * @Description: 处理用户注册请求 * @author: HuangYuhui * @date: May 5, 2019 5:01:46 PM * */@WebServlet(\"/ControllerServlet\")public class ControllerServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ControllerServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html;charset=utf-8\"); String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); String password2 = request.getParameter(\"userPassword2\"); String email = request.getParameter(\"userEmail\"); // 效验用户提交的注册表单信息 RegisterFormBean registerFormBean = new RegisterFormBean(name, password, password2, email); if (!registerFormBean.validate()) &#123; request.setAttribute(\"registerFromBean\", registerFormBean); request.getRequestDispatcher(\"/register.jsp\").forward(request, response); return; &#125; // 存储用户注册信息 UserBean userBean = new UserBean(name, password2, email); if (!DBUtil.getInstance().insertUser(userBean)) &#123; request.setAttribute(\"BDUtilErrorInfo\", \"抱歉! 你注册的用户名已存在啦 !\"); request.setAttribute(\"registerFromBean\", registerFormBean); request.getRequestDispatcher(\"/register.jsp\").forward(request, response); return; &#125; request.getSession().setAttribute(\"userBean\", userBean); response.getWriter().print(\"注册成功啦 ! 三秒后将自动跳转到用户注册信息的页面 !\"); response.setHeader(\"refresh\", \"3;url=registerInfo.jsp\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; register.jsp : 用户注册页面. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSP Model 2&lt;/title&gt; &lt;style type=\"text/css\"&gt; h3&#123; text-align:center; &#125; #main&#123; width:600px; margin-left: 450px; &#125; #main tr&#123; height:40px; &#125; #main tr td&#123; width: 50px; &#125; #main tr td input&#123; width: 200px; &#125; span&#123; font-size:13px; color:red; &#125; .buttom &#123; text-align: center; padding-top: 25px; &#125; .buttom .register&#123; margin-right: 70px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册页面&lt;/h3&gt; &lt;hr/&gt; &lt;form action=\"ControllerServlet\" method=\"post\"&gt; &lt;table id=\"main\"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userName\" value=\"$&#123;registerFromBean.name &#125;\"/&gt; &lt;span&gt; $&#123;registerFromBean.errors.nameErrorInfo &#125; $&#123;BDUtilErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" name=\"userPassword\" /&gt; &lt;span&gt; $&#123;registerFromBean.errors.passwordErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" name=\"userPassword2\"/&gt; &lt;span&gt; $&#123;registerFromBean.errors.password2ErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userEmail\" value=\"$&#123;registerFromBean.email &#125;\"/&gt; &lt;span&gt; $&#123;registerFromBean.errors.emailErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=\"buttom\"&gt; &lt;input class=\"register\" type=\"submit\" value=\"注册\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; registerInfo.jsp : 用户注册成功页面. 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSP Model 2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;JSP Mode2 : 用户注册信息&lt;/h3&gt; &lt;hr/&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;sessionScope.userBean == null &#125;\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath &#125;/register.jsp\"&gt;你还未注册! 请注册哟ヾ(●´∀｀●) ~&lt;/a&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;div align=\"center\"&gt; &lt;p&gt;你的姓名: $&#123;sessionScope.userBean.name &#125;&lt;/p&gt; &lt;p&gt;你的邮箱: $&#123;sessionScope.userBean.email &#125;&lt;/p&gt; &lt;/div&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果示例图.","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"VOA:Critics Praise New and Last Avengers Series Film","slug":"VOA-Critics-Praise-New-and-Last-Avengers-Series-Film","date":"2019-05-02T14:13:07.000Z","updated":"2019-08-25T06:31:01.092Z","comments":true,"path":"2019/05/02/VOA-Critics-Praise-New-and-Last-Avengers-Series-Film/","link":"","permalink":"http://yoursite.com/2019/05/02/VOA-Critics-Praise-New-and-Last-Avengers-Series-Film/","excerpt":"","text":"Critics Praise New and Last Avengers Series FilmMany movie critics are giving high praise to Avengers: Endgame,the final film in the superhero series from Walt Disney’s Marvel Studios. 许多影评人对《复仇者联盟:终局》都给予了高度评价,该电影是华特迪士尼漫威工作室超级英雄系列电影的最后一部. As of Tuesday,all but one of 56 Endgame critiques on the Rotten Tomatoes website were rated as positive. 截止到周二,烂番茄网站上出现的56篇有关《终局》的评论中,除了一篇之外 其余都是正面评论. USA Today’s Brain Truitt called the three-hour film “glorious“. He especially praised the time-travel part of the story. He said the movie includes returns to past happenings,which will please fans of superheroes like Iron Man and Thor. 《今日美国》的布莱恩·特鲁伊特称这部三个小时的电影”极其壮观”.他特别赞扬了故事中穿越时空的部分.他说,这部电影中出现的对过去发生的事情的回顾,可以取悦像钢铁侠和雷神这样的超级英雄的粉丝. But “it’s also a singular story”,Truitt said. 但是,”它也是一个奇艺非凡的故事,”特鲁伊说. The final film begins where last year’s Avengers: Infinity War ended,when several beloved heroes appeared to turn to dust. 最后一部电影以去年的《复仇者联盟3:无限战争》结束的地方为开端,当时几位深爱观众喜爱的英雄人物几乎都化为了灰烬. CNN’s Brain Lowry said Endgame is a winning finish. 美国广播电视公司的布莱恩·洛瑞表示,《复仇者联盟:终局》是胜利的结束. “The filmmakers have sought to reward movie-goers with a spectacle that’s epic in every way,” Lowry said. “电影制作人试图用史诗般的场面回报电影观众.” 洛瑞说. He alse wrote that there are several real surprises in the movie.and a lot of humor and emotional moments,as well. 他还写到,电影中还有一些惊喜,以及很多幽默和令人感动的时刻. A.O.Scott of The New York Times said the movie provides a “sense of an ending,” even though many characters are expected to return in future films. 《纽约时报》的斯科特说,这部电影让人们得到一种”结局感”,尽管很多角色都有望在未来的电影中回归. Scott wrote,”We’ve lived with these character and actors playing them for more than 10 years.” He added: “For the most part,it’s nice to see them again,and a little sad to say goodbye.” 斯科特写道: “我们和这些角色以及扮演他们的演员生活在一起已经有10多年.” 他补充道: “在很大程度上,在此见到他们很高兴,但说再见时有点伤感.” Esther Zuckerman of Thrillist agrees. “Endgame reinforces that there’s still a beating heart beneath all the machinery,” she wrote. 推尔名单网站的埃斯特·祖克曼对此表示赞同.”《终局》强化了一个概念,既所有机器下面仍有一颗跳动的心,” 她写到. Not everyone is pleased with the new film,Barry Herhz of Canada’s Globe and Mail newspaper calls Avengers: Endgame “shockingly boring.” 然而,并不是每个人都对这部电影感到满意.加拿大《环球邮报》的巴里·赫兹称《复仇者联盟:终局》”无聊至极.” Movie experts say the film may break records for opening weekend ticket sales in the United States and Canada. That record now stands at $257.7 million,set by Avengers: Infinity War. 电影专家表示,这部电影可能会打破美国和加拿大首映周末票房的记录.目前记录是由《复仇者联盟3:无限战争》创下的2.577亿美元. I’m Ashley Thompson. 重点词汇 critic (n) 批评家,评论家. avenger (n) 复仇者. series (n) 系列,连续. disney (n) 迪斯尼. studio (n) 工作室. endgame (n) 最后阶段,尾声. infinity (n) 无穷,无限大. filmmaker (n) 电影制作人. spectacle (n) 景象,场面. critique (n) 批评,评论文章. rotten (a) 腐烂的,堕落的. glorious (a) 光荣的,辉煌的. singular (a) 非凡的,单一的. beloved (a) 心爱的,挚爱的. epic (a) 史诗的,叙事诗的. emotional (a) 情绪的,感动人的. several (a) 几个的,各自的. reinforce (v) 加强,补充. beneath (ad) 在下方. shockingly (ad) 非常地. 重点短语 were rated as : 被看做,被评为.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"Java web:Cookie and Session","slug":"Java-web-Cookie-and-Session","date":"2019-05-02T01:33:30.000Z","updated":"2019-08-25T06:31:00.996Z","comments":true,"path":"2019/05/02/Java-web-Cookie-and-Session/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-Cookie-and-Session/","excerpt":"","text":"学习笔记 : Java web之会话及其会话技术概述在Web开发中,服务器跟踪用户信息的技术成为会话技术,它指的是一个客户端(浏览器)与Web服务器之间连续发生的一系列请求和响应的过程.为了保存会话过程中产生的数据,在Servlet技术中,提供了两个用于保存会话数据的对象,分别是Cookie和Session. Cookie objectCooke是一种会话技术,它用于将会话过程中的数据保存到用户的浏览器中,从而使浏览器和服务器可以更好地进行数据交互.Cookie在浏览器和服务器之间的传输过程示例图如下 : Cookie application显示用户上次访问时间案例描述 : 当用户请求LastAccessServlet时,服务器会调用HttpServletResponse接口的addCookie(Cookie cookie)方法,该方法会在发送给浏览器的HTTP响应消息中增加一个Set-Cookie头字段,将创建的Cookie对象作为Set-Cookie头字段的值传递给浏览器.示例程序如下 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@WebServlet(\"/LastAccessServlet\")public class LastAccessServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LastAccessServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String lastAccessTime = null;// 最后一次登录的时间 // 获取所有cookie,并将其存放到数组中 Cookie[] cookies = request.getCookies(); for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; // 如果cookie的名称为lastAccess,则获取其对应的cookie值 if (\"lastAccess\".equals(cookies[i].getName())) &#123; lastAccessTime = cookies[i].getValue(); break; &#125; &#125; // 判断是否存在名称为lastAccess的cookie if (lastAccessTime == null) &#123; response.getWriter().println(\"the first to visit this page !\"); &#125; else &#123; response.getWriter().println(\"the time of last visited : \" + lastAccessTime); &#125; // 创建cookie,并将当前时间作为名为lastAccess的cookie的值 String currentTime = new SimpleDateFormat(\"YYYY-MM-dd—&gt;hh:mm:ss\").format(new Date()); Cookie cookie = new Cookie(\"lastAccess\", currentTime); // 设置Cookie对象在客户端的存活时长,默认值为 -1 cookie.setMaxAge(60); // 设置该Cookie项的有效目录路径 cookie.setPath(\"/Cookie-Session_basic\"); // 发送cookie到客户端 response.addCookie(cookie); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Session objectCookie技术可以将用户的信息保存在各自的浏览器中,并且可以在多次请求下实现数据的共享.但是,如果传递的信息比较多,使用Cookie技术显然会增加服务器端程序处理的难度.这时,可以使用Session实现,Session是一种将会话数据保存到服务器端的技术.当浏览器访问Web服务器时,Servlet容器就会创建一个Session对象和ID属性,当客户端后续访问服务器时,只要将标识号传递给服务器,服务器就能判断出该请求是哪个客户端发送的,从而选择与之对应的Session对象为其服务.需要注意的是 : 由于客端户需要接收,记录,回送Session对象的ID,因此,通常情况下,Session是借助Cookie技术来传递ID属性的 ! HttpSession APISession是与每个请求消息紧密相关的,HttpServletRequest接口中定义了用于获取Session对象的getSession()方法,该方法有两种重载形式.1234// 根据传递的参数来判断是否创建新的HttpSession对象public HttpSession getSession(boolean create);// 在相关的HttpSession对象不存在时总是创建新的HttpSession对象public HttpSession getSession(); Session超时管理为了解决不再使用的HttpSession对象会在Web服务器中因积累过多从而导致Web服务器内存耗尽的问题,Web服务器采用了超时限制的办法来判断客户端是否还在继续访问.在会话过程中,会话的有效时间可以在web.xml文件中设置,其默认值由Servlet容器定义.如果想使站点内的所有Web应用程序都起作用,可以配置&lt;Tomcat directory&gt;\\conf\\web.xml文件,如下所示 :1234567&lt;!-- ==================== Default Session Configuration ================= --&gt; &lt;!-- You can set the default session timeout (in minutes) for all newly --&gt; &lt;!-- created sessions by modifying the value below. --&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; Session application实现购物车案例描述 : 购物车的的实现流程如下图所示,当用户使用浏览器访问某个网站的图书列表页面时,如果购买某一本书,那么首先会判断书籍是否存在,如果存在就加入购物车,跳转到购物车中所购买图书的列表页,否则,返回图书列表页面. Book.java : 用于封装图书的信息. 123456789101112131415161718192021222324252627282930313233343536package pers.huangyuhui.session.example.shoppingtrolley;/** * @ClassName: Book * @Description: 封装图书的信息 * @author: HuangYuhui * @date: Apr 29, 2019 4:52:20 PM * */public class Book &#123; private String id; private String name; public Book(String book_id, String book_name) &#123; id = book_id; name = book_name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; BookDB.java : 用于模拟保存所有图书的数据库. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.session.example.shoppingtrolley;import java.util.Collection;import java.util.LinkedHashMap;import java.util.Map;/** * @ClassName: BookDB * @Description: 模拟保存所有图书的数据库 * @author: HuangYuhui * @date: Apr 29, 2019 4:56:02 PM * */public class BookDB &#123; private static Map&lt;String, Book&gt; books = new LinkedHashMap&lt;String, Book&gt;(); static &#123; books.put(\"1\", new Book(\"1\", \"《Java web 入门》\")); books.put(\"2\", new Book(\"2\", \"《Java web 进阶》\")); books.put(\"3\", new Book(\"3\", \"《Spring》\")); books.put(\"4\", new Book(\"4\", \"《Spring MVC》\")); books.put(\"5\", new Book(\"5\", \"《MyBatis》\")); &#125; // 获取所有的图书 public static Collection&lt;Book&gt; getall() &#123; return books.values(); &#125; // 根据指定的id获取图书 public static Book getBook(String book_id) &#123; return books.get(book_id); &#125;&#125; ListBookServlet.java : 用于显示所有可购买图书的列表.通过点击”click to buy”链接,便可将指定的图书添加到购物车中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pers.huangyuhui.session.example.shoppingtrolley;import java.io.IOException;import java.io.PrintWriter;import java.util.Collection;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: ListBookServlet * @Description: 显示所有可购买图书的列表 * @author: HuangYuhui * @date: Apr 29, 2019 5:05:12 PM * */@WebServlet(\"/ListBookServlet\")public class ListBookServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ListBookServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); Collection&lt;Book&gt; bookInfo = BookDB.getall(); printWriter.println(\"&lt;h3 align='center'&gt;All of book be shown as followed&lt;/h3&gt;&lt;hr/&gt;\"); for (Book book : bookInfo) &#123; String url = \"/Cookie-Session_basic/PurchaseServlet?id=\" + book.getId(); printWriter.println(book.getName() + \"&lt;a href=' \" + url + \" '&gt;click to buy ..&lt;/a&gt;&lt;br&gt;\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; PurchaseServlet.java : 功能一: 将用户购买的图书信息保存到Session对象中. 功能二: 在用户购买图书结束后,将页面重定向到用户已经购买的图书列表. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package pers.huangyuhui.session.example.shoppingtrolley;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** * @ClassName: PurchaseServlet * @Description: 购买图书 * @author: HuangYuhui * @date: May 2, 2019 5:17:54 PM * */@WebServlet(\"/PurchaseServlet\")public class PurchaseServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public PurchaseServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得用户购买的商品 String book_id = request.getParameter(\"id\"); // 如果book_id为空,重定向到ListBookServlet页面 if (book_id == null) &#123; response.sendRedirect(\"/ListBookServlet\"); return; &#125; Book book = BookDB.getBook(book_id); // 创建/获取用户的Session对象 HttpSession session = request.getSession(); // 从Session对象中获得用户的购物车 @SuppressWarnings(\"unchecked\") List&lt;Book&gt; cart = (List&lt;Book&gt;) session.getAttribute(\"cart\"); if (cart == null) &#123; // 首次购买,为用户创建一个购物车( 用List集合模拟购物车 ) cart = new ArrayList&lt;Book&gt;(); // 将购物车存入到Session对象中 session.setAttribute(\"cart\", cart); &#125; // 将商品放入购物车 cart.add(book); // 创建Cookie存放Session的标识号( 体现了Session是借助Cookie技术来传递ID属性的 ) // JSeesionID: Tomcat容器对SessionID的称呼 Cookie cookie = new Cookie(\"JSessionID\", session.getId()); cookie.setMaxAge(60 * 30); cookie.setPath(\"/Cookie-Session_basic\"); // 重定向到购物车页面 response.sendRedirect(\"/Cookie-Session_basic/CartServlet\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; CartServlet.java : 展示用户已经购买的图书列表. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package pers.huangyuhui.session.example.shoppingtrolley;import java.io.IOException;import java.io.PrintWriter;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** * @ClassName: CartServlet * @Description: 展示用户已购买的图书列表 * @author: HuangYuhui * @date: Apr 29, 2019 5:30:42 PM * */@WebServlet(\"/CartServlet\")public class CartServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public CartServlet() &#123; super(); &#125; @SuppressWarnings(\"unchecked\") protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); // 引用用户的购物车 List&lt;Book&gt; cart = null; // 标记用户是否买过商品 boolean purFlag = true; // 获得用户的session HttpSession session = request.getSession(false); if (session == null) &#123; purFlag = false; &#125; else &#123; // 获得用户购物车 cart = (List&lt;Book&gt;) session.getAttribute(\"cart\"); // 如果用户的购物车为空 if (cart == null) &#123; purFlag = false; &#125; &#125; if (!purFlag) &#123; printWriter.println(\"Sorry,you don't buy any books ...\"); response.sendRedirect(\"/ListServlet\"); &#125; else &#123; // 显示用户所购买图书的信息 printWriter.println(\"&lt;h3 align='center'&gt;the book be shown as followed which you had bought&lt;/h3&gt;&lt;hr/&gt;\"); for (Book book : cart) &#123; printWriter.println(book.getName() + \"&lt;br&gt;\"); &#125; &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 实现用户登录案例描述 : 当用户进入网站首页时,如果还未登录,则可以通过单击”登录”按钮进入登录界面.在用户登录时,如果用户名及密码正确则登录成功,否则登录失败.登录成功后还可以单击”退出”按钮,回到首页,显示未登录时的界面.用户登录流程图如下所示 : Login.html : 用户登录页面. 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;User login interface&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;Login in&lt;/h3&gt; &lt;hr/&gt; &lt;div align=\"center\"&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;User name&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userpassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" value=\"submit\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; User.java : 封装用户信息. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.session.example.login;/** * @ClassName: User * @Description: 封装用户的信息 * @author: HuangYuhui * @date: Apr 29, 2019 9:21:28 PM * */public class User &#123; private String username; private String password; public User(String name, String password) &#123; this.username = name; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; IndexServlet.java : 用于显示网站的首界面,如果用户没有登录,那么首界面需要提示用户登录,否则,显示用户已经登录的信息. 12345678910111213141516171819202122232425262728293031323334353637383940@WebServlet(\"/IndexServlet\")public class IndexServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public IndexServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); // 创建/获取保存用户信息的Session对象 HttpSession session = request.getSession(); User user = (User) session.getAttribute(\"user\"); if (user == null) &#123; response.getWriter().println(\"你还没有登录 ! 请&lt;a href='Login.jsp'&gt;登录&lt;/a&gt;\"); &#125; else &#123; response.getWriter().println(\"你已经登录 ! 欢迎你 : \" + user.getUsername() + \" !\"); String url = \"LogoutServlet2\"; response.getWriter().println(\"&lt;a href=' \" + url + \" '&gt;退出&lt;/a&gt;\"); // 创建Cookie用于存放Session标识号 Cookie cookie = new Cookie(\"JSessionID\", session.getId()); cookie.setMaxAge(60 * 30); cookie.setPath(\"/Cookie-Session_basic\"); response.addCookie(cookie); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LoginServlet.java : 用于显示用户登录成功后的界面. 12345678910111213141516171819202122232425262728293031323334@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); String username = request.getParameter(\"username\"); String password = request.getParameter(\"userpassword\"); if (\"YUbuntu0109\".equals(username) &amp;&amp; \"demo\".equals(password)) &#123; // 传递用户登录信息 User user = new User(username, password); request.getSession().setAttribute(\"user\", user); response.sendRedirect(\"/Cookie-Session_basic/IndexServlet\"); &#125; else &#123; printWriter.println(\"登录失败 ! 用户名或密码错误 ! &lt;a href='Login.html'&gt;重新登录&lt;/a&gt;\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LogoutServlet.java : 用于完成用户注销功能. 12345678910111213141516171819202122232425@WebServlet(\"/LogoutServlet\")public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); // 将Session对象中的User对象移除 request.getSession().removeAttribute(\"user\"); response.getWriter().println(\"你的账户已成功注销 ! &lt;a href='Login.html'&gt;返回登录页面&lt;/a&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 利用Session实现一次性验证码案例描述 : 在实际开发中,为了保证用户信息的安全,都会在网站登录的界面中添加一次性验证码,从而限制不法分子使用软件暴力猜测密码.一次性验证码的功能同样可以使用Session来实现.该案例代码基于上个案例(实现用户登录)进行改写. Login.jsp : 用户登录页面. 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Login in&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;User login interface&lt;/h3&gt; &lt;hr/&gt; &lt;div align=\"center\"&gt; &lt;form action=\"LoginServlet2\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;User name&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"userName\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userPassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;verification code&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"verificationCode\"/&gt; &lt;img src=\"CheckServlet\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CheckServlet.java : 用于生成验证码图片. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package pers.huangyuhui.session.example.verifcode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.IOException;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@WebServlet(\"/CheckServlet\")public class CheckServlet2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; private static int WIDTH = 100; private static int HEIGHT = 30; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // set specifying the MIME type of the content response.setContentType(\"image/jpeg\"); // 设置浏览器勿缓冲此图片 response.setHeader(\"Pragma\", \"No-cache\"); response.setHeader(\"Cache-Control\", \"no-cache\"); response.setDateHeader(\"Expiress\", 0); // 获取/创建Session对象 HttpSession session = request.getSession(); // 创建内存图像并获得其图像上下文 BufferedImage bufferedImage = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_BGR); // 绘制图像 Graphics graphics = bufferedImage.getGraphics(); // 产生随机的认证码 char[] rands = generateCheckCode(); // 产生图像 drawBackground(graphics); drawRands(graphics, rands); // 结束图形的绘制过程 graphics.dispose(); // 将图像输出到客户端 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // writes an image using an arbitrary ImageWriterthat supports the given format // to an OutputStream. ImageIO.write(bufferedImage, \"JPEG\", byteArrayOutputStream); // Sets the length of the content body in the response In HTTP servlets, // this method sets the HTTP Content-Length header. byte[] buff = byteArrayOutputStream.toByteArray(); response.setContentLength(buff.length); // 将图片写入到Servlet输出流 ServletOutputStream servletOutputStream = response.getOutputStream(); byteArrayOutputStream.writeTo(servletOutputStream); byteArrayOutputStream.close(); servletOutputStream.close(); // 将当前验证码存放到Session中 session.setAttribute(\"check_code\", new String(rands)); // 直接使用下述代码将有问题! 因为Session对象必须在提交响应前获得 // request.getSession().setAttribute(\"check_code\", new String(rands)); &#125; // 生成验证码 private char[] generateCheckCode() &#123; String chars = \"0123456789abcdefghijklmnopqrstuvwxyz\" + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; char[] rands = new char[4]; for (int i = 0; i &lt; 4; i++) &#123; int rand = (int) (Math.random() * (10 + 26 * 2)); rands[i] = chars.charAt(rand); &#125; return rands; &#125; // 绘制验证码 private void drawRands(Graphics g, char[] rands) &#123; g.setColor(Color.RED); g.setFont(new Font(\"Console\", Font.BOLD, 25)); // 在不同的坐标上输出每个字符 g.drawString(\"\" + rands[0], 10, 22); g.drawString(\"\" + rands[1], 30, 22); g.drawString(\"\" + rands[2], 50, 22); g.drawString(\"\" + rands[3], 70, 22); &#125; // 绘制图片背景 private void drawBackground(Graphics g) &#123; // 画背景 g.setColor(Color.LIGHT_GRAY); g.fillRect(0, 0, WIDTH, HEIGHT); // 随机产生200个干扰点 for (int i = 0; i &lt; 200; i++) &#123; int x = (int) (Math.random() * WIDTH); int y = (int) (Math.random() * HEIGHT); int red = (int) (Math.random() * 255); int green = (int) (Math.random() * 255); int blue = (int) (Math.random() * 255); g.setColor(new Color(red, green, blue)); g.drawOval(x, y, 2, 2);// draws the outline of an oval &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LoginServlet.java : 对LoginServlet进行修改,增加对验证码的判断. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package pers.huangyuhui.session.example.verifcode;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/LoginServlet\")public class LoginServlet2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet2() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); String checkCode = request.getParameter(\"verificationCode\"); /* * 获取Session中的验证码信息 */ String saveCheckCode = (String) request.getSession().getAttribute(\"check_code\"); if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password) &amp;&amp; checkCode.equals(saveCheckCode)) &#123; User user = new User(name, password); request.getSession().setAttribute(\"user\", user); response.sendRedirect(\"/Cookie-Session_basic/IndexServlet\"); &#125; else if (checkCode.equals(saveCheckCode)) &#123; printWriter.println(\"登录失败! 用户名或密码 !\"); &#125; else &#123; printWriter.println(\"验证码错误 !\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 程序运行结果 : 用户登录页面.","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"Java web:Servlet listener","slug":"Java-web-Servlet-listener","date":"2019-05-02T01:31:43.000Z","updated":"2019-08-25T06:31:01.005Z","comments":true,"path":"2019/05/02/Java-web-Servlet-listener/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-Servlet-listener/","excerpt":"","text":"学习笔记 : Java web之Servlet事件监听器概述Servlet事件监听器可以监听ServletContext,HttpSession,ServletRequest等域对象的创建和销毁过程,监听这些域对象属性的修改以及感知绑定到HttpSession域中某个对象的状态.根据监听事件的不同可以将其分为三类,具体如下 : 用于监听域对象创建和销毁的事件监听器 : ServletContextListener,HttpSessionListener,ServletRequestListener interface 用于监听域对象属性增加和删除的事件监听器 : ServletContextAttributeListener,HttpSessionAttributeListener,ServletRequestAttributeListener interface 用于监听绑定到HttpSession域中某个对象状态的事件监听器 : HttpSessionBindingListener,HttpSessionActivationListener interface 监听域对象的生命周期简介 : 在Web应用程序的运行期间,Web容器会创建和销毁三个比较的重要的对象: ServletContext,HttpSession,ServletRequest,这些对象被称为域对象,为了监听这些域对象的生命周期,Servlet API中提供了三个对应的接口: ServletContextListener,HttpSessionListener,ServletRequestListener. 案例-监听域对象的生命周期示例代码如下所示1234567891011121314151617181920212223242526272829303132333435363738394041/** * @ClassName: MyServletListener * @Description: 监听域对象的生命周期 * @author: HuangYuhui * @date: May 3, 2019 3:17:56 PM * */@WebListener(value=\"/MyServletListener\")//Servlet 3.0public class MyServletListener implements ServletContextListener, ServletRequestListener, HttpSessionListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\"ServletContext object be initialized !\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\"ServletContext object be destroyed !\"); &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println(\"ServletRequest object be initialized !\"); &#125; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println(\"ServletRequest object be destroyed !\"); &#125; @Override public void sessionCreated(HttpSessionEvent se) &#123; System.out.println(\"HttpSession object be initialized !\"); &#125; @Override public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println(\"HttpSession object be destroyed !\"); &#125;&#125; 为了查看HttpSessionListener和ServletRequestListener监听器的运行效果,可以新建一个index.jsp页面,当运行Tomcat服务器第一次访问index.jsp时,Web容器除了为这次请求创建了ServletRequest对象外,还创建了与这个浏览器对应的HttpSession对象,当这两个对象在被创建时,Web容器会调用监听器MyServeltListener中相应的方法,当Web服务器完成这次请求后,ServletRequest对象会随之销毁.需要注意的是: 如果刷新index.jsp页面,会再次触发ServletRequestListener监听器接口中的方法,继而创建新的ServletRequest对象,但不会创建新的HttpSession对象,这是因为Web容器会为每次访问请求创建一个新的ServletRequest对象,而对于同一个浏览器在会话期间的后续访问是不会再创建新的HttpSession对象的. 案例-统计当前在线人数案例描述 : 通常情况下,当一个用户在进入某个网站时服务器就会为其创建一个HttpSessionListener对象,当用户离开网站时HttpSessionListener对象就会别销毁.因此,可以使用实现了HttpSessionListener接口的监听器来统计网站的在线人数. login.jsp : 用于显示当前在线人数. 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HttpSessionListener案例: 统计当前在线人数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;当前在线人数为: &lt;%=application.getAttribute(\"count\")%&gt;&lt;/h3&gt; &lt;a href=\"&lt;%=response.encodeURL(\"logout.jsp\")%&gt;\"&gt;退出登录&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; CountListener.java : 用于统计当前在线人数. 1234567891011121314151617181920212223242526272829/** * @ClassName: CountListener * @Description: 统计在线人数 * @author: HuangYuhui * @date: May 3, 2019 3:40:59 PM * */@WebListener(value = \"/CountListener\")public class CountListener implements HttpSessionListener &#123; private int count = 0;// 在线人数 @Override // Session对象创建时count++ public void sessionCreated(HttpSessionEvent se) &#123; count++; ServletContext servletContext = se.getSession().getServletContext(); servletContext.setAttribute(\"count\", Integer.valueOf(count)); &#125; @Override // Session对象销毁时count-- public void sessionDestroyed(HttpSessionEvent se) &#123; count--; ServletContext servletContext = se.getSession().getServletContext(); servletContext.setAttribute(\"count\", Integer.valueOf(count)); &#125;&#125; logout.jsp : 用于注销用户登录. 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HttpSessionListener案例: 统计当前在线人数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% session.invalidate();// 使当前的Session失效 %&gt; &lt;h3 align=\"center\"&gt;你已退出本系统&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 监听域对象中的属性变更简介 : Servlet API 中提供了三个用于监听某个域对象属性变更的接口: ServletContextAttributelistener,HttpSessionAttributerListener和ServletRequestAttributeListener.这三个接口都定义了相同名称的方法,分别用于处理被监听对象属性的增加,删除和替换. 案例-监听域对象的属性变更 attribute.jsp : 设置各个域对象的属性.12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;案例:监听域对象的属性变更&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;测试域对象属性信息监听器的页面&lt;/h3&gt; &lt;% getServletContext().setAttribute(\"name\", \"YUbuntu0109\"); getServletContext().setAttribute(\"name\", \"https://YUbuntu0109.github.io\"); getServletContext().removeAttribute(\"name\"); session.setAttribute(\"name\", \"YUbuntu0109\"); session.setAttribute(\"name\",\"https://YUbuntu0109.github.io\"); session.removeAttribute(\"name\"); request.setAttribute(\"name\", \"YUbuntu0109\"); request.setAttribute(\"name\", \"https://YUbuntu0109.github.io\"); request.removeAttribute(\"name\"); %&gt; &lt;/body&gt;&lt;/html&gt; MyAttributeListener.java : 用于监听各个域对象属性的变更. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @ClassName: MyAttributeListener * @Description: 监听域对象的属性变更 * @author: HuangYuhui * @date: May 3, 2019 4:18:40 PM * */@WebListener(\"/MyAttributeListener\")public class MyAttributeListener implements ServletContextAttributeListener, HttpSessionAttributeListener, ServletRequestAttributeListener &#123; @Override public void attributeAdded(ServletContextAttributeEvent event) &#123; System.out.println(\"ServletContext 添加属性: name=\" + event.getServletContext().getAttribute(event.getName())); &#125; @Override public void attributeReplaced(ServletContextAttributeEvent event) &#123; System.out.println(\"ServletContext 替换属性: name=\" + event.getServletContext().getAttribute(event.getName())); &#125; @Override public void attributeRemoved(ServletContextAttributeEvent event) &#123; System.out.println(\"ServletContext 移除属性: \" + event.getName()); &#125; @Override public void attributeAdded(ServletRequestAttributeEvent srae) &#123; System.out.println(\"HttpRequest 添加属性: name=\" + srae.getServletRequest().getAttribute(srae.getName())); &#125; @Override public void attributeReplaced(ServletRequestAttributeEvent srae) &#123; System.out.println(\"HttpRequest 替换属性: name=\" + srae.getServletRequest().getAttribute(srae.getName())); &#125; @Override public void attributeRemoved(ServletRequestAttributeEvent srae) &#123; System.out.println(\"HttpRequest 移除属性: \" + srae.getName()); &#125; @Override public void attributeAdded(HttpSessionBindingEvent event) &#123; System.out.println(\"HttpSession 添加属性: name=\" + event.getSession().getAttribute(event.getName())); &#125; @Override public void attributeReplaced(HttpSessionBindingEvent event) &#123; System.out.println(\"HttpSession 替换属性: name=\" + event.getSession().getAttribute(event.getName())); &#125; @Override public void attributeRemoved(HttpSessionBindingEvent event) &#123; System.out.println(\"HttpSession 移除属性: \" + event.getName()); &#125;&#125; 程序运行结果如下所示. 123456789ServletContext 添加属性: name=YUbuntu0109ServletContext 替换属性: name=https://YUbuntu0109.github.ioServletContext 移除属性: nameHttpSession 添加属性: name=YUbuntu0109HttpSession 替换属性: name=https://YUbuntu0109.github.ioHttpSession 移除属性: nameHttpRequest 添加属性: name=YUbuntu0109HttpRequest 替换属性: name=https://YUbuntu0109.github.ioHttpRequest 移除属性: name 案例-统计当前在线人数名单案例描述 : 在上述统计当前在线人数的案例中,实际上统计的是Web应用当前的所有会话的数目.它无法统计所有所有在线用户的具体名单! 下面我们通过使用HttpSessionBindingListener接口不仅可以统计在线用户的数量,还可以统计在线用户的名单. login.jsp : 用户登录页面. 1234567891011121314151617181920212223242526272829303132&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;案例:统计登录用户的在线名单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;用户登录页面&lt;/h3&gt; &lt;hr/&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table width=\"280px\" cellpadding=\"0\" align=\"center\"&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"userName\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userPassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"50\" colspan=\"2\" align=\"center\"&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;span style=\"font-size:13px;color:red\"&gt;$&#123;errorMsg &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; User.java : 封装用户信息. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package pers.huangyuhui.servletlistener.example.onlinenumber2;import javax.servlet.http.HttpSessionBindingEvent;import javax.servlet.http.HttpSessionBindingListener;/** * @ClassName: User * @Description: 封装用户信息 * @author: HuangYuhui * @date: May 4, 2019 9:10:47 AM * */public class User implements HttpSessionBindingListener &#123; private String id; private String username; private String password; public User(String id, String name, String password) &#123; this.id = id; this.username = name; this.password = password; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public void valueBound(HttpSessionBindingEvent event) &#123; // System.out.println(\"将新用户添加到在线名单 : \" + event.getName() + \"=\" + event.getValue()); OnlineUser.getInstance().addUser(this); &#125; @Override public void valueUnbound(HttpSessionBindingEvent event) &#123; // System.out.println(\"从在线名单中移除该用户 : \" + event.getName() + \"=\" + event.getValue()); OnlineUser.getInstance().removeUser(this); &#125;&#125; OnlineUser.java : 用于存储和获取在线用户列表. 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.servletlistener.example.onlinenumber2;import java.util.HashMap;import java.util.Map;/** * @ClassName: OnlineUser * @Description: 存储及获取在线用户列表 * @author: HuangYuhui * @date: May 4, 2019 9:14:09 AM * */public class OnlineUser &#123; private OnlineUser() &#123; &#125; private static OnlineUser instance = new OnlineUser(); public static OnlineUser getInstance() &#123; return instance; &#125; private Map&lt;String, String&gt; userMap = new HashMap&lt;&gt;(); // 将用户添加至在线列表 public void addUser(User user) &#123; userMap.put(user.getId(), user.getUsername()); &#125; // 将用户从在线列表中移除 public void removeUser(User user) &#123; userMap.remove(user.getId()); &#125; // 返回在线的用户列表 public Map&lt;String, String&gt; getOnlineUsers() &#123; return userMap; &#125;&#125; LoginServlet.java : 处理用户登录请求. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package pers.huangyuhui.servletlistener.example.onlinenumber2;import java.io.IOException;import java.util.Map;import java.util.UUID;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LoginServlet * @Description: 处理用户登录请求 * @author: HuangYuhui * @date: May 4, 2019 9:30:23 AM * */@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); String username = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); if (username != null &amp;&amp; !username.trim().equals(\"\")) &#123; User user = new User(UUID.randomUUID().toString(), username, password); request.getSession().setAttribute(\"user\", user); Map&lt;String, String&gt; onlineUsers = OnlineUser.getInstance().getOnlineUsers(); request.setAttribute(\"onlineUsers\", onlineUsers); request.getRequestDispatcher(\"/showOnlineUsers.jsp\").forward(request, response); &#125; else &#123; request.setAttribute(\"errorMsg\", \"用户名不能为空 !\"); request.getRequestDispatcher(\"/login.jsp\").forward(request, response); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LogoutServlet.java : 注销用户登录信息. 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.servletlistener.example.onlinenumber2;import java.io.IOException;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LogoutServlet * @Description: 注销用户登录信息 * @author: HuangYuhui * @date: May 4, 2019 9:54:27 AM * */@WebServlet(\"/LogoutServlet\")public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getSession().removeAttribute(\"user\"); Map&lt;String, String&gt; onlineUsers = OnlineUser.getInstance().getOnlineUsers(); request.setAttribute(\"onlineUsers\", onlineUsers); request.getRequestDispatcher(\"/showOnlineUsers.jsp\").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; showOnlineUsers.jsp : 显示所有用户的登录信息以及当前登录的用户. 1234567891011121314151617181920212223242526&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;应用案例:统计登录用户的在线名单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;用户在线名单如下所示&lt;/h3&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;sessionScope.user == null &#125;\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath &#125;/login.jsp\"&gt;登录&lt;/a&gt;&lt;br&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; 你已成功登录! 欢迎你: $&#123;sessionScope.user.username &#125; &lt;a href=\"$&#123;pageContext.request.contextPath &#125;/LogoutServlet\"&gt;退出&lt;/a&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;hr/&gt; &lt;c:forEach var=\"user\" items=\"$&#123;requestScope.onlineUsers &#125;\"&gt; &lt;p align='center'&gt;用户名: $&#123;user.value&#125;&lt;/p&gt; &lt;/c:forEach&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果示例图. 感知被HttpSession绑定的事件监听器暂略写 ..","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"Java web:Filter","slug":"Java-web-Filter","date":"2019-05-02T01:29:12.000Z","updated":"2019-08-25T06:31:01.001Z","comments":true,"path":"2019/05/02/Java-web-Filter/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-Filter/","excerpt":"","text":"学习笔记 : Java web之过滤器简介Filter被称作过滤器或者拦截器,作为Servlet 2.3中新增的技术,可以实现用户在访问某个目标资源之前,对访问的请求和响应进行相应处理.其基本功能就是对Servlet容器调用Servlet的过程进行拦截,从而在Servlet响应处理前后实现一些特殊功能. Filter过滤器实现了javax.servlet.Filter接口.在Filter接口中定义了三个方法,其代表Filter的生命周期,如下所示 :123456// 用于初始化过滤器init(FilterConfig filterConfig);// 客户端请求时被调用(Filter所有的工作都集中在此方法中)doFilter(ServletRequest request,ServletResponse response,FilterChain chain);// 在Web应用程序卸载时被调用destory(); Filter annotation简介 : Servlet3.0提供@WebFilter注解将一个实现了javax.servlet.Filter接口的类定义为过滤器,继而当我们在Web应用中使用过滤器时无需在web.xml文件中配置Filter映射 ! 注解示例-拦截用户的所有请求1234@WebFilter(filterName=\"/MyFilter\" , urlPatterns= \"/*\")public class MyFilter implements Filter &#123; ···&#125; 注解示例-拦截不同方式的访问请求描述 : 根据被Servlet容器调用的方式来拦截指定的资源.其调用方式如下所示 :1234567891011121314package javax.servlet;/** * Enumeration of filter dispatcher types. * * @since Servlet 3.0 */public enum DispatcherType &#123; FORWARD, INCLUDE, REQUEST, ASYNC, ERROR&#125; 下面以FORWARD(如果目标资源是通过RequestDispatcher的forward()方法访问时,该过滤器将会被调用)为例,演示Filter对转发请求的过滤效果. ServletTest : 将请求转发给index.jsp页面. 1234567891011121314151617181920@WebServlet(\"/ServletTest\")public class ServletTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ServletTest() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(\"/index.jsp\").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; FilterTest.java : 拦截index.jsp页面. 1234567891011121314151617181920// Servlet 3.0@WebFilter(filterName = \"/FilterTest\", urlPatterns = \"/index.jsp\", dispatcherTypes = &#123; DispatcherType.FORWARD &#125;) public class FilterTest implements Filter &#123; public FilterTest() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; response.getWriter().println(\"This is Filter !\"); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125; FilterConfig interface简介 : 为了获取Filter程序在web.xml中的配置信息,Servlet API提供了一个FilterConfig接口,该接口封装了Filter程序在web.xml中的所有注册信息.并提供了一系列获取这些配置信息的方法.(同时适用于注解的哟 ~) getInitParameter(String name)描述 : 下面以接口FilterConfig接口中的getInitParameter(String name)方法为例,演示FilterConfig接口的作用. FilterConfigTest.java : 获取注解中指定名称的初始化参数值. 12345678910111213141516171819202122232425262728// 使用注解为该Filter设置初始化参数: initParams= &#123;@WebInitParam(name=\"encoding\",value=\"utf-8\")&#125;@WebFilter(filterName = \"/FilterConfigTest\", urlPatterns = \"/MyServlet\", initParams = &#123; @WebInitParam(name = \"encoding\", value = \"utf-8\") &#125;)public class FilterConfigTest implements Filter &#123; FilterConfig filterConfig; String characterEncoding = null; public FilterConfigTest() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; response.setContentType(\"text/html;charset=utf-8\"); characterEncoding = filterConfig.getInitParameter(\"encoding\"); response.getWriter().println(\"encoding的初始化参数的值为: \" + characterEncoding); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; this.filterConfig = fConfig; &#125;&#125; FilterConfigTest.java : 获取web.xml中指定名称的初始化参数值(代码同FilterConfigTest.java),web.xml中的配置信息如下 : 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Filter_basic&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;FilterConfigTest&lt;/filter-name&gt; &lt;filter-class&gt;pers.huangyuhui.filter.filterconfig.FilterConfigTest&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;gbk2312&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterConfigTest&lt;/filter-name&gt; &lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Filter applicationFilter 实现用户自动登录案例描述 : 使用Cookie实现用户自动登录后,当客户端访问服务器的Servlet时,所有的Servelt都需要对用户的Cookie信息进行校验,这样势必会导致在Servlet程序中书写大量重复的代码.为了解决这个问题,可以在Filter程序中实现Cookie的校验.由于Filter可以对服务器的所有请求进行拦截,因此,一旦请求通过Filter程序,就相当于用户信息校验通过,然后Servelt程序就可以根据获取到的用户信息实现自动登录功能了. User.java : 封装用户的信息. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.filter.example.autologin;/** * @ClassName: User * @Description: 封装用户的信息 * @author: HuangYuhui * @date: May 1, 2019 7:24:26 PM * */public class User &#123; private String username; private String password; public User(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; login.jsp : 用户登录页面. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;应用案例 : Filter实现用户自动登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;用户登录页面&lt;/h3&gt; &lt;hr/&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table width=\"380px\" cellpadding=\"0\" align=\"center\"&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"userName\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userPassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"40\" align=\"center\"&gt;自动登录时间&lt;/td&gt; &lt;td&gt; &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60 &#125;\"/&gt;一小时 &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60*24 &#125;\"/&gt;一天 &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60*24*7 &#125;\"/&gt;一周 &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60*24*31 &#125;\"/&gt;一个月 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"50\" colspan=\"2\" align=\"center\"&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;span style=\"font-size:13px;color:red\"&gt;$&#123;errorMsg &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; LoginServlet.java : 处理用户的登录请求. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package pers.huangyuhui.filter.example.autologin;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LoginServlet * @Description: 处理用户的登录请求 * @author: HuangYuhui * @date: May 1, 2019 9:38:38 PM * */@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); String autoLogin = request.getParameter(\"autologin\"); // 检查用户登录信息 if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password)) &#123; // 将用户对象存入session域 User user = new User(name, password); request.getSession().setAttribute(\"user\", user); if (autoLogin != null) &#123; Cookie cookie = new Cookie(\"autologin\", name + \"-\" + password);// 加密 cookie.setMaxAge(Integer.parseInt(autoLogin)); cookie.setPath(request.getContextPath()); response.addCookie(cookie);// 发送自动登录的cookie &#125; response.sendRedirect(\"index.jsp\"); // 跳转到首页 &#125; else &#123; request.setAttribute(\"errorMsg\", \"提示: 用户名或密码错误 !\"); request.getRequestDispatcher(\"/login.jsp\").forward(request, response); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LoginServlet.java : 注销用户的登录信息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.filter.example.autologin;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LogoutServlet * @Description: 注销用户登录的信息 * @author: HuangYuhui * @date: May 1, 2019 9:47:49 PM * */@WebServlet(\"/LogoutServlet\")public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 将Session会话中保存的User对象删除 request.getSession().removeAttribute(\"user\"); // 将自动登录的Cookie删除 Cookie cookie = new Cookie(\"autologin\", \"msg\"); cookie.setPath(request.getContextPath()); cookie.setMaxAge(0); response.addCookie(cookie); response.sendRedirect(request.getContextPath() + \"/index.jsp\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; AutoLoginFilter.java : 拦截用户登录的访问请求. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package pers.huangyuhui.filter.example.autologin;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebFilter;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;/** * @ClassName: AutoLoginFilter * @Description: 拦截用户登录的访问请求 * @author: HuangYuhui * @date: May 1, 2019 9:51:23 PM * */@WebFilter(filterName = \"/AutoLoginFilter\", urlPatterns = \"/*\")public class AutoLoginFilter implements Filter &#123; public AutoLoginFilter() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request2 = (HttpServletRequest) request; Cookie[] cookies = request2.getCookies(); // 获取一个名为`autologin`的cookie String autoLogin = null; for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; if (\"autologin\".equals(cookies[i].getName())) &#123; autoLogin = cookies[i].getValue(); break; &#125; &#125; // 验证用户登录信息 if (autoLogin != null) &#123; String[] parts = autoLogin.split(\"-\"); String name = parts[0]; String password = parts[1]; if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password)) &#123; // 将用户的登录信息封装到User对象并存入Sesssion域中,既而完成自动登录 User user = new User(name, password); request2.getSession().setAttribute(\"user\", user); &#125; &#125; chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125;","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"Java web:请求与响应","slug":"Java-web-请求与响应","date":"2019-05-02T01:28:42.000Z","updated":"2019-08-25T06:31:01.006Z","comments":true,"path":"2019/05/02/Java-web-请求与响应/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-请求与响应/","excerpt":"","text":"学习笔记 : Java web之请求与响应简介Servlet最主要的作用就是处理客户端请求,并向客户端做出响应.为此,针对Servlet的每次请求,Web服务器在调用service()之前,都会创建两个对象,分别是: HttpServletRequest和HttpServletResponse.其中HttpServletRequest用于封装HTTP请求消息,简称request对象.HttpServletResponse用于封装HTTP响应消息,简称response对象.下面通过示例图来展示浏览器访问Servlet的交互过程. HttpServletResponseHttpServletResponse接口继承自ServletResponse,用于封装HTTP响应消息.由于HTTP响应消息分为 : 状态行,响应消息头,消息体三部分,因此,在HttpServletResponse接口中定义了向客户端发送响应状态码,响应消息头,响应消息体的方法. HttpServletResponse application中文输出乱码问题由于计算机中的数据都是以二进制形式存储的,因此,当传输文本时,就会发生字符和字节之间的转换.字符与字节之间是通过查码表完成的,将字符转换为字节的过程称为编码,相反称为解码.如果两者使用的码表不一致就会导致乱码问题.可通过以下示例程序中的方法解决此问题.12345678910111213141516171819202122232425262728@WebServlet(\"/SetCharsetServlet\")public class SetCharsetServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SetCharsetServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 第一种解决乱码的方式 // response.setCharacterEncoding(\"utf-8\"); // response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\"); // 第二种解决乱码的方式 response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); printWriter.write(\"中文\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 网页定时刷新并跳转在HTTP中定义了一个Refresh头字段,他可以通知浏览器在指定的时间自动刷新并跳转到其它页面.示例程序如下.12345678910111213141516171819202122@WebServlet(\"/SetHeaderServlet\")public class SetHeaderServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SetHeaderServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 实现网页的定时刷新并跳转 response.setHeader(\"Refresh\",\"5;URL=https://yubuntu0109.github.io\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 请求重定向在某些情况下,针对客户端的请求,一个Servlet类可能无法完成全部工作.这时,可以使用请求重定向来完成.所谓的请求重定向,指的是Web服务器接受到客户端的请求后,可能由于某些条件限制,不能访问当前请求URL所指的Web资源,而是指定了一个新的资源路径,让客端户重新发送请求. 用户登录界面 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;login in&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;User login interface&lt;/h3&gt; &lt;hr&gt; &lt;div align=\"center\"&gt; &lt;form action=\"SendRedirectTest\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;User name&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userpassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" name=\"login in\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 登录成功页面 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;success&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\" &gt;weclome&lt;/h3&gt; &lt;hr&gt; &lt;p align=\"center\"&gt;success to login in !&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 编写处理用户登录请求的Servlet程序 12345678910111213141516171819202122232425262728293031@WebServlet(\"/SendRedirectServlet\")public class SendRedirectServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SendRedirectServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置编码 response.setContentType(\"text/html;charset=utf-8\"); // 使用HttpServletRequest对象的getParameter()方法获取用户名及密码 String name = request.getParameter(\"username\"); String password = request.getParameter(\"userpassword\"); if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password)) &#123; response.sendRedirect(\"Redirection/welcome.jsp\"); &#125; else &#123; response.sendRedirect(\"login.jsp\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; HttpServletRequestHttpServletRequest接口继承自ServletRequest,用于封装HTTP请求消息.由于HTTP请求消息分为 : 请求行,请求消息头,请求消息体三部分,因此,在HttpServletRequest接口中定义了获取请求行,请求头,请求消息体的相关方法. HttpServletRequest application利用Referer请求头防止盗链编写一个Servlet类,其负责提供下载内容,但它要求下载请求的链接必须是通过本网站进入的,否则,会将请求转发给下载说明的HTML页面.123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @ClassName: DownManagerServlet * @Description: 利用`Referer`请求头防止盗链 * @author: HuangYuhui * @date: Apr 29, 2019 9:41:11 AM * */@WebServlet(\"/DownManagerServlet\")public class DownManagerServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public DownManagerServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); // 获取referer头的值: http://localhost:8080/Request-Response_basic/DownManagerServlet String referer = request.getHeader(\"referer\"); // 获取访问地址 // 由于第一次请求DownManagerServlet时,请求消息中并不包含referer请求头, // 所以DownManagerServlet会将下载请求转发给了downlaod.html页面 String sitePart = \"http://\" + request.getServerName(); if (referer != null &amp;&amp; referer.startsWith(sitePart)) &#123; printWriter.println(\"dealing download ...\"); &#125; else &#123; // 非法下载请求将跳转到download.html页面 request.getRequestDispatcher(\"HttpServletRequest/download.html\").forward(request, response); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 请求参数的中文乱码问题HttpServletRequest接口中,提供了一个setCharacterEncoding()方法,该方法用于设置request对象的解码方式.但该方法只对POST提交方式有效(错误结论),为了解决GET方式提交表单的中文乱码问题,可以首先使用ISO 8859-1将用户名重新编码,然后使用码表GBK进行解码.示例程序略.. RequestDispatcher当一个Web资源收到客户端的请求后,如果希望服务器通知另外一个资源去处理请求,这时,除了使用sendRedirect()方法实现请求重定向外,还可以通过RequestDispatcher接口的实例对象来实现.在ServletRequest接口中定义了一个获取RequestDispatcher对象的方法. 获取RequestDispatcher对象的方法 123// 返回封装了某个路径所指资源的RequestDispather对象.其中,参数path必须// 以'/'开头,用于表示当前Web应用的根目录getRequestDispatcher(String path); 获取RequestDispatcher对象后,最重要的工作是通知其他Web资源处理当前的Servlet请求,为此,在RequestDispather接口中,定义了两个相关的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 该方法用于将请求从一个Servlet传递给另外的一个Web资源(请求转发)// 注意: 该方法必须在响应提交给客户端之前被调用,否则抛出IllegalStateExceptionforward(ServletRequests request,ServletResponse response);// 该方法用于将其他的资源作为当前响应内容包含进来include(ServletRequest request,ServletResponse response);``` ### RequestDispatcher applicatoin#### forward()实现请求转发*通过使用`forward()`方法,将当前RequestForwardServlet的请求转发到ResultServlet页面*1. *RequestForwardServlet示例程序*```java/** * @ClassName: RequestForwardServlet * @Description: 请求转发:forword() * @author: HuangYuhui * @date: Apr 29, 2019 11:07:03 AM * */@WebServlet(\"/RequestForwardServlet\")public class RequestForwardServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public RequestForwardServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); request.setAttribute(\"websiteURL\", \"https://yubuntu0109.github.io\"); // request.getRequestDispatcher(\"/ResultServlet\").forward(request, response); RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/ResultServlet\"); requestDispatcher.forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; ResultServlet示例程序 1234567891011121314151617181920212223242526272829/** * @ClassName: ResultServlet * @Description: 请求转发:forword() * @author: HuangYuhui * @date: Apr 29, 2019 11:12:47 AM * */@WebServlet(\"/ResultServlet\")public class ResultServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ResultServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); response.getWriter().println(\"&lt;p align='center'&gt;\" + \"my personal blog website address : \" + request.getAttribute(\"websiteURL\") + \"&lt;/p&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 页面显示结果 1my personal blog website address : https://yubuntu0109.github.io 由结果可知,forward()方法不仅可以实现请求转发,还可以使转发页面和转发到的页面共享数据.需要注意的是: 存储在request对象中的数据只对当前请求有效,而对其他请求无效. include()实现请求包含请求包含指的是使用include方法将Servlet请求转发给其他Web资源进行处理,与请求转发不同的是,在请求包含返回的响应消息中,既包含当前Servlet的响应消息也包含其他Web资源所做出的响应消息. 编写IncludingServlet程序,其中调用include()方法请求包含IncludedServlet程序. 123456789101112131415161718192021222324252627282930313233/** * @ClassName: IncludingServlet * @Description: 请求包含:include() * @author: HuangYuhui * @date: Apr 29, 2019 11:28:25 AM * */@WebServlet(\"/IncludingServlet\")public class IncludingServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public IncludingServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 因为请求IncludingServelt时,用于封装响应消息的HttpServletResponse对象已经创建,该对象在编码时采用的是默认的: ISO 8859-1 // 所以当客户端对接收到的数据进行解码时,Web服务器会继续保持调用HttpServeltResponse对象中的信息,从而使IncludedServlet中 // 的输出内容发生乱码.为解决此问题需在IncludingServlet中提前设置如下编码方式 . response.setContentType(\"text/html;charset=utf-8\"); RequestDispatcher resDispatcher = request.getRequestDispatcher(\"/IncludedServelt?name=YUbuntu0109\"); resDispatcher.include(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; IncludedServlet程序 123456789101112131415161718192021222324252627282930/** * @ClassName: IncludedServlet * @Description: 请求包含:include() * @author: HuangYuhui * @date: Apr 29, 2019 11:33:42 AM * */@WebServlet(\"/IncludedServelt\")public class IncludedServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public IncludedServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); printWriter.println(\"中文&lt;br&gt;\"); printWriter.println(\"user name : \" + request.getParameter(\"name\") + \"&lt;br&gt;\"); printWriter.println(\"request.getRequestURI() : \" + request.getRequestURI()); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 页面显示结果 123中文user name : YUbuntu0109request.getRequestURI() : /Request-Response_basic/IncludingServlet 注意: 使用forward()实现请求转发或使用include()方法实现请求包含后,浏览器显示的URL地址是不会变化的 !","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"VOA:Americans`Favorite Thing To Do","slug":"VOA-Americans-Favorite-Ting-To-Do","date":"2019-04-28T07:49:03.000Z","updated":"2019-08-25T06:31:01.091Z","comments":true,"path":"2019/04/28/VOA-Americans-Favorite-Ting-To-Do/","link":"","permalink":"http://yoursite.com/2019/04/28/VOA-Americans-Favorite-Ting-To-Do/","excerpt":"","text":"Americans’Favorite Thing To DoAmericans’s favorite activity has long been said to be baseball. But a new study by the U.S. government suggests that is not true. The Bureau of Labor Statistics says Americans seem to enjoy watching television more than anything else. 美国人最喜欢的运行据说是棒球,但美国政府的一项新研究表明,事实并非如此.美国劳工统计局说,美国人似乎最喜欢看电视. Researchers examined how Americans age 15 and older spent their free time during the years 2013 to 2017. They learned that Americans spend almost three hours every day watching TV. 研究人员调查了15岁及以上的美国人在2013年至2017年期间是如何度过空闲时间的.他们了解到美国人每天几乎花三个小时看电视. The activity includes watching movies,recorded program.and live broadcasts. 观看的电视内容包括电影,录制节目和现场直播. So who watches television the most? People over the age of 65,researchers found.Older people clock in at more than four and a half hours of television every day. 那么哪个群体看电视最多呢? 研究人员发现,是年龄超过65岁的老人,老年人每天去看电视的时间超过四个半小时. Parents with small children spent the least amount of time in front of the tube,as TV is sometimes called. 有小孩的父母花在电视机前的时间最少(电视有时也被称为”TV”) Researchers discovered something else,too : Men watch about 30 minutes more television than women each day. 研究人员还发现另一件事: 男性平均每天看电视的时间比女性多30分钟. I’m Kelly Jean Kelly. 重点词汇 bureau (n) 局,处. labor (n) 劳动,工作. statistics (n) 统计,统计学. examine (v) 检查,调查.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:A Lifetime of Exercise Slows Aging Process","slug":"VOA-A-Lifetime-of-Exercise-Slows-Aging-Process","date":"2019-04-27T08:20:30.000Z","updated":"2019-08-25T06:31:01.091Z","comments":true,"path":"2019/04/27/VOA-A-Lifetime-of-Exercise-Slows-Aging-Process/","link":"","permalink":"http://yoursite.com/2019/04/27/VOA-A-Lifetime-of-Exercise-Slows-Aging-Process/","excerpt":"","text":"A Lifetime of Exercise Slows Aging ProcessFrom VOA learning English,this is the Health&amp;Lifestyle report. 这里是美国之音——健康&amp;生活方式节目. If you have been meaning to add more exercise to your daily routine,you may want to start sooner rather than later. 如果你已经打算每天增加点锻炼,或许你应该尽早开始. A 2018 study has found a lifetime of regular exercise and activity can slow down the aging process. 2018年的一项研究发现,在人的一生中,定期锻炼和参加活动可以减缓衰老过程. Researchers at Britain’s University of Birmingham and King’s Collage London say that getting older should not necessarily mean becoming more weak or sick. Their research shows that a commitment to a life of movement and exercise my help us live ont only longer,but also healthier. 英国伯明翰大学和伦敦国王学院的研究人员说,年龄的增长不一定意味着变得更加虚弱.他们的研究表明,坚持运动和锻炼可以使我们的寿命加长,而且身体会更健康. For their study,the researchers looked at two groups. 关于他们的研究,研究人员观察了两个小组. The first group was made up of 125 non-professional cyclists between the ages of 55 to 79. This group included 84 healthy men and 41 healthy women. We will call this group the “cyclists”. 第一组由125名年龄在55至79岁之间的非职业自行车手组成.该组包括84名健康男性和41名女性.我们将这个组称为: “自行车运动组.” Researchers then found 130 people to make up a second group. Within this group,75 people were aged 57 to 80. The other 55 were between the ages of 20 and 36. The people in this group were also healthy,but they did not exercise regularly. We will call this group the “non-exercisers”. 研究人员随后找了130人组成第二组.在这一组中,有75人年龄在57岁至80岁之间.其他55人年龄在20岁至36岁之间.这一群体的人也很健康,但他们没有定期锻炼.我们将这个小组称为: “非运动组”. Smokers,heavy drinkers of alcohol and people with other health issues were not included in the study. 吸烟者,酗酒者以及有其他健康问题的人士未参与此次研究. Then,researchers gave both groups a series of tests. They testd their muscle mass,muscular strength,percentage of body fat,cholesterol levels and the strength of their immune system. And male participants had their testosterone levels checked. 然后,研究人员对这两组进行了一系列的测试.他们测试他们的肌肉质量,肌肉力量,身体脂肪的百分比,胆固醇水平和他们的免疫系统的强度.还检查了男性参与者的睾酮水平. The the researchers compared the result of the two groups. 然后研究人员比较了两组的结果. Result showed that the cyclists did not experience body changes usually equated with a normal aging process. For example,they did not lose muscle mass or strength. Also,their body fat and cholesterol levels did not increase with age. 结果表明,骑自行车的人没有经历身体变化,通常等同于正常的老化过程.例如: 他们的肌肉质量或力量没有减少.此外,他们的身体脂肪和胆固醇指标并没有随着年龄增加而上升. The male cyclists’ testosterone levels had also remained high. Researchers say this may mean that they avoided at least one major symptom of male menopause. 男性骑行者的睾酮水平也一直很高.研究人员说: 这可能意味着他们至少避免了男性更年期的一个主要症状. The reseachers also found something they had not expected. The study showed that the immune systems of the cyclists did not seem to age either. For this,they looked at an organ called the thymus. The thymus makes immune cells called T-cells. 研究人员还发现他们没有预料的事情.该研究表明,骑自行车的免疫系统似乎也没有老化.为此,他们观察了一个称为胸腺的器官.胸腺制造的免疫细胞称为T细胞. The University of Arizona’s biology department explains on its website that T-cells are a type of white blood cell and are made in our bone marrow. 亚利桑那大学生物系在其网站上解释说,T细胞是一种白血球,在我们的骨髓中生成. As the article says: “There are two types of T-cells in your body: Helper T-cells and Killer T-cells. Killer T-cells do the work of destorying the infected cells. The Helper T-cells coordinate the attack.” 正如文章所说: “你体内有两种类型的T细胞: 辅助型T细胞和杀伤型T细胞. 杀伤型T细胞的工作是消灭感染的细胞.辅助型T细胞协调攻击.” Starting at about the age of 20,the thymus of most people starts to get smaller. It also starts to make fewer T-cells. 从大约20岁开始,大多数人的胸腺开始变小.所产生的T细胞也开始相应的减少. Howerver,in this study,the T-cell production by the thymuses of the cyclists had not slowed down with age. They were making as many T-cells as those of a young person. 然而,在这项研究中,骑自行车者的胸腺产生的T细胞没有随着年龄增加而减慢.他们正在制造与年轻人一样多的T细胞. Janet Lord is director of the Institute of Inflammation and Ageing at the University of Birmingham. In a press statement,she offers the words of Hippocrates,often called the “father of medicine.” 珍妮特爵士是伯明翰大学炎症和老化研究所所长.在新闻发布会上,她引用了通常被称为”医学之父”的希波克拉底的话. She write: “Hippocrates in 400 BC said that exercise is man’s best medicine,but his message has been lost over time and we are an increasingly sedentary society.” 她写到: “公元前400年希波克拉底说: 运动是人类最好的药物,但随着时间的流逝,他的话渐渐被大家所遗忘,我们正处在一个日益就久坐的社会.” Professor Stephen Harridge is director of the Center of Human &amp; Aerospace PhysiologicalSciences at King’s College London. He addressed the common question of what came first——the chicken or the egg? In this case,the question became,”Which camej first——the healthy behavior or the good health?” 斯蒂芬哈里教授是伦敦国王学院人体与航天生理学中心主任.他解释了一个老生常谈的问题——先有鸡还是先有蛋?在这种情况下,这个问题变成了: “有着健康行为,会有一个健康的身体.还是有了健康的身体才会进行健康的行为.” When talking about the findings of the study,he said “the cyclists do not exercise because they are healthy,but that they are healthy because they have been exercising for such a large portion of their lives.” 在谈到这项研究的结果时,他说: “骑自行车的人之所以健康,并不是因为他们身体健康,而是因为他们“在生命的大部分时间里一直在锻炼.” The researchers advise us all to find an exercise that we like and to make physical activity a priority in our lives. 研究人员建议我们所有人都要找到自己喜欢的运动,并将身体活动作为我们生活中的优先事项. They published their findings in Aging Cell. The study is part of ongoing research by the two universities. 他们在《老龄细胞》发表了他们的研究.这项研究是两所大学正在进行研究的一部分. And that’s the Health&amp;Lifestyle report.I’m Anna Matteo. 重点词汇 commitment (n) 承诺,保证. routine (n) [计]程序,日常工作. movement (n) 运动,活动. muscle (n) 肌肉,力量. mass (n) 块,团. percentage (n) 百分比,百分率. cholesterol (n) [生化]胆固醇. participant (n) 参与者,关系者. cyclist (n) 骑自行车的人. participant (n) 参与者. testosterone (n) 睾酮,睾丸素. symptom (n) 症状,征兆. menopause (n) 更年期,活动终止期. organ (n) 器官,机构. thymus (n) 胸腺. marrow (n) 髓,骨髓. inflammation (n) [病理]炎症. Hippocrates (n) 希波克拉底(希腊的名医-称医药之父) professor (n) 教授,教师. aerospace (n) 航空宇宙.[航]航空航天空间. physiological (n) 生理学的,生理的. portion (n) 部分,一份. priority (n) 优先,优先权. equate (v) 使相等,视为平等. remain (v) 保持,留下,剩余. avoid (v) 避免,避开. coordinate (v) 协调. immune (a) 免疫的. infected (a) 被感染的. sedentary (a) 久坐的,坐惯的. ongoing (a) 不间断的,进行的. 重点短语 be made up : 由..组成,被构成. equate with : 把..等同,使相等,同等相待. at least : 至少","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"文件上传与下载","slug":"文件上传与下载","date":"2019-04-26T02:28:32.000Z","updated":"2019-08-25T06:31:01.192Z","comments":true,"path":"2019/04/26/文件上传与下载/","link":"","permalink":"http://yoursite.com/2019/04/26/文件上传与下载/","excerpt":"","text":"学习笔记 : Java web之文件的上传与下载文件上传如何实现文件上传Apache组织提供了一个开源组件Commons-FileUpload( 依赖于common-io ),该组件可以方便地将multipart/form-data类型请求中的各种表单解析出来,并实现一个或多个文件的上传,同时也可以限制上传文件的大小等内容..并且性能优异,使用简单. FileUpload组件是通过Servlet来实现文件上传功能的,其工作流程如下图所示. 文件上传相关APIFileItem InterfaceFileItem接口用于封装单个表单字段元素的数据,一个表单字段元素对应一个FileItem对象. DiskFileItemFactory ClassDiskFileItemFactory类用于将请求的消息实体中的每一个文件封装成单独的FileItem对象.如果上传的文件比较小,将直接保存在内存中,如果上传的文件比较大,则会以临时文件的形式,保存在磁盘的临时文件中,默认情况下,文件保存在内存/磁盘临时文件夹的临界值为10240,既10KB. ServletFileUpload ClassServletFileUpload类是Apache组件处理文件上传的核心高级类,通过使用parseRequest(HttpServletRequest)方法可以将HTML中每个表单提交的数据封装成一个FileItem对象,然后以List列表的形式返回. 文件上传案例 JSP页面代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;file&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;upload the specified the file&lt;/h3&gt; &lt;hr&gt; &lt;form action=\"UploadServlet2\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div align=\"center\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"id\"/&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;照片&lt;/td&gt; &lt;td&gt;&lt;input type=\"file\" name=\"image\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;%-- 文件上传结果 --%&gt; &lt;% String result = (String)request.getAttribute(\"result\"); if(result!=null)&#123; out.println(\"&lt;script&gt;alert(' \"+result+\" ')&lt;/script&gt;\"); &#125; %&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; Servlet类 : 获取表单及其上传文件的信息.. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package pers.huangyuhui.file.servlet;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadBase.SizeLimitExceededException;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.apache.commons.io.filefilter.SuffixFileFilter;@WebServlet(\"/UploadServlet2\")public class UploadServlet2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public UploadServlet2() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html;charset=utf-8\"); String message = \"上传失败 !\";// 上传结果 // FileItemFactory fileItemFactory = new DiskFileItemFactory(); DiskFileItemFactory fileItemFactory = new DiskFileItemFactory(); fileItemFactory.setSizeThreshold(1024 * 1024);// // 设置将上传的文件以临时文件的形式保存在磁盘的临界值 // 默认情况下,采用的是系统默认的临时文件路径,可以通过该方式获取: System.getProperty(\"java.io.tmpdir\"); fileItemFactory.setRepository(new File(\"D:\\\\Java web\\\\temporary files\"));// 将上传的文件以临时文件的形式保存在指定的目录下 // 判断请求消息中的内容是否是: multipart/form-data类型 if (ServletFileUpload.isMultipartContent(request)) &#123; // 文件上传的核心高级类 ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory); servletFileUpload.setSizeMax(1024 * 20); // 设置请求消息实体内容(既上传数据)的最大尺寸限制: 20KB try &#123; // 将HTML中每个表单提交的数据封装成一个FileItem对象,然后以List列表的形式返回 List&lt;FileItem&gt; fileItems = servletFileUpload.parseRequest(request); // 限制上传的文件类型 String[] suffixs = new String[] &#123; \".exe\", \".bat\", \".c\", \".java\", \".sh\", \"html\", \".css\", \".js\" &#125;; SuffixFileFilter suffixFileFilter = new SuffixFileFilter(suffixs); // 遍历集合 File file = null; String sno = null; String sname = null; String fileName = null; for (FileItem fileItem : fileItems) &#123; String item = fileItem.getFieldName(); if (fileItem.isFormField()) &#123;// 普通文本表单字段 if (item.equals(\"id\")) &#123; sno = fileItem.getString(); &#125; else if (item.contentEquals(\"name\")) &#123; sname = fileItem.getString(); &#125; else &#123; System.out.println(\"others value ..\"); &#125; &#125; else &#123;// 文件表单字段 fileName = fileItem.getName(); file = new File(request.getSession().getServletContext().getRealPath(\"/upload/\" + fileName)); if (suffixFileFilter.accept(file)) &#123; message = \"禁止上传此类型文件 !\"; &#125; else &#123; file.getParentFile().mkdirs();// 创建目录 fileItem.write(file);// 上传文件 message = \"success to upload !\"; System.out.println(\"id: \" + sno + \"\\nname: \" + sname + \"\\nthe file name: \" + fileName + \"\\nthe file path: \" + file.getAbsolutePath()); // 上传者及文件信息 &#125; &#125; &#125; &#125; catch (FileNotFoundException e) &#123; message = \"error : please choose the specified file !\"; &#125; catch (SizeLimitExceededException e) &#123; message = \"error : the file size exceeds limit !\"; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 将提示信息保留在request对象中 request.setAttribute(\"result\", message); request.getRequestDispatcher(\"upload.jsp\").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 程序运行结果 : 略.. 文件下载文件下载程序流程浏览器通常会直接处理响应的实体内容,这时需要在HTTP响应消息中设置两个响应消息头字段,指定接收程序处理数据内容的方式为下载方式,当点击”下载”超链接时,系统将请求提交到对应的Servlet.在该Servlet中,程序流程如下 : 根据该地址创建文件字节输入流. 通过该流读取下载文件的内容. 将读取的内容通过输出流写到目标文件中. HTTP中设置两个响应消息头,具体如下.1234//设定接收程序处理数据的方式Content-Disposition: attachment;filename=//设定实体内容的MIME类型Content-Type: application/x-msdownload 文件下载案例 JSP页面代码 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"&gt; &lt;title&gt;down the file&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;&lt;/h3&gt; &lt;a href=\"DownloadServlet?filename=文件.png\"&gt; Click to download this file .. &lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Servlet类 : 设置所要下载的文件以及文件在浏览器中打开的方式. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package pers.huangyuhui.file.servlet;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.tomcat.util.codec.binary.Base64;@WebServlet(\"/DownloadServlet\")public class DownloadServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public DownloadServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); // 获取需要下载的文件名 String fileName = request.getParameter(\"filename\"); // 设定接收程序处理数据的方式( MIME type : application/octet-stream ) response.addHeader(\"Content-Type\", \"application/octet-stream\"); /* * 根据不同浏览器进行不同的编码处理,以防乱码 */ // User-Agent: 首部包含了一个特征字符串,用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号. String agent = request.getHeader(\"User-Agent\"); if (agent.toLowerCase().indexOf(\"firefox\") != -1) &#123; response.addHeader(\"Content-Disposition\", \"attachment;filename==?UTF-8?B?\" + new String(Base64.encodeBase64(fileName.getBytes(\"UTF-8\"))) + \"?=\"); &#125; else &#123; // 设定实体内容的MIME类型并使用encode(String s, Charset charset)解决乱码问题: Google Chrome,Microsoft Eage .. response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + URLEncoder.encode(fileName, \"UTF-8\")); &#125; // 读取文件 InputStream inputStream = getServletContext().getResourceAsStream(\"/resource/\" + fileName); // 获取response对象的输出流 OutputStream outputStream = response.getOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len = inputStream.read(buffer)) != -1) &#123; outputStream.write(buffer, 0, len); &#125; outputStream.close(); inputStream.close(); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 程序运行结果 : 略..","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"JSP 标准标签库","slug":"JSP-标准标签库","date":"2019-04-26T02:24:15.000Z","updated":"2019-08-25T06:31:00.990Z","comments":true,"path":"2019/04/26/JSP-标准标签库/","link":"","permalink":"http://yoursite.com/2019/04/26/JSP-标准标签库/","excerpt":"","text":"学习笔记 : Java web之JSTLJSTL介绍从JSP 1.1规范开始,JSP就支持使用自定义标签,使用自定义标签大大降低了JSP页面的复杂度.同时增加了代码的重用性.因此市面上出现了许多由不同厂商定制的功能相同的标签,继而导致网页制作者无从选择的问题.为了解决该问题,Sun公司制定了一套标准标签库(Java Server Pages Standard Tag Library),简称JSTL.其为一个JSP标签集合,封装了JSP应用的通用核心功能. JSTL标签库 Core : 核心标签库,它包含实现Web应用中通用操作的标签. SQL : 数据库标签库,用于访问数据库和对数据库中的数据进行操作的标签. XML : 操作XML文档的标签库,它包含对XML文档中的数据进行操作的标签. Functions : 函数标签库,提供了一套自定义EL函数,包含JSP网页制作者经常要用到的字符串操作. JSTL的使用例如 : 测试&lt;c:out&gt;标签,需要使用taglib指令导入Core标签库.代码如下 :1&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; 在上述代码中,taglib指令的uri属性用于指定引入标签库描述文件中的URL, 其prefix属性用于指定引入标签库描述符文件的前缀.在JSP文件中使用这个标签时都要使用这个前缀.","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"VOA:Researchers Find Clues that Depression May Speed Brain Aging","slug":"VOA-Researchers-Find-Clues-that-Depression-May-Speed-Brain-Aging","date":"2019-04-25T22:51:42.000Z","updated":"2019-08-25T06:31:01.095Z","comments":true,"path":"2019/04/26/VOA-Researchers-Find-Clues-that-Depression-May-Speed-Brain-Aging/","link":"","permalink":"http://yoursite.com/2019/04/26/VOA-Researchers-Find-Clues-that-Depression-May-Speed-Brain-Aging/","excerpt":"","text":"Researchers Find Clues that Depression May Speed Brain AgingMemory and thinking skills naturally slow with age. Scientists are now looking inside living brains to tell if depression might speed aging. The scientists report that some of the signs they have found are worrisome. 随着年龄增长,人的记忆力和思维能力也随之减退.科学家正在研究活人大脑的内部情况,以判断抑郁症是否会加速大脑老化.科学家报告称,他们发现一些迹象令人十分担忧. Depression has long been linked to some cognitive problems. Depression late in life even may increase the risk of developing Alzheimer&#39;s disease. Yet how depression might harm the ability to remember things and things and think clearly is not yet known. 长期以来,抑郁症就与一些认知障碍相关联.在晚年,抑郁症甚至可能增加患增加阿尔兹海默病的风险.而然,关于抑郁症会如何损害记忆力及清晰的思维能力,目前尚不清楚. One pssibility : Brain cells communicate by sending messages across connections called synapses. Generally,good cognition is linked to more and stronger synapses. With a weakening of congnitive ability,those connections slowly shrink and die. But unitl recently,scientists could count synapses only in brain tissue collected after the person dies. 一种可能是: 脑细胞间通过被称为突触的连接进行交流.一般来说,良好的认知能力表明突触数量多且强健.随着认知能力的退化,突触会慢慢萎缩并消亡.但直到最近,科学家还仅能通收集逝者的大脑组织来计算出突触的数量. Yale University scientists used a new method to study the brains of living people. They discovered that patients with depression had a lower density of synapses than healthy people of the same age. 耶鲁大学科学家采用了一种新方法来研究活人的大脑.他们发现,抑郁症患者的突触密度比同龄的健康人群要低. The lower the density,the more severe the signs of depression. Yele University neuroscientist Irna Esterlis says this is especially true of problems with loss of interest in activities patients once enjoyed. She spoke at a meeting of the American Association for the Advancement of Science. 突触密度越低,患抑郁症的迹象越严重.耶鲁大学神经学家伊琳娜·埃斯特曾在美国科学促进会的一次会议发言上说: 病人对曾经喜欢的活动失去兴趣的问题尤其如此. Esterlis was not studying just older adults,but people of all ages,including those too young for any cognitive changes to be noticeable. She was working from a theory that early damage can build up. 埃斯特里并不仅仅是在研究老年人,而是所有年龄段的人群,包括那些非常年轻,无法注意到任何认知变化的人群.她的研究建立在”早起伤害会不断积累”这一理论上. “We think depression might be accelerating the normal aging,”she said. 她说: “我们认为抑郁症可能正加速正常衰老.” Her studies are small. To prove if depression really does increase the risk of cognitive problem as we age would require more investigation. Jovier Evans is a scientist with the U.S. National Institute of Mental Health. He proposed a study of synaptic density on larger numbers of people as they get older,to see if and how it changes over time in those with and without depression. 她进行的是小型研究.要证明随着年龄的增长,抑郁症确实会增加认知障碍的风险需要进行更多的调查.乔维尔·埃文斯是美国国家心理健康研究所的科学家.他提出一项研究: 针对更多的人群,研究他们随着年龄的增长,突触密度的变化,以此来判断在那些患抑郁症和无抑郁症的人群中,随着时间的推移,突触密度是否改变以及如何改变. Eaterlis has announced plans for a larger study to do that. Volunteers would be injected with a radioactive substance that links up to a protein in the vesicles,or storage containers,used by synapses. Then each volunteer would be given an imaging test,known as a PET scan. During the test,areas with synapses light up,enabling researchers to see how many are in different parts of the brain. 埃斯特里已宣布要进行大规模对的研究计划.志愿者将注射放射性物质,该物质与囊泡中的蛋白质或突触使用的储存容器相连.然后,每位志愿者将进行影像检查,也就是PET扫描.检查期间,突触区域会亮起来,这样研究人员就能够看到大脑的不同部位有多少突触. Esterlis said there are no medications that target synapse damage. 埃斯特里表示目前没有专门治疗突触损伤的药物. Doctor Mary Sano directs the Mount Sinai Alzheimer’s Disease Research Center in New York. She was not involved in the new research. 玛丽·萨诺医生是纽约西奈山阿尔茨海默病研究中心的负责人.她没有参与这项新研究. Sano warned that normal cognitive aging is complex process that involves other health problems,such as heart disease. It might be that depression does not worsen synaptic weakening. It could just makes the problem more noticeable,she said. 萨诺提醒说,正常的认知衰退是个复杂的过程,设计其他健康问题,比如心脏病.也有可能抑郁症不会加速突触退化.她说,抑郁症可能只是让问题更显而易见. With depression “at any age,there’s a hit on the brain. At an older age hit may be more visible because there may already be some loss,” she explained. 患抑郁症 “在任何年纪,都会对大脑造成伤害.对较大年纪的人群而言,这种伤害可能更明显,因为他们的大脑可能已有一些损伤.” I’m Ashley Thompson. 重点词汇 cognition (n) 认识,认识能力. depression (n) 抑郁症,精神忧郁. Alzheimer (n) 阿尔茨海默病. synapse (n) 突触. tissue (n) 组织. density (n) 密度. neuroscientist (n) 神经系统科学家. association (n) 协会,联盟. theory (n) 理论,原理. aging (n) 老化,陈化. investigation (n) 调查,调查研究. substance (n) 物质,实质. vesicle (n) 泡,囊. target (n) 目标,指标. accelerate (a) 加速,加快. visible (a) 看的见得. severe (a) 严峻的,严厉的. noticeable (a) 显著的,显而易见的. cognitive (a) 认知的,认识的. synaptic (a) 突触的. radioactive (a) [核]放射性的,有辐射的. complex (a) 复杂的,合成的. shrink (v) 收缩,畏缩. 重点短语 build up : 增进,加强. link up : 会合,连接. involved in : 参与,涉及.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"JSP 自定义标签","slug":"JSP-自定义标签","date":"2019-04-25T03:26:47.000Z","updated":"2019-08-25T06:31:00.990Z","comments":true,"path":"2019/04/25/JSP-自定义标签/","link":"","permalink":"http://yoursite.com/2019/04/25/JSP-自定义标签/","excerpt":"","text":"JSP 自定义标签入门 什么是JSP自定义标签?自定义标签可以有效地将HTML代码与Java代码分类,从而使不懂Java编程的HTLML设计人员也可以编写出功能强大的JSP页面.JSP复规范中定义了多个用于开发自定义标签的接口和类,它们都位于javax.servlet.jsp.tagext包中,这些接口和类的继承关系如下所示. 标签分类在JSP2.0之前,所有的标签都需要实现Tag接口,这样的标签称为: 传统标签( javax.servlet.jsp.tagext.Tag ). 后来为了简化标签的开发,JSP2.0规范又定义了一种新类型的标签,称为简单标签( javax.servlet.jsp.tagext.SimpleTag ) 自定义标签的开发步骤 编写标签处理器Tag接口和SimpleTag接口定义了JSP页面与标签处理器类之间的通信规则.如果JSP引擎在编译JSP页面时遇到了自定义标签,传统标签将会调用标签处理器的doStartTag()方法,简单标签将会调用标签处理器类的doTag()方法. 编写标签库描述符文件要想让JSP引擎在遇到自定义标签时,能找到其所对应的标签处理器,还必须编写是一个标签描述符( Tag Library Descriptor )文件.简称: TLD文件. 注意: 自定义标签的根标签(&lt;taglib&gt;)使用的是schema约束.其标签内容可以从 : &lt;Tomcat安装目录&gt;\\webapps\\examples\\WEB-INF\\jsp2\\jsp2-example-taglib.tld中复制即可. 在JSP页面导入和使用自定义标签TLD文件编写完成后,就可以在JSP文件中使用自定义标签.在使用自定义标签之前,首先需要使用taglib指令来引入TLD文件. 传统标签 Tag 接口 Tag接口定义了JSP页面与标签处理器之前的通信规则,当JSP容器将JSP页面翻译成Servlet源文件时,如果遇到JSP标签,会创建标签处理器类的实例对象.然后依次调用标签处理器的如下方法.1setPageContext() ——&gt; setParent() ——&gt; doStartTag() ——&gt; doEndTag() ---&gt; release() IterationTag 接口 在自定义标签的开发过程中,其可以对标签体的内容进行重复处理. TagSupport类实现了该接口,简化了程序的编写. BodyTag 接口 在实现自定义标签时,其可以根据需要对标签体的内容进行处理后再向浏览器输出. 案例-实现一个传统自定义标签描述 : 开发一个显示IP地址的自定义标签 编写完成标签功能的标签处理器类 123456789101112131415161718192021222324252627282930package pers.huangyuhui.tag.handler;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.TagSupport;/** * @ClassName: IpTag * @Description: 传统标签处理器 * @author: HuangYuhui * @date: Apr 25, 2019 4:06:28 PM * */public class IpTag extends TagSupport &#123; private static final long serialVersionUID = -8446674958888389920L; @Override public int doStartTag() throws JspException &#123; String IP = pageContext.getRequest().getRemoteAddr(); try &#123; pageContext.getOut().write(\"访问用户的IP地址为 : \" + IP); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.doStartTag(); &#125;&#125; 编写TLD文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 标签库的版本号 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;!-- 标签库的名称 --&gt; &lt;short-name&gt;TraditionalTag&lt;/short-name&gt; &lt;!-- 标签库的URI --&gt; &lt;uri&gt;https://yubuntu0109.github.io&lt;/uri&gt; &lt;!-- 注册一个自定义的标签 --&gt; &lt;tag&gt; &lt;!-- 指定自定义标签的注册名称 --&gt; &lt;name&gt;ipTag&lt;/name&gt; &lt;!-- 指定标签的标签处理器类 --&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.IpTag&lt;/tag-class&gt; &lt;!-- 指定标签的类型 --&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 编写JSP文件,并导入和使用自定义标签 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%-- 导入自定义的标签库描述符文件 --%&gt;&lt;%@taglib uri=\"https://yubuntu0109.github.io\" prefix=\"yu\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;yu:ipTag/&gt; &lt;/body&gt;&lt;/html&gt; 简单标签 SimpleTag 接口 SimpleTag接口中的方法和传统标签中定义的签名有所区别,但是功能却基本一致,例如: 都实现了给标签处理器传递pageContext对象和父标签处理器对象的功能.而且JSP容器执行简单标签处理器的顺序也和执行传统标签处理器的顺序一致.简单标签处理器的执行流程如下所示:1JSP容器实例化标签处理器类 ——&gt; setJspContext() ——&gt; setParent() ——&gt; 设置属性的setter方法 ——&gt; setJspBody() ——&gt; doTag() JspFragment 类 JSP容器在处理简单标签时,会把标签体内容用一个JspFragment对象表示,并调用标签处理器对象的setJspBody()方法将JspFragment对象传递给标签处理器对象,标签开发者可以根据需要调用JspFragment对象的方法来决定是否输出标签体,或者循环多次输出标签体等.其中JspFragment的invoke(Write out)方法是简单标签开发中最重要的一个方法,它用于控制如何执行标签体的内容. SimpleTagSupport 类 该类实现了SimpleTagSupport接口,继而使得简单标签处理器的编写变得简化. 案例-实现一个自定义简单标签描述 : 自定义简单标签,实现重复执行标签体的功能. 编写标签处理器类 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.tag.handler;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: SimpleIterate * @Description: 简单标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 4:52:19 PM * */public class SimpleIterate extends SimpleTagSupport &#123; private int num; public void setNum(int num) &#123; this.num = num; &#125; @Override // 对标签进行逻辑处理 public void doTag() throws JspException, IOException &#123; // 获取标签体 JspFragment jspFragment = this.getJspBody(); for (int i = 0; i &lt; num; i++) &#123; jspFragment.invoke(null); &#125; &#125;&#125; 编写简单标签库描述符文件 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 标签库的版本号 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;!-- 标签库的名称 --&gt; &lt;short-name&gt;SimpleTag&lt;/short-name&gt; &lt;!-- 标签库的URI --&gt; &lt;uri&gt;/SimpleTag&lt;/uri&gt; &lt;!-- 注册一个自定义的标签 --&gt; &lt;tag&gt; &lt;name&gt;simpleIterate&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.SimpleIterate&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;!-- 用于描述自定义标签的属性 --&gt; &lt;attribute&gt; &lt;!-- 指定属性的名称 --&gt; &lt;name&gt;num&lt;/name&gt; &lt;!-- 指定在JSP页面调用自定义标签时是否必须设置这个属性 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 编写JSP文件,并导入和使用自定义标签 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib uri=\"/SimpleTag\" prefix=\"yu\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;yu:simpleIterate num=\"5\"&gt; Hello SimpleTag !&lt;br&gt; &lt;/yu:simpleIterate&gt; &lt;/body&gt;&lt;/html&gt; 案例-模拟JSTL的&lt;c:choose&gt;,&lt;c:when&gt;,&lt;c:otherwise&gt;标签描述 : 通过模仿JSTL核心标签库中的&lt;c:choose&gt;,&lt;c:when test=””&gt;,&lt;c:otherwise&gt;标签,开发一套自己的标签 : &lt;yu:choose&gt;,&lt;yu:when test=&quot;&quot;&gt;,&lt;yu:otherwise&gt; 编写标签&lt;yu:choose&gt;的标签处理器类 : ChooseTag.java 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.tag.handler.choose;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: ChooseTag * @Description: 标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 5:15:53 PM * */public class ChooseTag extends SimpleTagSupport &#123; // 作为标识符用于控制&lt;yu:when&gt;和&lt;yu:otherwise&gt;的标签体是否执行 private boolean flag; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; @Override public void doTag() throws JspException, IOException &#123; this.getJspBody().invoke(null); &#125;&#125; 编写标签&lt;yu:when test=&quot;&quot;&gt;的标签处理器类 : WhenTag.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.tag.handler.choose;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspTagException;import javax.servlet.jsp.tagext.JspTag;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: WhenTag * @Description: 标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 5:19:01 PM * */public class WhenTag extends SimpleTagSupport &#123; // 用于接收标签中`test`属性传入的值 private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; // 获得父类标签对象 JspTag tag = this.getParent(); // 判断父标签是否为: ChooseTag if (!(tag instanceof ChooseTag)) &#123; throw new JspTagException(\"ERROR : OUT OF CHOOSE TAG\"); &#125; // 将父类标签对象强转成`ChooseTag`类型 ChooseTag chooseTag = (ChooseTag) tag; // 判断`WhenFlag`为true且父标签中的`flag`为false时执行该标签体 if (test &amp;&amp; !(chooseTag.isFlag())) &#123; this.getJspBody().invoke(null); // 执行完标签体后,将父标签中的`flag`置为true,防止其它嵌套标签体继续执行 chooseTag.setFlag(true); &#125; &#125;&#125; 编写&lt;yu:otherwise&gt;的标签体处理器类 : OtherwiseTag.java 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.tag.handler.choose;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspTagException;import javax.servlet.jsp.tagext.JspTag;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: OtherwishTag * @Description: 标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 5:46:33 PM * */public class OtherwiseTag extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; // 获得父标签对象 JspTag jspTag = this.getParent(); // 判断父标签是否是: ChooseTag if (!(jspTag instanceof ChooseTag)) &#123; throw new JspTagException(\"ERROR : OUT OF CHOOSE TAG\"); &#125; // 将父类标签对象强转成`ChooseTag`类型 ChooseTag chooseTag = (ChooseTag) jspTag; // 判断父标签中的`flag`为false时,执行该标签体 if (!chooseTag.isFlag()) &#123; this.getJspBody().invoke(null); // 执行完标签体后,将父标签中的`flag`置为true,防止其它嵌套标签体继续执行 chooseTag.setFlag(true); &#125; &#125;&#125; 编写TLD文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;模拟JSTL的choose,when,otherwish标签&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;SimpleTag&lt;/short-name&gt; &lt;uri&gt;https://yubuntu0109.github.io&lt;/uri&gt; &lt;!-- choose tag --&gt; &lt;tag&gt; &lt;name&gt;choose&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.choose.ChooseTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; &lt;!-- when tag --&gt; &lt;tag&gt; &lt;name&gt;when&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.choose.WhenTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;!-- 注意: 属性名一定要和该标签的处理器类中的属性名一致 ! 否则抛出异常: Unable to find setter method for attribute: xxx .. --&gt; &lt;name&gt;test&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;!-- otherwise tag --&gt; &lt;tag&gt; &lt;name&gt;otherwise&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.choose.OtherwiseTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 编写两个JSP文件,对三个自定义标签进行测试. 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;请选择你热爱的运动哟 (づ￣3￣)づ╭❤～&lt;/h3&gt; &lt;hr&gt; &lt;div align=\"center\"&gt; &lt;form action=\"choose_when_otherwise.jsp\"&gt; &lt;input type=\"radio\" name = \"hobby\" value=\"badminton\"/&gt;羽毛球 &lt;input type=\"radio\" name = \"hobby\" value=\"footall\"/&gt;足球 &lt;input type=\"radio\" name = \"hobby\" value=\"basketball\"/&gt;篮球 &lt;input type=\"radio\" name = \"hobby\" value=\"others\"/&gt;其它&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%-- 导入自定义的标签库描述符文件 --%&gt;&lt;%@taglib uri=\"https://yubuntu0109.github.io\" prefix=\"yu\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; &lt;yu:choose&gt; &lt;yu:when test=\"$&#123;param.hobby=='badminton' &#125;\"&gt; &lt;p&gt;你热爱的运动是: 羽毛球&lt;/p&gt; &lt;/yu:when&gt; &lt;yu:when test=\"$&#123;param.hobby=='footall' &#125;\"&gt; &lt;p&gt;你热爱的运动是: 足球&lt;/p&gt; &lt;/yu:when&gt; &lt;yu:when test=\"$&#123;param.hobby=='basketball' &#125;\"&gt; &lt;p&gt;你热爱的运动是: 篮球&lt;/p&gt; &lt;/yu:when&gt; &lt;yu:otherwise&gt; &lt;p&gt;哎哟 ~ 难道你只会coding ! ヾ(◍°∇°◍)ﾉﾞ&lt;/p&gt; &lt;/yu:otherwise&gt; &lt;/yu:choose&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"VOA:5 Habits of Very Successful People","slug":"VOA-5-Habits-of-Very-Successful-People","date":"2019-04-25T02:08:13.000Z","updated":"2019-08-25T06:31:01.090Z","comments":true,"path":"2019/04/25/VOA-5-Habits-of-Very-Successful-People/","link":"","permalink":"http://yoursite.com/2019/04/25/VOA-5-Habits-of-Very-Successful-People/","excerpt":"","text":"5 Habits of Very Successful PeopleFrom VOA Learning English,this is Health&amp;Lifestyle report. 欢迎收听VOA慢速英语健康及生活方式报道. Having success and being able to meet one’s goals requires knowledge,a sense of direction,hard work and resources. Some people might add to that list luck,connections and perhaps a strong belief in yourself. 获得成功以及达到某人的目标需要知识,方向感,努力付出和资源.一些人也许会将幸运,关系和自信加入其中. We accomplish our goals one step at a time,doing a little each day. So,using your day effectively is important. 我们一步步完成自己的目标,每天完成一点.所以高效率地过好每天很重要. On many websites——from Forbes magazine and Fast Commpany to health and physical fitness sites——productivity experts share advice on how to achieve your career and life goals. Most of the experts agree on one thing: Starting your day on the right foot is most important. 很多网站上,从福布斯杂志,快递公司到健康网站,专家都分享如何能够实现职业和生活目标的建议.很多专家都同意一点: 每一天开一个好头最重要. Collected from these websites,here are five ideas on how to start your day off right. 根据这些网站整理出五点,关于如何做到开门大吉. Get up an hour early. 第一: 早起一小时. People who get up early in the morning have a jump on the day. For starters,they’s awake! And some studies show that our willpower and attention span are strongest in the morning. In fact,the morning may be the most productive part of your day. 早起的人们在那一天就已经领先一步.首先,他们已经清醒了.一些研究显示,我们的意志力和注意力在早上最集中.事实上,早晨可能是你一天当中效率最高的时候. In American English,we like to say,”The early bird gets the worm.” Here,if you’re a bird,the worm is the reward. So,this expression means that people who rise up early have a head start and,therefore,are more likely to succeed. 在美式英语中,我们喜欢说: “早起的鸟儿有虫吃.” 如果你是一只鸟,虫子就是你早起的回报.这个表达是指早起的人们捷足先登,因此更可能成功. Inventor,philosopher and writer Benjamin Franklin would probably agree. Americans like to use Franklin’s memorable expressions. One of them is “Early to bed,early to rise,makes a man healthy,wealthy and wise.” 发明家,哲学家及作家的本杰明·富兰克林可能会同意这一点.美国人喜欢引用富兰克林的经典语录.其中一条是: “早睡早起会让人聪明,富有及智慧.” Of course,there are exceptions. People who are “night owls“ do their best work and their best thinking at night. 当然也有例外.”夜猫子”型的人在晚上的工作效率最高.思维最活跃. Drink a glass of with lemon juice. 第二: 喝一杯柠檬水. While your coffee is being prepared or waiting for your tea water to heat up,drink a glass of water with lemon juice. 当你在煮咖啡或蒸茶时,先喝一杯柠檬水. Why? Health experts say that drinking a combination of lemon juice and water first thing in the morning jump-starts the body’s metabolism. Not only does it jump start your body’s cells,but this kind keeps them moving throughout the day. 为什么呢? 健康专家表示,早上先喝一杯柠檬会激活身体的新陈代谢.不仅会激活你身体的细胞,还会让这些细胞整天保持运转. Don’t answer emial or jump into social media as soon as you get up. 第三: 一起床不要先回邮件或查看社交媒体. Your coffee or tea is ready. So,you decide to look at your email quickly or open up your Facebook account. Well,don’t. This is a great way to forget about the day ahead. 你的咖啡或茶煮好了.你决定先快速浏览一遍邮件或打开你的社交账户.不要这么做.这会让你忘记这是全新的一天. We’ve all done it. You see a Facebook post from a friend you haven’t seen in a long time. He is angry about some political issue and the heated discussion pulls you in. Before you know it,an hour has passed,you’re angry with lawmakers and it’s not even nine in the morning yet! You hurry out the door so as not to be later for work. This is not the best way to start your day. 我们都这么做过.你看到很久不见的朋友发了一条状态.他对某个政治问题感到很气愤,然后拉你进入热烈的讨论.不知不觉中,一个小时过去了,你对立法者感到很生气,这时早上还不到九点.你为了避免上班迟到而急匆匆地冲出门外.这绝不是开启一天的最佳方式. Exercise ! Some people may disagree with this one. Exercising in the morning may not be for everyone. Some people like to exercise after work or at night. 一些人可能不同意.在早上锻炼并不适合所有人.一些人喜欢下班后或晚上锻炼. Physical fitness experts and trainers often suggest some form of exercise in the morning because the middle of the day is busy time for most people. By the day’end,you may not have the time or energy to exercise. How many times have you finished work and said to yourself. “I’m too tired to exercise! I’ll do it tomorrow.” 健身专家和教练通常会建议在早上做一些形式的运动,因为白天对大多数人来说就是最繁忙的时候.白天结束后,你可能就没有时间或精力去运动了.有多少次你下班后告诉自己: “我太累了,不能再锻炼了,明天再去锻炼吧!” Exercising in the morning prevents that from happening. 在早上锻炼可以防止这一点. Think about your day…at night. 第五,在晚上思考你白天做的事情. Meditate,visualize——whatever you call it——take time at the day to think back on all the things that have happened. Give thanks,if you want. And spend a little time to think about tomorrow. Some people who talk about “living in the present” may criticize this. But it may help you to prepare if you take a few minutes to think about what you need to do the next day. 冥想,思考——无论你将其称为什么—— 一天结束前花点时间想想今天发生过的事.感恩这一天.然后花点时间想想明天.一些坚持”活在当下”的人可能会批判这一点.但如果你能花几分钟想想第二天需要做些什么,可能会帮助你提前进行准备继而提高效率. Also,know that your day will probably change. You probably won’t have time to do everything you planned. But that’s fine. If you did one thing, that means you are one step closer in reaching one of your goals. And if you follow this advise,at least you’ve already gotten your exercise out of the way ! 同时要知道,这一天也许会发生某些变化,你也许没有时间做完你所计划的所有的事,但这也没关系.如果你做完一件事,就离你完成这个目标近了一步.如果你遵循这些建议,至少你不会忘了锻炼. And that’s the Health&amp;Lifestyle report.I’m Anna Matteo. 重点词汇 willpowr (n) 意志力,毅力. perhaps (n) 假定,猜想. magazine (n) 杂志. productivity (n) 生产力,生产率,生产能力. willpower (n) 意志力,毅力. owl (n) 猫头鹰,惯于晚上活动的人. span (n) 跨度,跨距,范围. worm (n) 虫,蠕虫. inventor (n) 发明家,[专利]发明人. philosopher (n) 哲学家,哲人. lawmaker (n) 立法者. combination (n) 结合,组合. metabolism (n) [生理]新陈代谢. memorable (a) 显著的,难忘的,值得纪念的. political (a) 政治的,党派的. meditate (v) 考虑,计划,冥想. visualize (v) 形象,想像,设想. criticize (v) 批评,评论,苛求.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"详解Java对象的引用及赋值","slug":"详解Java对象的引用及赋值","date":"2019-04-23T10:21:00.000Z","updated":"2019-08-25T06:31:01.210Z","comments":true,"path":"2019/04/23/详解Java对象的引用及赋值/","link":"","permalink":"http://yoursite.com/2019/04/23/详解Java对象的引用及赋值/","excerpt":"","text":"细节 : 详解Java中对象的引用及赋值问题引入 前言 前些天学习数据结构与算法时特意写了一篇名为详解Linked-list的实现方式及其应用的文章,其中循环链表的代码中就淋漓尽致地体现了Java中对象的引用与赋值 循环链表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221package pers.huangyuhui.linkedlist;/** * @ClassName: CircularLinkedList * @Description: 操作循环链表 * @author: HuangYuhui * @param &lt;T&gt; * @date: Apr 16, 2019 7:25:36 PM * */public class CircularLinkedList&lt;T&gt; &#123; // get the length of the circular linked list public int getLength(ListNode&lt;T&gt; headNode) &#123; int length = 0; ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; if (currentNode == headNode) &#123; break; &#125; &#125; return length; &#125; // traverse the node of the circular linked list public void traverseNode(ListNode&lt;T&gt; headNode) &#123; System.out.println(\"\\n### [headNode]-address : \" + headNode + \"\\n\"); ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; System.out.print(currentNode.getData() + \" -&gt; \"); currentNode = currentNode.getNext(); if (currentNode == headNode) &#123; break; &#125; &#125; System.out.print(\"headNode(\" + currentNode.getData() + \")\\n\"); &#125; // add new node at the tail of linked list public void insertAtListTail(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; //// 注意: 由于`currentNode`无变化,导致`currentNode.getNext() != headNode`继而进入进入死循环 !//// // currentNode.setNext(currentNode.getNext()); currentNode = currentNode.getNext(); &#125; newNode.setNext(newNode); if (headNode == null) &#123; headNode = newNode; &#125; else &#123; newNode.setNext(headNode); currentNode.setNext(newNode); &#125; &#125; // add new node at the header of linked list public ListNode&lt;T&gt; insertAtListHeader(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; currentNode = currentNode.getNext();// 尾节点 &#125; newNode.setNext(newNode);// 指针指向自身 if (headNode == null) &#123; headNode = newNode; &#125; newNode.setNext(headNode); currentNode.setNext(newNode); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = newNode; return headNode; &#125; // add the new node by the specified index public ListNode&lt;T&gt; insertNodeByIndex(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular list is empty !\"); return null; &#125; else if (position == 1) &#123; insertAtListHeader(headNode, newNode); &#125; else if (position == getLength(headNode)) &#123; insertAtListTail(headNode, newNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待插节点的前节点 currentNode = currentNode.getNext();// 待插节点 &#125; temp.setNext(newNode); newNode.setNext(currentNode); &#125; return headNode; &#125; // delete the last node public void deleteLastNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; temp = headNode; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); &#125; while (currentNode.getNext() != headNode) &#123; temp = currentNode; // 尾节点的前一个节点 currentNode = currentNode.getNext(); &#125; temp.setNext(headNode); currentNode = null; &#125; // delete the header node public ListNode&lt;T&gt; deleteHeaderNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); return null; &#125; while (currentNode.getNext() != headNode) &#123; // currentNode.setNext(currentNode.getNext());//死循环 currentNode = currentNode.getNext(); &#125; currentNode.setNext(headNode.getNext()); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = headNode.getNext(); return headNode; &#125; // delete the node by the specified index public ListNode&lt;T&gt; deleteNodeByIndex(ListNode&lt;T&gt; headNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular linked list is empty !\"); return null; &#125; else if (position == 1) &#123; deleteHeaderNode(headNode); &#125; else if (position == getLength(headNode)) &#123; deleteLastNode(headNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待删节点的前节点 currentNode = currentNode.getNext();// 待删节点 &#125; temp.setNext(currentNode.getNext()); &#125; return headNode; &#125; // Test public static void main(String[] args) &#123; // 初始化链表头结点 CircularLinkedList&lt;Integer&gt; list = new CircularLinkedList&lt;&gt;(); ListNode&lt;Integer&gt; headNode = new ListNode&lt;&gt;(); headNode.setData(1);// 初始化链表头结点 headNode.setNext(headNode);// 节点指针指向自身 // 初始化待插入的链表节点 ListNode&lt;Integer&gt; a = new ListNode&lt;&gt;(); a.setData(2); ListNode&lt;Integer&gt; b = new ListNode&lt;&gt;(); b.setData(3); ListNode&lt;Integer&gt; c = new ListNode&lt;&gt;(); c.setData(4); ListNode&lt;Integer&gt; d = new ListNode&lt;&gt;(); d.setData(100); ListNode&lt;Integer&gt; e = new ListNode&lt;&gt;(); e.setData(101); ListNode&lt;Integer&gt; f = new ListNode&lt;&gt;(); f.setData(0); // 向链表的尾部添加三个节点 System.out.print(\"the origin node: \"); list.insertAtListTail(headNode, a); list.insertAtListTail(headNode, b); list.insertAtListTail(headNode, c); list.traverseNode(headNode); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 向链表中添加两个头结点( 头结点被更新 ) System.out.print(\"add two header node: \"); ListNode&lt;Integer&gt; newHeadNode = list.insertAtListHeader(headNode, d); // 注意: 由于`头结点`已在`insertAtListHeader`中已更新所以要向`traverseNode`传入新的头结点 ListNode&lt;Integer&gt; newHeadNode2 = list.insertAtListHeader(newHeadNode, e); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 在链表的指定位置上插入新的节点 System.out.print(\"Insert the new node at position 3: \"); list.insertNodeByIndex(headNode, f, 3); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表的尾节点 System.out.print(\"delete the tail node: \"); list.deleteLastNode(newHeadNode2); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 注意: 由于`头结点`已在`deleteHeaderNode`中已更新所以要向`traverseNode`传入新的头结点对象 ListNode&lt;Integer&gt; newHeadNode3 = list.deleteHeaderNode(newHeadNode2); System.out.print(\"delete the header node: \"); list.traverseNode(newHeadNode3); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表中指定位置的节点 ListNode&lt;Integer&gt; newHeadNode4 = list.deleteNodeByIndex(newHeadNode3, 4); System.out.print(\"delete the fourth node: \"); list.traverseNode(newHeadNode4); System.out.println(\"the length of the list: \" + list.getLength(headNode)); &#125;&#125; 程序运行结果 123456789101112131415161718192021222324252627282930the origin node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@16f656121 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(1)the length of the list: 4add two header node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@311d617d101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 6Insert the new node at position 3: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@311d617d101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 7delete the tail node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@311d617d101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(101)the length of the list: 6delete the header node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@7c53a9eb100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(100)the length of the list: 5delete the fourth node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@7c53a9eb100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; headNode(100)the length of the list: 4 基本数据类型作为参数传递 示例程序 12345678910111213public class test &#123; public static void main(String[] args) &#123; int i = 1; System.out.println(\"before change, i=\" + i); change(i); System.out.println(\"after change, i=\" + i); &#125; private static void change(int i) &#123; i = 5; &#125;&#125; 程序运行结果 12345678910111213141516171819202122232425262728before change, i=1after change, i=1``` 3. *结论* *当`基本数据类型`作为参数传递时,传递时的是`实参的副本`,既传的是`值`,无论在函数中怎么操作这个副本,实参的值是不会被改变的.*### 对象作为参数传递1. *第一个示例程序*```javapublic class test &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(\"Hello\"); System.out.println(\"before change: \" + sb); change(sb); System.out.println(\"after change: \" + sb); &#125; private static void change(StringBuffer stringBuffer) &#123; stringBuffer.append(\" world !\"); &#125;&#125; 程序运行结果 12before change: Helloafter change: Hello world ! 探究结论从上述程序运行结果可知sb所指的对象的值被改变了!那么我们是否就可以认为Java中的对象作为参数传递时,传递的是该对象的引用呢 ? 那我们再来看第二个示例程序. 第二个示例程序 12345678910111213141516public class test &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(\"Hello\"); System.out.println(\"before change: \" + sb); change(sb); System.out.println(\"after change: \" + sb); &#125; private static void change(StringBuffer stringBuffer) &#123; stringBuffer = new StringBuffer(\"Hi\"); stringBuffer.append(\" world !\"); &#125;&#125; 程序运行结果 如果上面的推论:(Java中对象作为参数传递时,实际传递的是该对象的引用)是正确的,那么在调用change函数后,原对象的值应该会被改变,既变为:Hi World !,但是,该程序的运行结果如下 !!!12before change: Helloafter change: Hello 可知原对象(sb)的值并没有被改变,这是为什么呢? 下面让我们来分析一下其中的原因吧嘿嘿 ~ 结论分析 当我们执行StringBuffer sb = new StringBuffer(&quot;Hello&quot;)时,我们便创建了一个指向新建对象new StringBuffer(&quot;Hello&quot;)的引用sb,如下所示.1sb ——————&gt; [Hello] 在第二个示例程序中,当我们调用change函数后,实际上,形参stringBuffer也指向了实参sb所指的对象! 如下所示.1sb ——————&gt; [Hello] &lt;—————— stringBuffer 那么当我们执行stringBuffer.append(&quot;world!&quot;)后,便通过对象的引用(stringBuffer)修改了对象的值,使之修改成了: Hello world !,如下所示:1sb ——————&gt; [Hello world !] &lt;—————— stringBuffer 但是在第二个示例程序中的change函数中,我们又新建了一个对象:new StringBuffer(&quot;Hi&quot;)(该操作实际上是在内存中开辟了一块在原对象地址之外的新区域),这让形参stringBuffer实际指向了这个新建的对象,并将新对象的值设置为了Hi world !,如下所示:12sb ——————&gt; [Hello]stringBuffer ——————&gt; [Hi World !] 综上所述,可以得出结论: 在Java中,当对象作为参数传递时,实际上传递的是一份&quot;引用&quot;的拷贝 ! 总结在Java中, = 不能看成一个赋值语句,因为它并不是把一个对象赋给另一个对象的过程,它的执行过程实质上是将右边对象的地址传给了左边的引用,使得左边的引用指向了右边的对象.Java表面上看起来没有指针,但它的引用实质上就是一个指针,引用里面存放的并不是对象,而是存放该对象的地址,使得该引用指向了该对象.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"VOA:One in Five Deaths Linked to Unhealthy Diet","slug":"VOA-One-in-Five-Deaths-Linked-to-Unhealthy-Diet","date":"2019-04-23T01:06:07.000Z","updated":"2019-08-25T06:31:01.094Z","comments":true,"path":"2019/04/23/VOA-One-in-Five-Deaths-Linked-to-Unhealthy-Diet/","link":"","permalink":"http://yoursite.com/2019/04/23/VOA-One-in-Five-Deaths-Linked-to-Unhealthy-Diet/","excerpt":"","text":"One in Five Deaths Linked to Unhealthy DietIn 2017,eleven million deaths worldwide were linked to people eating diets high in sugar,salt and processed meat. 2017年,全国范围内有1100个死亡案例与摄入含糖,含盐,加工肉制品最高的食物有关. Those foods were partly to blam for heart disease,cancer and diabetes,a new study found. 上述食物是导致心脏病,癌症,糖尿病的部分原因,这是一项新研究的发现. The study is called the Global Burden of Disease,It followed eating trends in 195 countries 1990 to 2017. The findings were reported in the publication The Lancet. 该研究名为”全国疾病负担研究”.该研究在1990-2017年间跟进了195个国家的饮食趋势.该研究的发现成果以报告的形式发布在了《柳叶刀》杂志上. Researchers considered 15 dietary elements,such as diets low in fruits,vegetables,whole grains and milk. They also looked at diets high in red meat,processed meat,sugar-sweetend drinks and sodium. 研究人员考量了15中饮食元素,比如水果,蔬菜,全谷类,牛奶含量少的食谱.研究人员还考量了红肉,加工肉制品,含糖饮料,含钠量高的食谱. The study found that Uzbekistan had the highest percentage of diet-related deaths. 该研究发现: 乌兹别斯坦因食谱而导致死亡的比例是最高的. Israel had the lowest proportion of diet-related deaths, while the United Stated reted 43rd in the study. 以色列则恰恰相反,美国则名列第43位. Consumption of foods such as nuts and seeds,milk and whole gains was on average too low,the researchers found. 研究人员发现,平均来看,坚果,种子,牛奶,全谷类的摄入太低. Chris Murrary is director of the Institute for Health Metrics and Evaluation at the University of Washington,which led the work. 克里斯·默里是华盛顿大学健康指标和评估研究所的负责人,他也是这项研究的负责人. “Poor diet is reponsible for more deaths than any other risk factor in the world,”he said. 他表示,”食谱不健康是导致死亡案例增加的罪魁祸首,比其他的风险都要致命.” The study found people are only 12 percent of the recommended amount of nuts and seeds——an average intake of 3 grams a day. For good health,experts say,you should eat 21 grams of nuts and seeds every day. 研究发现,人们摄入坚果和种子的总量只达到了推荐摄入量的12%——平均每天只有3克.多位专家表示,为了保持身体健康,每天应该摄入21克的坚果和种子类食物. The study also found that people drank more than 10 times the recommened amount of sugary drinks. 该研究还返现:含糖饮料的摄入量是推荐摄入量的10倍以上. Another study published in January suggested an “ideal diet” for the health of people and the planet would a doubling of the consumption of nuts,fruits,vegetables and legumes. Such a diet would also include reducing by half the amount of meat and sugar consumed. 一月份发布的另一个研究提出了一份”理想食谱”来保证人类的身体健康,而且全国范围内的所有人都应该加倍摄入坚果,水果,蔬菜,豆类食品.这样的健康食谱还应该包括将肉类和糖分摄入量减少一半. I’m John Russell. 重点单词 trend (n) 潮流,趋势. proportion (n) 比例. consumption (n) 摄入,消耗. factor (n) 因素. legume (n) 豆类,豆科植物. diabetes (n) 糖尿病,多尿症. percentage (n) 百分比,百分率,百分数. grain (n) 粮食,颗粒,[作物]谷物. sodium (n) [化学]钠. proportion (n) 比例,占比.部分. Consumption (n) 消费,消耗. nut (n) 坚果. director (n) 主任,主管,导演. metric (n) 度量标准. evaluation (n) 评价,[审计]评估,估价. factor (n) 因素,要素. intake (n) 摄取量,通风口. consumption (n) 消费,消耗. dietary (a) 饮食的,饭食的,规定食物的. sugary (a) 含糖的,甜的. consume (v) 消耗,消费. recommend (v) 推荐. diet-related 与饮食有关的.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"自定义EL函数防止HTML注入","slug":"自定义EL函数防止HTML注入","date":"2019-04-22T10:19:18.000Z","updated":"2019-08-25T06:31:01.200Z","comments":true,"path":"2019/04/22/自定义EL函数防止HTML注入/","link":"","permalink":"http://yoursite.com/2019/04/22/自定义EL函数防止HTML注入/","excerpt":"","text":"学习笔记 : 自定义EL函数防止HTML注入防止HTML注入前 JSP程序代码 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;`HTML`注入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; &lt;form action=\"ResultServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; 姓 名: &lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 留 言: &lt;textarea rows=\"6\" cols=\"50\" name=\"message\"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" value=\"submit\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Servlet程序代码 123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.el.test;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: ResultServlet * @Description: 跳转页面 * @author: HuangYuhui * @date: Apr 21, 2019 3:03:53 PM * */@WebServlet(\"/ResultServlet\")public class ResultServlet extends HttpServlet &#123; private static final long serialVersionUID = 6692198599916433288L; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"UTF-8\"); String name = req.getParameter(\"username\"); String message = req.getParameter(\"message\"); req.setAttribute(\"name\", name); req.setAttribute(\"message\", message); req.getRequestDispatcher(\"result.jsp\").forward(req, resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 所跳转的JSP页面的程序代码 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML注入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; 用户名: $&#123;name &#125;&lt;br&gt; 留言内容: $&#123;message &#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行结果示例图 JSP页面 HTML注入结果 防止HTML注入后 过滤HTML中特殊字符的程序代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.el.util;/** * @ClassName: HTMLFilter * @Description: 过滤特殊字符 * @author: HuangYuhui * @date: Apr 21, 2019 3:42:04 PM * */public class HTMLFilter &#123; public static String filter(String message) &#123; if (message == null) &#123; return null; &#125; // copy char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuffer result = new StringBuffer(content.length + 50); for (int i = 0; i &lt; content.length; i++) &#123; switch (content[i]) &#123; case '&lt;': result.append(\"&amp;lt;\"); break; case '&gt;': result.append(\"&amp;gt;\"); break; case '&amp;': result.append(\"&amp;amp;\"); break; case '\"': result.append(\"&amp;quot;\"); break; default: result.append(content[i]); &#125; &#125; return result.toString(); &#125;&#125; 描述自定义EL函数的mytaglib.tld文件 &lt;taglib&gt;元素是tld文件的根元素,用于声明该JSP文件使用了标签库,不需要对其进行修改,只需要从目录&lt;Tomacat安装目录&gt;\\webapps\\examples\\WEB-INF\\jsp2\\jsp2-example-taglib.tld中复制即可. 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;A tag library exercising SimpleTag handlers.&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;SimpleTagLibrary&lt;/short-name&gt; &lt;uri&gt;https://yubuntu0109.github.io&lt;/uri&gt; &lt;function&gt; &lt;name&gt;filter&lt;/name&gt; &lt;function-class&gt; pers.huangyuhui.el.util.HTMLFilter &lt;/function-class&gt; &lt;function-signature&gt; java.lang.String filter(java.lang.String) &lt;/function-signature&gt; &lt;/function&gt; &lt;/taglib&gt; JSP页面的程序代码 &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;%-- uri: 既tld文件中&lt;uri&gt;元素的内容. prefix: 为引用的tld文件定义一个\"代号\"(作为自定义EL函数的前缀) --%&gt; &lt;%@taglib prefix=\"demo\" uri=\"https://yubuntu0109.github.io\" %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;防止`HTML`注入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; 姓名: ${name }&lt;br&gt; 留言内容: ${demo:filter(message) } &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 运行效果示例图","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"VOA:Paris`Notre-Dame Cathedral Burning","slug":"VOA-Paris-Notre-Dame-Cathedral-Burning","date":"2019-04-22T01:26:31.000Z","updated":"2019-08-25T06:31:01.094Z","comments":true,"path":"2019/04/22/VOA-Paris-Notre-Dame-Cathedral-Burning/","link":"","permalink":"http://yoursite.com/2019/04/22/VOA-Paris-Notre-Dame-Cathedral-Burning/","excerpt":"","text":"Paris’ Notre-Dame Cathedral BurningA major fire began to burn on Monday at France’s world-famous Notre-Dame de Paris Cathedral. 周一,法国著名的巴黎圣母院大教堂发生大火. Flames could be seen rising through the top of the monument. It tall,narrow spire later collapsed. 可以看到纪念碑的顶部火焰冲天,又高又窄的尖塔随后倒塌了. The cathedral dates back to the 12th century. Frech writer Victor Hugo used it as the setting of his famous story,The Hunchback of Notre-Dame,first published in 1831. 这座大教堂可追溯到12世纪.法国作家维克多·雨果把它作为其著名小说《巴黎圣母院》的背景,该书于1831年首次出版. The capthedral is one of world’s most famous tourist sites. About 12 million people visit Notre-Dame each year. It’s sits in the center of Paris,along the Seine River. 这座大教堂是世界上最著名的旅游景点之一.每年大约有1200万人参观巴黎圣母院.它位于巴黎市中心,塞纳河沿岸. The mayor of Paris,Anne Hidalgo wrote on Twitter Monday,”A terrible fire is underway at Notre-Dame Cathedral in Paris.” Hidalgo added that Paris firefighters were still trying to contain the fire. She urged people to stay away from the area. 巴黎市长安妮·伊达尔戈周一在推特上表示:”巴黎圣母院发生可怕的火灾.” 伊达尔戈补充说,巴黎消防员仍在努力控制火势.她督促人们远离该区域. As the cathedral’s roof continued to burn. a police officer near the scene told Reuters news agency, “Everying is collapsing.“ 随着大教堂的屋顶火势不断地蔓延,一名靠近现场的警官告诉路透社,”一切都在坍塌.” French President Emmanuel Macron delayed a planned scheduled speech to the nation because of the fire. The speech was to present his answers to the yellow vest crisis that has taken over the country since November. 法国总统艾玛纽埃尔·马克龙因火灾推迟了原定的全国讲话.此次演讲是为了回应自去年11月以来席卷全国的黄背心危机. Macron arrived at the scene of the fire Monday nigth. 马克龙于周一晚上抵达火灾现场. The cause off the fire was not immediately knownn. France 2 television reported that police was treating it as accidental. 火灾发生的原因尚不清楚.法国第二电视台报道说,警方认为这是一起意外事故. Workers had been renovating parts of Notre-Dame. Parts of the monument surrounded by metal and wood support structure. The cathedral’s bronze statues had been removed last week for repairs. 此前,人工们一直在修缮巴黎圣母院的部分建筑.纪念碑的一部分被金属和木头组成的支护结构包围.大教堂的青铜雕像上周已被移走进行修复. Notre-Dame’s first stone was laid in 1163 by Pope Alexander III,It’s main spire was added during repairs in the 19th century. 巴黎圣母院的第一块基石是1163年由教皇亚历山大三世奠基的.它的主尖塔是在19世纪修缮时加上去的. 重点词汇 cathedral (n) 大教堂. flame (n) 火焰. spire (n) 尖顶,塔尖. tourist (n) 旅游者,观光者. statue (n) 雕像,塑像. Seine (n) 塞纳河(法国北部河流，流经巴黎) agency (n) 代理,中介,代理处,经销处. vest (n) 背心,汗衫. crisis (n) 危机,危险期,决定性时刻. metal (n) 金属,合金. statue (n) 雕像,塑像. mayor (n) 市长. monument (n) 纪念碑,历史遗迹,不朽的作品. accidental (a) 意外的,偶然的. narrow (a) 狭窄的,有限的. underway (a) 进行中的,起步的. bronze (a) 青铜色的,青铜制的. urged (v) 怂恿,催促. collapsed (v) 倒塌,崩溃. contain (v) 控制,容纳. continue (v) 继续,延续. collapse (v) 崩溃,塌陷. delay (v) 延期,耽搁. treat (v) 对待,处理. renovate (v) 更新,修复. 重点短语 urged to do sth : 催促做某事. news agency : 通讯社,新闻通讯社. take over : 接管,接收.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:The Woman Behind the Image of the Black Hole","slug":"VOA-The-Woman-Behind-the-Image-of-the-Black-Hole","date":"2019-04-21T13:51:03.000Z","updated":"2019-08-25T06:31:01.095Z","comments":true,"path":"2019/04/21/VOA-The-Woman-Behind-the-Image-of-the-Black-Hole/","link":"","permalink":"http://yoursite.com/2019/04/21/VOA-The-Woman-Behind-the-Image-of-the-Black-Hole/","excerpt":"","text":"The Woman Behind the Image of the Black HoleTrying to capture an image of a black hole is like trying to take a picture of an orange sitting on the surface of the moon from Earth——with your smartphone. 试图捕捉黑洞的一张图片就好比在地球上试图用智能手机去拍摄在月f球表面放着的一个橙子. That is what Dr.Katie Bouman said two years ago during her TED talk called “How to take a picture of a black hole.” 这是两年前凯蒂·布曼博士在她的TED演讲《如果拍一张黑洞的照片》中所说的话. Bouman is 29 years old. She received her doctoral degrees in computer science and enginnering from the Masschusetts Institute of Technology. She later became a postdoctoral researcher with the international Event Horizon Telescope,or EHT,project. The project scientists produced a black hole image from data collected from a series of telecopes around the world. Together,they formed an Earth-sized “virtual” telescope——on powerful enough to do what had once seemed impossible. 布曼今年29岁,她在麻省理工学院获得了计算机科学和计算机工程博士学位.后来,她成为了国际事件视界望远镜(简称EHT)项目的博士后研究院.研究该项目的科学家们从世界各地各种望远镜收集的数据中的得出了一张黑洞图像.他们一起组成了一个地球大小的虚拟望远镜,这个望远镜强大到足以让他们完成曾经看起来不可能完成的任务. This week,the team of scientists,led by Sheperd S.Doeleman of Harvard University,released to the public the first-ever image of a black hole. 本周,由哈佛大学的谢泼德S.杜勒曼领导的科学家团队向公众发布了史上第一张黑洞图片. Soon after,another image was spreading over ssocial media and the news. It’s showed a smiling Bouman with the black hole image on her computer screen. She wrote on Facebook, “Watching in disbelief as the first image I ever made of a black hole was in the process of being reconstructed.” 不久之后,另一个照片在社交媒体和新闻上传播开来.照片上布曼在微笑,她后面的电脑屏幕上是黑洞的图像.她的脸书上写到: “看着我制作的第一张黑洞图片正在重新,这简直难以置信.” Bouman led a team that helped create an algorithm,or set of computer processes that turned the huge amout of telescopic data into one image. 布曼领导者的团队帮助创建了一种算法,或一组计算机处理程序,其能将望远镜观察到的大量数据转换为一张图像. Bouman quickly became a symbol for woman in science. 布曼很快成为了科学界女性的象征. One especially pupular Twitter post showed a side-by-side picture of Bouman with hard drives of black hole image data next to another woman scientist: Margarget Hamilton. In 1969,Hamilton helped write on-board computer code for NASA’s Apollo space program. 一条特别受欢迎的推特帖子展示了一张布曼与另一位女科学家玛格丽特·汉密尔顿并列的照片,布曼的硬盘里存有黑洞图像数据.1969年,汉密尔顿为美国宇航局的阿波罗太空计划编写了随行对计算机代码. Twitter user Tammy Emma Pepin wrote of Bouman,”Here’s to more women in science——getting their credit and being remembered in history.” 推特用户塔米·艾玛·佩平这样评论布曼: “让更多的科学女性获得荣誉,并被载入史册.” And Twitter user Pooja Chandrakekar,who recently completed her studies in engineering at Harvard,wrote, “So many young girls will see Dr.Katie Bouman as an inspiration and go on to make their own discoveries in space,physis,and computer science. A historic moment not just for science,but for women in science.” 推特用户普贾·钱德拉斯卡最近最哈佛大学工程学系毕业,她写到: “很多年轻女性都因凯蒂·布曼博士而大受鼓舞,决定在太空,物理和计算机科学领域做深入研究.这不仅是科学界的历史性时刻,也是科学领域中女性的历史时刻.” But Boman herself quickly noted that she was not the only one responsible for the image off the black hole. She posted on Facebook, “No one algorithm or person made this image,it required the amazing talent of a team of scientists from around the globe and years of hard work…” 但布曼本人很快指出,她并不是黑洞图像的唯一功臣. 她在Facebook上写到: “并不是什么算法或者人制作了这幅图像.这幅图像的的问世得益于世界各地的科学家团队的惊人才能和多年的辛勤工作···” After the press event Wednesday,Bouman spoke with members of the media. She said she is looking forward to developing more algorithms and methods that will help lead to an even better,sharper image of a black hole. 周期三的新闻发布会后,布曼对媒体说,她期待着开发更多的算法和方法,以帮助生成一幅更好,更清晰的黑洞图像. Bouman will begin her teaching career at the California Institute of Technology later this year. 今天晚些时候,布曼将在加州理工学院开始地她的教学生涯. I’m Ashley Thompson. 重点词汇 symbol (n) 象征. inspiration (n) 鼓舞. talent (n) 才能. telescope (n) 望远镜. disbelief (n) 怀疑,不信. engineering (n) 工程,工程学. horizon (n) [天]地平线,视野. surface (n) 表面,表层,外观. press (n) 压,按.新闻,出版社. sharper (n) 骗子,赌棍,欺诈犯. virtual (a) 虚拟的. postdoctoral (a) 博士后的. doctoral (a) 博士的,博士学位的. historic (a) 有历史意义的,历史上著名的. reconstruct (v) 重建,改造,修复,重现. on-board 随行. side-by-side 并肩的,并行的. 重点短语 Event Horizon Telescope : 视界望远镜. released to : 发布. Brightness sharper : 亮度更清晰.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:咖啡到底好不好?研究人员也说不清","slug":"VOA-咖啡到底好不好-研究人员也说不清","date":"2019-04-19T10:45:07.000Z","updated":"2019-08-25T06:31:01.096Z","comments":true,"path":"2019/04/19/VOA-咖啡到底好不好-研究人员也说不清/","link":"","permalink":"http://yoursite.com/2019/04/19/VOA-咖啡到底好不好-研究人员也说不清/","excerpt":"","text":"Large Review of Coffee Studies Finds…Not Much NewFrom VOA Learning English,this is the Health&amp;Lifestyle report. 这里是美国之音慢速英语与健康报道. Which is more popular —— coffee or tea ?If you are on Team Coffee,you team may be ahead. 如果你站在咖啡队,那就加一分. The well-known U.S. coffee shop Starbucks just opened its largest store in the land of tea: China! 美国著名的咖啡店星巴克在茶叶之国中国开了一家最大的门店! The Shanghai Starbucks is 2,700 square meters and employs more than 400 people. 上海星巴克占地2700平方米,员工400多人. But nw for the health question: Is coffee good for us ? 但现在从健康出发,咖啡对我们有好处吗? There have been many studies on the health benefits of coffee. Recently,researchers at the University of Southampton&#39;s Faculty of Medicine in Great Britain looked at results from 201 observational coffee studies and 17 clinical trial of coffee 有很多关于咖啡对健康的益处的研究.最近,英国南安普顿大学医学院的研究人员对咖啡进行了研究,他们观察了201项观测性研究和17项临床试验的结果. With this “umbrella review“ researchers wanted to find a clear answer on whether coffee is good for us or not. 在”撒网式研究”的帮助下,研究人员想找到一个明确的答案: 咖啡对我们是否有益. They discovered that coffee drinkers had a lower risk of heart and liver disease and some cancers. Coffee drinkers also had a lower risk of dying from stroke. 它们发现和咖啡的人患心脏病,肝病和一些癌症的风险较低.喝咖啡的人死于中风的风险也较低. However,their findings are uncertain. The researchers could not prove coffee was the cause of these lowered risks. 然而,他们的发现还不确定,研究人员不能证明咖啡是降低这些风险的原因. One of the researchers of this umbrella review is Robin Poole. Poole’s team notes that their umbrella review included mainly observational data. Therefore,they could not prove any cause and effect relationship. “撒网式研究”的其中一位研究人员是罗宾·普尔.普尔的团队注意到,它们的”撒网式研究”主要是观测数据.因此他们无法证明任何因果关系. The National Institutes of Health in the United States define an “observational uncontrolled study” as a study where “researchers simply watch what happens to a series of people in one group.”,There is no control group. 根据美国国家卫生研究院的定义,”不受控制的观测性研究”指的是”研究人员仅观察一组人中一部分人的情况”的研究.这种研究没有试验控制组. Still,researchers found that the benefits of moderate coffee drinking seem to outweght the risks. Their report says drinking coffee “was more often associated with benefit than harm.” 不过,研究人员发现,适度应用咖啡的好处似乎大于风险.它们的报告指出,喝咖啡”好处多于坏处”. Poole calls these findings “Handline benefits.” 普尔称这些发现为”看得见的益处”. There are some headline benefits such as a lower risk of dying from any cause,a lower risk of dying from heart disease and stroke and lower risk of developing heart diease in the first place. 有一些看得见的益处,比如降低死亡的风险,降低死于心脏病和中风的风险,以及降低患早期心脏病的风险.对于这些结果,每天喝三到四杯咖啡就可以带来最大的好处. Poole means that if people read only the headline,they may think that the result are simply positive. But he warns that the coffee story is much more complicated. 普尔的意思是：如果人们只看表面,他们可能会认为结果是积极的.但他提醒我们,咖啡要复杂得多. He advises people to not drink more than four cups a day. And not everyone should drink so much coffee. 他建议人们每天最多和四杯咖啡,而且不是每个人都应该喝这么多. Researchers found that: Too much coffee during pregnancy can be dangerous. 研究人员发现: 怀孕期间喝太多咖啡会很危险. People,esecially woman,whose bones break easily should limit how much coffee they drink. 人们,尤其是女性,骨头容易骨折,应该限制她们饮用咖啡的量. People with abnormal heart beat patterns are advised to drink decaffeinated coffee. 心脏跳动不规律的人建议饮用无咖啡因的咖啡. In addition,the scientists point out that the research was only about coffee. Yet many coffee drinkers don’t just drink coffee. They put sugar into it. They add milk or cream. They may have a baked treat on the side. 此外,科学家们指出这项研究是关于咖啡的.然而,许多和咖啡的人并不只是喝咖啡.他们往里面放糖.他们家牛奶或奶油.他们还可能还同时吃一些烘焙食品. Researcher Robin Poole warns that to get the full health benefits of coffee,keep it simple.Drinking it black is the healthiest. And skip the pastries. 研究人员罗宾·普尔提醒我们,要想充分享受咖啡的健康益处,要尽量简单.喝黑咖啡是最健康的.糕点就放弃吧. It’s not about the sugar and the syrups and the biscuits,cakes and pastries. And we should urge people who are already drinking moderate amounts of coffee——about the three or four cups per day mark——to enjoy it,but try and make it as healthy as possible because standard health message still apply to those other things. 这本身与糖,糖浆,饼干,蛋糕和糕点无关,我们会监督那些已经喝了适量咖啡的人——大约每天喝三到四杯咖啡——可以尽情享受这些食物,但是尽量保持健康饮食,因为标准的健康饮食也同样适用于其他食物. The researchers found that the greatest benefit to drinking coffee seemed to be in fighting livers diseases. Based on that finding. They are planning a clinical test using coffee as a treatment for cirrhosis,a serious liver disease. 研究人员发现和咖啡最大的好处似乎是对抗肝脏疾病.基于这一发现,他们计划用咖啡来对肝硬化进行临床试验,肝硬化是一种严重的肝病. But the final takeaway is the same as before: if you drink coffee,keep it simple and don’t eat the pastries or other baked treats that often come with a cup of coffee. 但最终的结论还是和以前一样: 如果你和咖啡,保持简单,不要同时吃糕点或其他烘焙食品. And if you’re not coffee drinker,you don’t need to start drinking coffee to be healthier. 如果你不喝咖啡,你也不必用喝咖啡来保持健康. And that’s the Health &amp; Lifestyle report. I’m Anna Matteo. 这就是健康与生活报道,我是安娜·马特奥. The coffee versus tea argument is always interesting. Let us know In the Comments Section,which drink you prefer. 人们对咖啡和茶总是争论不休.欢迎在评论区留言.告诉我们你更喜欢咖啡还是茶. 重点单词 Starbuck (n) 星巴克(咖啡公司). trial (n) 试验,审讯,努力,磨炼. liver (n) 肝脏,生活者,居民. stroke (n) 中风. Institute (n) 学会,协会,学院. dying (n) 死,死亡. pregnancy (n) 怀孕,丰富,多产. pastry (n) 油酥点心,面粉糕饼. syrup (n) 糖浆,果汁,含药糖浆. biscuit (n) 小点心,饼干. amount (n) 数量,总额,总数. cirrhosis (n) 硬化,[内科]肝硬化. observational (a) 观测的,根据观察的. clinical (a) 临床的,诊所的. moderate (a) 稳健的,温和的,适度的,中等的,有节制的. associated (a) 关联的,联合的. complicated (a) 难懂的,复杂的. decaffeinated (a) 无因咖啡的. abnormal (ad) 反常的,不规则的,变态的. baked (v) 烤的,烘焙的. urge (v) 力劝,催促,驱策,推进. 重点短语 Southampton’s Faculty of Medicine : 南安普敦医学院 clinical trial : 临床试验,诊治试验. associated with : 与..有关系,与..相联系. amounts of : 大量的,相当数量的. final takeaway : 最终的结论.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"详解Linked list的实现方式及其应用","slug":"详解Linked-list的实现方式及其应用","date":"2019-04-19T03:54:07.000Z","updated":"2019-09-01T14:09:15.918Z","comments":true,"path":"2019/04/19/详解Linked-list的实现方式及其应用/","link":"","permalink":"http://yoursite.com/2019/04/19/详解Linked-list的实现方式及其应用/","excerpt":"","text":"链表链表的定义链表是一种物理存储单元上非连续、非顺序的存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的.链表由一系列结点(链表中每一个元素称为结点)组成,结点可以在运行时动态生成.每个结点包括两个部分: 一个是存储数据元素的数据域,另一个是存储下一个结点地址的指针域. 链表的使用场景 数据量较小. 不需要预先知道数据规模. 适应于频繁的插入操作. 链表的实现方式单向链表 首先定义一个链表 123456789101112131415161718192021222324252627282930package pers.huangyuhui.linkedlist;/** * @ClassName: ListNode * @Description: 单向链表 * @author: HuangYuhui * @date: Apr 15, 2019 8:59:50 PM * */public class SinglyListNode&lt;E&gt; &#123; private E data; private SinglyListNode&lt;E&gt; next;// the pointer public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125; public SinglyListNode&lt;E&gt; getNext() &#123; return next; &#125; public void setNext(SinglyListNode&lt;E&gt; next) &#123; this.next = next; &#125;&#125; 操作单向链表的示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package pers.huangyuhui.linkedlist;/** * @ClassName: SinglyLinkedList * @Description: 操作单向链表 * @author: HuangYuhui * @date: Apr 15, 2019 8:54:46 PM * */public class SinglyLinkedList&lt;T&gt; &#123; SinglyListNode&lt;T&gt; headNode; public void createLinkedList() &#123; headNode = new SinglyListNode&lt;T&gt;(); // headNode.setData(0);// attention: the header node is zero default &#125; // get the header node of the linked list public T getHeaderNode() &#123; return headNode.getData(); &#125; // get the length of the linked list public int getListLength(/* ListNode headNode */) &#123; int length = 0; SinglyListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; &#125; return length; &#125; // add a new node into the linked list by specified position public SinglyListNode&lt;T&gt; insertInLinked(SinglyListNode&lt;T&gt; nodeToInsert, int position) &#123; if (headNode == null) &#123; System.err.println(\"Error: the linked list is empty !\"); return nodeToInsert; &#125; int size = getListLength(); if (position &gt; size + 1 || position &lt; 1) &#123; System.err.println(\"Position of node to insert is invalid. The vaild inputs are 1 to \" + (size + 1)); return headNode; &#125; if (position == 1) &#123; nodeToInsert.setNext(headNode); headNode = nodeToInsert; return nodeToInsert; &#125; else &#123; int count = 1; SinglyListNode&lt;T&gt; previousNode = headNode; while (count &lt; position - 1) &#123; previousNode = previousNode.getNext();// 待插节点的前节点 count++; &#125; SinglyListNode&lt;T&gt; currentNode = previousNode.getNext();// 待插节点的后节点 nodeToInsert.setNext(currentNode); previousNode.setNext(nodeToInsert); &#125; return headNode; &#125; // delete the node by the specified position in the linked node public boolean deleteNodeFromLinkedList(/* ListNode headNode, */ int position) &#123; int size = getListLength(); if (position &gt; size || position &lt; 1) &#123; System.err.println(\"Position of node to insert is invalid. The vaild inputs are 1 to\" + (size + 1)); return false; &#125; if (position == 1) &#123; SinglyListNode&lt;T&gt; currentNode = headNode.getNext(); headNode = currentNode; return true; &#125; else &#123;// 删除中间或表尾结点 int count = 1; SinglyListNode&lt;T&gt; previousNode = headNode.getNext(); while (count &lt; position) &#123; previousNode = previousNode.getNext(); // 找到待删节点的前节点 count++; &#125; SinglyListNode&lt;T&gt; currentNode = previousNode.getNext();// 待删节点 previousNode.setNext(currentNode.getNext()); currentNode = null; &#125; return true; &#125; // delete the singly linked list public boolean destroyLinkedList(/* ListNode headNode */) &#123; if (headNode == null) &#123; System.err.println(\"Error: the singly linked list is empty !\"); return false; &#125; System.out.print(\"delete the node: \"); while (headNode != null) &#123; System.out.print(headNode.getData() + \" , \"); headNode = headNode.getNext(); &#125; System.out.println(); return true; &#125; // Iterate through all the data in the linked list public boolean traverseNode( /* ListNode headNode */) &#123; if (headNode == null) &#123; System.err.println(\"Error: the linked node is empty !\"); return false; &#125; SinglyListNode&lt;T&gt; currentNode = headNode; System.out.print(\"All of node: \"); while (currentNode != null) &#123; System.out.print(currentNode.getData() + \" , \"); currentNode = currentNode.getNext(); &#125; System.out.println(); return true; &#125; // Test public static void main(String[] args) &#123; SinglyLinkedList&lt;String&gt; list = new SinglyLinkedList&lt;String&gt;(); // 定义待插入链表的节点 SinglyListNode&lt;String&gt; a = new SinglyListNode&lt;String&gt;(); a.setData(\"A\"); SinglyListNode&lt;String&gt; b = new SinglyListNode&lt;String&gt;(); b.setData(\"B\"); SinglyListNode&lt;String&gt; c = new SinglyListNode&lt;String&gt;(); c.setData(\"C\"); // 向单向链表中添加新的节点 list.createLinkedList(); list.insertInLinked(a, 1); list.insertInLinked(b, 2); list.insertInLinked(c, 1); System.out.println(\"The size of linked list: \" + list.getListLength()); System.out.println(\"The header node : \" + list.getHeaderNode()); list.traverseNode(); System.out.println(\"Delete the node which the position is first: \" + list.deleteNodeFromLinkedList(1)); list.traverseNode(); System.out.println(\"Delete all of node: \" + list.destroyLinkedList()); System.out.println(\"The size of linked list: \" + list.getListLength()); list.traverseNode(); &#125;&#125; 程序运行结果 123456789The size of linked list: 4The header node : CAll of node: C , A , B , null , Delete the node which the position is first: trueAll of node: A , B , null , delete the node: A , B , null , Delete all of node: trueThe size of linked list: 0Error: the linked node is empty ! 双向链表 定义链表 123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.linkedlist;/** * @ClassName: BidirectionalLinkList * @Description: 双向链表 * @author: HuangYuhui * @date: Apr 16, 2019 2:31:09 PM * */public class DoubleListNode&lt;E&gt; &#123; private E data; private DoubleListNode&lt;E&gt; next;// the pointer private DoubleListNode&lt;E&gt; previous; public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125; public DoubleListNode&lt;E&gt; getNext() &#123; return next; &#125; public void setNext(DoubleListNode&lt;E&gt; next) &#123; this.next = next; &#125; public DoubleListNode&lt;E&gt; getPrevious() &#123; return previous; &#125; public void setPrevious(DoubleListNode&lt;E&gt; previous) &#123; this.previous = previous; &#125;&#125; 操作双向链表的示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package pers.huangyuhui.linkedlist;/** * @ClassName: CircularList * @Description: 操作循环链表 * @author: HuangYuhui * @date: Apr 16, 2019 2:28:27 PM * */public class DoubleLinkedList&lt;T&gt; &#123; DoubleListNode&lt;T&gt; headNode; // initialize the circular list public void createCircularList() &#123; headNode = new DoubleListNode&lt;T&gt;();// Attention: the header node is empty default // headNode.setData(0); &#125; // get the length of the circular list public int getLength() &#123; int length = 0; DoubleListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; &#125; return length; &#125; // get the header node of the double linked list public T getHeaderNode() &#123; if (headNode == null) &#123; System.err.println(\"Error: the double linked list is empty !\"); return null; &#125; return headNode.getData(); &#125; // add new node into the double linked list by the specified position public DoubleListNode&lt;T&gt; insertNode(DoubleListNode&lt;T&gt; newNode, int position) &#123; if (headNode == null) &#123; System.err.println(\"Error: the double linked list is empty !\"); &#125; int size = getLength(); if (position &lt; 1 || position &gt; size + 1) &#123; System.err.println(\"Position of node to insert is invalid. The vaild inputs are 1 to \" + (size + 1)); return headNode; &#125; if (position == 1) &#123; newNode.setNext(headNode); headNode.setPrevious(newNode); headNode = newNode;// 更新头结点 return headNode; &#125; else &#123; int count = 1; DoubleListNode&lt;T&gt; previousNode = headNode; while (count &lt; position - 1) &#123; previousNode = previousNode.getNext(); count++; &#125; DoubleListNode&lt;T&gt; currentNode = previousNode.getNext();// 找到待插位置的节点 newNode.setNext(currentNode); if (currentNode != null) &#123;// 如果待插位置的节点不是尾节点 currentNode.setPrevious(newNode); &#125; previousNode.setNext(newNode); newNode.setPrevious(previousNode); &#125; return headNode; &#125; // delete node by the spcified position in the double linked list public boolean deleteNode(int position) &#123; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); return false; &#125; if (position == 1) &#123; DoubleListNode&lt;T&gt; secondNode = headNode.getNext(); secondNode.setPrevious(null); headNode = secondNode;// as the header node &#125; else &#123; int count = 1; //// `previousNode`与`headNode`操作的是同一个对象哟 ! //// DoubleListNode&lt;T&gt; previousNode = headNode; while (count &lt; position - 1) &#123; previousNode = previousNode.getNext();// 待删节点的前节点 count++; &#125; DoubleListNode&lt;T&gt; currentNode = previousNode.getNext();// 待删节点 DoubleListNode&lt;T&gt; laterNode = currentNode.getNext();// 待删节点的后节点 previousNode.setNext(laterNode); if (laterNode != null) &#123; laterNode.setPrevious(previousNode); currentNode = null; &#125; &#125; return true; &#125; // Iterate through all the data in the linked list public void traverseNode() &#123; DoubleListNode&lt;T&gt; node = headNode; if (node == null) &#123; System.err.println(\"Error: the circular list is empty !\"); &#125; while (node != null) &#123; System.out.println(\"the node: \" + node.getData()); node = node.getNext(); &#125; &#125; // destroy the double linked list public void destroyList() &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular list is empty !\"); &#125; while (headNode != null) &#123; System.out.println(\"delete the node: \" + headNode.getData()); headNode = headNode.getNext(); &#125; &#125; // Test public static void main(String[] args) &#123; // CircularList&lt;Integer&gt; list = new CircularList&lt;Integer&gt;(); DoubleLinkedList&lt;Character&gt; list = new DoubleLinkedList&lt;Character&gt;(); // 初始化待插节点 DoubleListNode&lt;Character&gt; a = new DoubleListNode&lt;Character&gt;(); a.setData('a'); DoubleListNode&lt;Character&gt; b = new DoubleListNode&lt;Character&gt;(); b.setData('b'); DoubleListNode&lt;Character&gt; c = new DoubleListNode&lt;Character&gt;(); c.setData('c'); // 向双向链表中添加新节点 list.createCircularList(); list.insertNode(a, 1); list.insertNode(b, 2); list.insertNode(c, 3); System.out.println(\"-------- traverse --------\"); list.traverseNode(); System.out.println(\"--------------------------\"); System.out.println(\"The header node: \" + list.getHeaderNode()); System.out.println(\"The length of the circular list: \" + list.getLength()); System.out.println(\"Delete the node which the position is one: \" + list.deleteNode(1)); System.out.println(\"-------- traverse --------\"); list.traverseNode(); System.out.println(\"--------------------------\"); System.out.println(\"The header node: \" + list.getHeaderNode()); System.out.println(\"The length of the circular list: \" + list.getLength()); System.out.println(); list.destroyList(); System.out.println(\"The header node: \" + list.getHeaderNode()); &#125;&#125; 程序运行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758-------- traverse --------the node: athe node: bthe node: cthe node: null--------------------------The header node: aThe length of the circular list: 4Delete the node which the position is one: true-------- traverse --------the node: bthe node: cthe node: null--------------------------The header node: bThe length of the circular list: 3delete the node: bdelete the node: cdelete the node: nullThe header node: nullError: the double linked list is empty !``` #### 循环链表1. *定义一个链表*```javapackage pers.huangyuhui.linkedlist;/** * @ClassName: CircularListNode * @Description: 循环链表 * @author: HuangYuhui * @date: Apr 17, 2019 9:52:23 AM * */public class ListNode&lt;T&gt; &#123; private T data; private ListNode&lt;T&gt; next; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ListNode&lt;T&gt; getNext() &#123; return next; &#125; public void setNext(ListNode&lt;T&gt; next) &#123; this.next = next; &#125;&#125; 操作循环链表的示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219package pers.huangyuhui.linkedlist;/** * @ClassName: CircularLinkedList * @Description: 操作循环链表 * @author: HuangYuhui * @param &lt;T&gt; * @date: Apr 16, 2019 7:25:36 PM * */public class CircularLinkedList&lt;T&gt; &#123; // get the length of the circular linked list public int getLength(ListNode&lt;T&gt; headNode) &#123; int length = 0; ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; if (currentNode == headNode) &#123; break; &#125; &#125; return length; &#125; // traverse the node of the circular linked list public void traverseNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; System.out.print(currentNode.getData() + \" -&gt; \"); currentNode = currentNode.getNext(); if (currentNode == headNode) &#123; break; &#125; &#125; System.out.print(\"headNode(\" + currentNode.getData() + \")\\n\"); &#125; // add new node at the tail of linked list public void insertAtListTail(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; //// 注意: 由于`currentNode`无变化,导致`currentNode.getNext() != headNode`继而进入进入死循环 !//// // currentNode.setNext(currentNode.getNext()); currentNode = currentNode.getNext(); &#125; newNode.setNext(newNode); if (headNode == null) &#123; headNode = newNode; &#125; else &#123; newNode.setNext(headNode); currentNode.setNext(newNode); &#125; &#125; // add new node at the header of linked list public ListNode&lt;T&gt; insertAtListHeader(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; currentNode = currentNode.getNext();// 尾节点 &#125; newNode.setNext(newNode);// 指针指向自身 if (headNode == null) &#123; headNode = newNode; &#125; newNode.setNext(headNode); currentNode.setNext(newNode); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = newNode; return headNode; &#125; // add the new node by the specified index public ListNode&lt;T&gt; insertNodeByIndex(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular list is empty !\"); return null; &#125; else if (position == 1) &#123; insertAtListHeader(headNode, newNode); &#125; else if (position == getLength(headNode)) &#123; insertAtListTail(headNode, newNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待插节点的前节点 currentNode = currentNode.getNext();// 待插节点 &#125; temp.setNext(newNode); newNode.setNext(currentNode); &#125; return headNode; &#125; // delete the last node public void deleteLastNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; temp = headNode; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); &#125; while (currentNode.getNext() != headNode) &#123; temp = currentNode; // 尾节点的前一个节点 currentNode = currentNode.getNext(); &#125; temp.setNext(headNode); currentNode = null; &#125; // delete the header node public ListNode&lt;T&gt; deleteHeaderNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); return null; &#125; while (currentNode.getNext() != headNode) &#123; // currentNode.setNext(currentNode.getNext());//死循环 currentNode = currentNode.getNext(); &#125; currentNode.setNext(headNode.getNext()); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = headNode.getNext(); return headNode; &#125; // delete the node by the specified index public ListNode&lt;T&gt; deleteNodeByIndex(ListNode&lt;T&gt; headNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular linked list is empty !\"); return null; &#125; else if (position == 1) &#123; deleteHeaderNode(headNode); &#125; else if (position == getLength(headNode)) &#123; deleteLastNode(headNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待删节点的前节点 currentNode = currentNode.getNext();// 待删节点 &#125; temp.setNext(currentNode.getNext()); &#125; return headNode; &#125; // Test public static void main(String[] args) &#123; // 初始化链表头结点 CircularLinkedList&lt;Integer&gt; list = new CircularLinkedList&lt;&gt;(); ListNode&lt;Integer&gt; headNode = new ListNode&lt;&gt;(); headNode.setData(1);// 初始化链表头结点 headNode.setNext(headNode);// 节点指针指向自身 // 初始化待插入的链表节点 ListNode&lt;Integer&gt; a = new ListNode&lt;&gt;(); a.setData(2); ListNode&lt;Integer&gt; b = new ListNode&lt;&gt;(); b.setData(3); ListNode&lt;Integer&gt; c = new ListNode&lt;&gt;(); c.setData(4); ListNode&lt;Integer&gt; d = new ListNode&lt;&gt;(); d.setData(100); ListNode&lt;Integer&gt; e = new ListNode&lt;&gt;(); e.setData(101); ListNode&lt;Integer&gt; f = new ListNode&lt;&gt;(); f.setData(0); // 向链表的尾部添加三个节点 System.out.print(\"the origin node: \"); list.insertAtListTail(headNode, a); list.insertAtListTail(headNode, b); list.insertAtListTail(headNode, c); list.traverseNode(headNode); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 向链表中添加两个头结点 System.out.print(\"add two header node: \"); ListNode&lt;Integer&gt; newHeadNode = list.insertAtListHeader(headNode, d); // 注意: 由于`头结点`已在`insertAtListHeader`中已更新所以要向`traverseNode`传入新的头结点 ListNode&lt;Integer&gt; newHeadNode2 = list.insertAtListHeader(newHeadNode, e); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 在链表的指定位置上插入新的节点 System.out.print(\"Insert the new node at position 3: \"); list.insertNodeByIndex(headNode, f, 3); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表的尾节点 System.out.print(\"delete the tail node: \"); list.deleteLastNode(newHeadNode2); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 注意: 由于`头结点`已在`deleteHeaderNode`中已更新所以要向`traverseNode`传入新的头结点 ListNode&lt;Integer&gt; newHeadNode3 = list.deleteHeaderNode(newHeadNode2); System.out.print(\"delete the header node: \"); list.traverseNode(newHeadNode3); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表中指定位置的节点 ListNode&lt;Integer&gt; newHeadNode4 = list.deleteNodeByIndex(newHeadNode3, 4); System.out.print(\"delete the fourth node: \"); list.traverseNode(newHeadNode4); System.out.println(\"the length of the list: \" + list.getLength(headNode)); &#125;&#125; 程序运行结果 123456789101112the origin node: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(1)the length of the list: 4add two header node: 101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 6Insert the new node at position 3: 101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 7delete the tail node: 101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(101)the length of the list: 6delete the header node: 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(100)the length of the list: 5delete the fourth node: 100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; headNode(100)the length of the list: 4 推荐书籍 上述示例程序主要参考本书籍：《数据结构与算法经典问题解析》—— 纳拉辛哈·卡路曼希[著] 很认真的说这是我大二至今看过的最好的一本关于数据结构与算法的书籍哟 ! 其针对不同问题提供多个具有不同复杂度的解决方案.兼顾自学教材和面试辅导的不同需求呢 !","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"data structures and algorithms","slug":"data-structures-and-algorithms","permalink":"http://yoursite.com/tags/data-structures-and-algorithms/"}]},{"title":"VOA:Google`s Lookout App Helps Blind People Experience the World","slug":"VOA-Google-s-Lookout-App-Helps-Blind-People-Experience-the-World","date":"2019-04-18T00:12:55.000Z","updated":"2019-08-25T06:31:01.092Z","comments":true,"path":"2019/04/18/VOA-Google-s-Lookout-App-Helps-Blind-People-Experience-the-World/","link":"","permalink":"http://yoursite.com/2019/04/18/VOA-Google-s-Lookout-App-Helps-Blind-People-Experience-the-World/","excerpt":"","text":"谷歌推出Lookout 应用帮助盲人看世界Google has launched a new app desgined to help blind people explore their surroundings. 谷歌推出了一款新应用,旨在帮助盲人探索周围环境. The free app,called Lookout,is currently available to users in the United States who own a Google Pixel device. The company says it hopes to bring Lookout to more devices and additional countries soon. 这款名为Lookout的免费应用,目前在美国拥有Google Pixel设备的用户都可以使用.谷歌公司表示,希望尽快让更多设备和国家可以使用Lookout应用. The app was first announced at Google’s I/O developer conference in May 2018. Since then,the company says it has been testing and working to improve te quality of its results. 该应用程序于2018年5月在谷歌的I/O开发者大会上首次发布.自那以后,该公司表示一直进行测试,并努力提高其结果质量. The app uses technology similar to Google Lens. That produt uses machine learning to recognize text and objects through device’s camera. Users can then receive information about or take actions related to the text and recognized objects. 该应用程序所使用的技术与Google Lens类似,Google Lens通过设备上的相机利用机器学习技术来识别文本和物体,然后,用户可以通过接收有关文本和可识别物体的信息继而采取相应的行动. Lookout builds on this same technology,but aims to provide assistance to people who are blind or have low vision. Lookout基于同样的技术,但这款应用旨在为盲人或视力低下的人提供帮助. The app users a devices’s camera to recognize text and objects and then provide voice descriptions about what is sees. 该应用程序使用设备的摄像头来识别文本和物体,然后提供对所见内容的语音描述. Lookout is not designed to describe everything,but instead seeks to search out things that people would most likely care about. The app can learn to judge what things are most important to a person over time. Lookout应用程序并不会对所有事务进行描述,而是寻找人们最关心的事情.随着时间的推移,这个应用程序可以学会判断什么是对用户来说是最重要的事情. Google says the app operates best when the wears a device around the neck or inside a pocket,with the camera lens pointed outward. 谷歌表示,当用户将设备戴在脖子上或放入口袋里,摄像头朝外时,应用程序运行效果最好. Lookout was thress main settings for people to use. Lookout应用有三种主要模式可供人们使用. The Explore setting is designed to provide assistance for people carrying out daily activities or for identifying things in new place. A Shopping setting can capture products and help users identify their money. The Quick Read setting can help users go through their email,read signs or identify other printed materials. 探索模式旨在为人们进行日常活动或识别新地方的事物提供帮助,购物模式可以捕获产品并帮助用户识别产品价格.快速阅读模式可以帮助用户浏览邮件,读取指示牌或识别其他印刷材料. User can control parts of the app through a fingeprint sensor. For example,the sensor can be used to change operating settings or go through recent result captured by the camera. The app has three different detail levels that can be activated to provide more or less information about objects. 用户可以通过指纹传感器控制应用程序的部分功能.例如,传感器可以用来改变操作模式或查看相机最近拍到的结果.这款应用提供三种不同的信息详细程序,激活后可以提供物体或多或少的信息. There are other apps and devices designed to assist these people,too. 还有其他的应用和设备为这些人提供帮助. Microsoft’s free Seeing AI app works similary to Google Lookout. Microsoft calls its system——launched for iPhone users in 2017 -a “talking camera for the blind.”,Seeing AI can recognize text,objects and people and speaks results to users. 微软的免费Seeing AI应用程序的工作原理与谷歌的Lookout应用乐类似.微软称其于2017年为iPhone用户推出的系统为: “盲人的语音相机”.Seeing AI可以识别文本,物体和人,并向用户播报结果. Microsoft says the system can provide audio sounds that relate to current light levels around the user. A recently released version also reportedly lets uers put their fingers over a photo of something to get a sense of how the object feels. The app produces smail vibrations sounds to help this process. 微软表示,该系统可以提供与当前用户周围光线水平相关的音频.据报道,最近发布的一个版本还允许用户将手指放在物体的照片上,以感知照片中的物体.这款应用程序会产生微小的震动和声音,为这一过程提供帮助. Another free app,called Be My Eyes,connects blind or low-sight individuals with sighted volunteers through live video calls. 另一款名为: “Be My Eyes”的免费应用程序通过实时的视频通话,将盲人或视力较低的人与视力正常的志愿者联系起来. I’m Bryan Lynn. 重点单词 lens (n) 透镜,镜头,眼睛中的水晶体. material (n) 材料,原料,物资,布料. sensor (n) 传感器. vibration (n) 振动,犹豫,心灵感应. 重点短语 over time : 随着时间的过去,久而久之,加班,超时.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:Napping May Improve Learning,Memory","slug":"VOA-Napping-May-Improve-Learning-Memory","date":"2019-04-17T00:44:57.000Z","updated":"2019-08-25T06:31:01.093Z","comments":true,"path":"2019/04/17/VOA-Napping-May-Improve-Learning-Memory/","link":"","permalink":"http://yoursite.com/2019/04/17/VOA-Napping-May-Improve-Learning-Memory/","excerpt":"","text":"VOA : 午休对学习记忆有益From VOA Learning English,this is the Health &amp; Lifestyle Report. 这里是美国之音慢速英语健康和生活报道. March 16 is International Sleep Day. 3月16日是国际睡眠日. And we should all celebrate the act of sleeping. Studies have shown that a good night’s rest helps us stay healthy,both mentally and physically. And researchers say sleep is probably the best tool we have for memeory and learning. 我们大家都应该庆祝睡眠这一行为.研究表明,晚上睡得好有益身心健康,研究人员说睡眠对记忆与学习来说也许是最佳的工具. Michael Twery is director of National Center on Sleep Disorders Research at Americal’s National Institutes of Health.Twery is an expert on the sicence of sleep and sleep disorders. He told me that a good night’s sleep helps to lean better. 迈克尔·特维里是美国国立卫生研究院睡眠絮乱研究中心的负责人,他是睡眠与睡眠障碍科学方面的专家,他跟我说晚间好的睡眠有助于学习. Getting a good night’s sleep is important for the learning and memory process. It’s important because it stores the training exercises and the learning exercises into our more permanent memory while we’re sleeping 7-8 hours in bed. And then the next morning when you wake up,your mind is better prepared to act on that information. 睡个好觉对于学习和记忆来说很重要,睡眠能够更加长久地存储我们的训练与学习信息,因为当我们睡七八个小时的时候,第二天早上起来时,你的大脑可以更好地准备处理那些信息. But what about getting durig the middle of the day? Short periods of sleep my help our brains work better,or so says a recent study on mapping. 不过在中午休息会如何? 最近,一项关于睡眠的调查表明,短时间睡眠有助于大脑的运转. Past studies have shown that mapping can help babies and young children learn better And napping can help brain performance in older adults. 以前的研究表明,宝宝和儿童午休有助于学习.对于年纪稍长的成年人来说,午休能够让大脑更好地运转. Taking a nap may also help this group of people fight off age-related memory loss. 午休也许能够帮助这些年轻人应对因年龄增长带来的记忆衰退. Many Americans do nap. But one-third of all adult in the United States are also chronically tired,notes the U.S. Centers for Disease Control and Prevention(CDC). It found that 50 million to 70 million Americans have chronic sleep disorders. 许多美国人都有午休的习惯.不过,美国疾病控制和预防中心指出,三分之一的美国成年人都有慢性疲劳,有5000万到7000万的美国人患有慢性睡眠絮乱症. So,someone who naps as a way of paying off a sleep debt may not experience the same improvements from mapping as a healthy,well-rested person would. 所以,同样是午休,缺乏睡眠的人与睡眠充足的健康人士相比,效果没有那么好. Also,many people may not want to admit that they take naps. They may think that napping shows they are weak or lack energy. They only children,the very old,sick or lazy people nap is not an uncommon opinion. 很多人也不想承认他们有午休的习惯.他们也许认为午休说明自己身体很弱,没有精力.人们普遍认为,只有小孩,老人,多病的人和懒人才会午休. In fact,we Americans somethimes do a very strange thing. Some brag about how few hours of sleep they need each night. 事实上,美国人有时候会做一件非常奇怪的事,有人会吹嘘自己一晚休息的时间是如果如何得少. Health experts suggest that adults get seven to eight hours of sleep each night. People who claim they only sleep four or five hours a night,they may think thery are somehow stronger than the average human - superhuman,if you will. 健康专家建议成年人一晚睡七到八个小时.那些说自己一晚只睡四五个小时的人,他们自认为比常人更加强壮——或者说是超人. However,that may be changing. Many offices now offer napping rooms and napping cafes are appearning in many U.S. cities,including Washington,D.C. 然而,情况不同的.美国城市许多办公室都在提供午休的房间和休息咖啡室,包括华盛顿地区. While resting in the middle of the work day may seem like a luxury to Americans,napping is very much part of normal,everyday life in other parts of the world. 工作日午睡对于美国人来说也许很奢侈,但是对于全世界上其它国家与地区来说,午睡是日常生活的一部分. Take China,for example: While it depends on the age and job,China,generally speaking,is a land of nappers. 就拿中国来说吧,午睡因年龄和职业而异,中国可以说是一个”午睡之国”. So,researchers receently looked at information provided by nearly 3000 Chinese adults,aged 65 year or older. They wanted to learn if napping after a min-day meal,a tradition in many areas,had any effect on the mental performance of the subjects. 所以,近期研究人员查阅了由3000名65岁及以上的中国人所提供的信息.他们想知道午餐(许多地区的传统)是否会对身体有影响. First,the researchers asked the people if they napped and for how long. Then based on their answers,researchers put them into four groups: non-nappers(0 minutes),short nappers(less than 30 minutes),moderate nappers(30-90 minutes),and extended nappers(more than 90 minutes). 首先,研究人员问这些参与调查的人是否会午睡?睡多久?然后,根据他们的回答,把他们分为四组:不午睡的人,睡很短时间的人(少于30分钟),睡眠时间适中的人(30-90分钟),睡时间很长的人(超过90分钟). Nearly 60 percent of those 3,000 people said they did take a nap after lunch and that their naps lasted anywhere from 30 to 90 minutes. Most of the subjects who said they napped said said they napped from about an hour. 在这3000人当中,近60%说自己午饭之后会午休30到90分钟.大多数会午睡的人一般都睡一个小时左右. The study found that people who took an hour-long map did much better on mental tests than those who did not nap. The hour-long nappers also did better on the test than those who napped for shorter and longer periods. In this study,it seems that the most effective nap lasted for about an hour,but not much longer. 研究发现,午休一个小时的体能检验结果比不午休的人好.睡一个小时的人比午休时间短于一小时或长于一小时的人测验结果更好.在这次研究中,似乎最佳睡眠时长是一个小时左右,但别睡太长时间. These researchers reported their findings in Journal of the American Geriatrics Society. 这些研究人员在《美国老年学会杂志》上发布了他们的研究成果. Keep in mind,however,that these are the findings for those over the age of 65. 不过,要记住,这些研究成果是针对年龄在65岁以上的人. Yet Doctor Michael Twery notes that an hour long nap may be to long for young.healthy adults.”Currently,we’re recommending that we try to sleep for about 30 minutes or less. And 30 minutes is enough to remove the pressure to sleep and will help us feel more awake. If we nap longer,we will get trapped into those deeper layers of sleep,which can ben hard to get out of.” 不过迈克尔·特维里博士指出,对于身体健康的年轻人来说,午休一个小时或许太长了,”目前,我们建议大家睡30分钟或者更短,30分钟足够缓解睡眠压力,也会让我们更清醒.如果我们睡更长,会陷入深度睡眠,这样就很难醒过来了.” The feeling Twery described is called sleep inertia——the period when you awake from a very deep sleep. For a time.you are unable to think clearly. 特维里把这种感觉称为睡眠惯性——从深度睡眠中醒过来的那段时间.短时间之内,你无法清楚地思考. So sleep inertia is when someone is being awakened from deep sleep,Some individuals may find it hard to change instantly from that deep sleep——where everything is a bit foggy and confused to the fully awake state. We may be little bit clumsy. We may not have all our thoughts in order when we wake from deep sleep. 所以睡眠惯性就是人们从深度睡眠中醒过来,有些人会发现很难从深度睡眠中马上改变过来.或许我们有一点笨拙,从深度睡眠中醒过时来我们的思维并不是很清楚. The National Sleep Foundation also warns that if you have trouble falling asleep at night,limit your daytime nap to under 45 minutes. Also nap before 3 p.m. in the afternoon. 美国国家睡眠基金会警告称,如果晚上很难入眠,白天睡觉的时间要控制在45分钟之内,并且在下午三点之前进行午休. And that’s the Health &amp; Lifestyle report. I’m Anna Matteo. 以上就是今天的健康和生活报道,我是安娜·马泰奥. 重点词汇 luxury (n) 奢侈品. institute (n) 学会,协会,学院. disorder (n) 混乱,骚乱. expert (n) 专家,行家,能手 period (n) 周期,期间. inertia (n) 惯性,惰性,迟钝. individual (n) 个人,个体. nap (n/v) 午休. brag (v) 吹嘘. permanent (a) 永久的,永恒的,不变的. foggy (a) 有雾的,模糊的,朦胧的. mental (a) 精神的,脑力的,疯的. extended (a) 延伸的,扩大的,长期的. clumsy (a) 笨拙的. chronic (a) 慢性的. lazy (a) 懒的. mentally (ad) 精神上,智力上,心理上. chronically (ad) 长期地,慢性地,习惯性地. age-relate 年龄相关,与年龄相关. well-rested 休息充分的. 重点短语 fight off : 击退,排斥,竭力避免. be confused to : 迷惑,被混淆了.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"一款瞄准大学生的交友软件:TinderU","slug":"一款瞄准大学生的交友软件-TinderU","date":"2019-04-16T00:50:23.000Z","updated":"2019-08-25T06:31:01.134Z","comments":true,"path":"2019/04/16/一款瞄准大学生的交友软件-TinderU/","link":"","permalink":"http://yoursite.com/2019/04/16/一款瞄准大学生的交友软件-TinderU/","excerpt":"","text":"TinderU App Amins to Help College Student Find Frends,Partner —— August 26, 2018It is back-to-school season in the United States,Mang youg adults are headed to colloges and universities. 有又到了美国开学季.不少年轻人就要踏进大学校园. A new app might make their social lives as busy as their academic schedules. 一款新应用可能会让他们的社交生活和学业日程一样繁忙. The popular dating app Tinder has just launched TinderU.The tool is designed to help students find friends,study partners and, possibly, love. 热门约会应用Tinder刚刚推出了TinderU.该工具旨在帮助学生找出友谊,学习伙伴,还有爱情哟 ~(怎么感觉我好需要呀..) On TinderU,users can look at pictures and information about other students at their university and other schools nearby.Just like on Tinder,if you see somebody you think you might like,you swipe right to “match” with that person,If you are not interested,you swipe left to pass. 在TinderU上,用户可以看到本科生及周边学校学生的照片和信息.如同Tinder一样,如果你看到了自己可能感兴趣的人,就可以在屏幕上右滑,和对方”配对”.如果你不感兴趣就向左滑. Only college students attending four-year schools can use TinderU.Online and for-profit colleges and universities are not included at this time,All that TinderU requires of users is a .edu email address. 目前,只有就读于四年制大学的在校学生才可以使用TinderU,在线和盈利性学院的学生不包含在内.TinderU仅需要用户提供一个.edu邮箱地址就可以啦. Tinder launched in 2012 in Los Angeles,California. It’s widely used around the world.The app is especially popular among people aged 18 to 34. Tinder于2012年在加州洛杉矶推出,此后,在全世界得到了广泛应用.这款软件在18岁到34岁的人群中特别流行. Some people argue TinderU will destroy traditional socializing on college campuses.And they say student don’t need the app because they meet other students face-to-face each day. 一些人认为TinderU会破坏大学校园里的传统社交活动.他们认为学生们不需要这个应用程序,因为他们每天都要和其他学生面对面. But the experience of starting college can be overwhelming for some.Mang students become independent for the first time in th their lives when they go to college.They often do not know a single person in that new environment.Tinder supporters say the app can help users find like-minded people to talk and, maybe, ask out on a date. 然而,上大学的经历对一些人来说可能是难以承受的.因为对于许多学生而言,人生的第一次独立是从踏进学生生活的那一刻开始的.在那种新环境中,他们往往一个人也不认识.Tinder的支持者说:,这款应用可以帮助用户找到志同道合的朋友,他们可以一起聊天,还可以出去约会. The Tinder website says Tinder is in 190 countries,It averages 1.6 billion matches a day and reponsible for one million dates each week. I’m Caty Weaver. 重点词汇 schedule (n) 时间表. swipe (v) 滑动屏幕. match (v) 匹配. argue (v) 辩论,争论.证明,说服. overwhelming (adj) 压倒性的. for-profit (adj) 以盈利为目的,营利性,经营性 . (n) 营利性的机构 like-minded (adj) 志趣相投的,具有相似意向或目的. 重点短语 be headed to : 前往.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"Naming Notations","slug":"Naming-Notations","date":"2019-04-15T08:13:07.000Z","updated":"2019-08-25T06:31:01.020Z","comments":true,"path":"2019/04/15/Naming-Notations/","link":"","permalink":"http://yoursite.com/2019/04/15/Naming-Notations/","excerpt":"","text":"Java 命名规范Java总体命名规范 项目名全部小写. 包名全部小写. 类名首字母大写,其余组成词首字母依次大写. 变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词的首字母都要大写. 常量名全部大写. 所有命名规则必须遵循以下规则 : 名称只能由字母、数字、下划线、$符号组成. 不能以数字开头. 名称不能使用Java中的关键字. 坚决不允许出现中文及拼音命名. Java包名命名规范 Java的包名由小写单词组成,包的路径符合所开发的系统模块的定义,以便通过包名可得知其属于哪个模块,从而方便到对应包里找相应的实现类. 常规包名为了保障每个Java Package命名的唯一性,在Java编程规范中要求开发人员在自己定义的包名前加上唯一的前缀.由于互联网上的域名称是不会重复的,所以多数开发人员采用自己公司在互联网上的域名称作为自己程序包的唯一前缀.例如 : com.sun.swt... 公司项目 com : 公司项目,copyright由项目发起的公司所有. 包名 : com.公司名.项目名.模块名.. 团队项目 team : 团队项目,指由团队发起,并由该团队开发的项目,copyright属于该团队所有. 包名 : team.团队名.项目名.模块名.. 自定义包名一般公司命名为com.公司名.项目名.模块名....那我们个人的项目又怎么命名呢? 个人的英语单词有individual、personal、private、one-man,进一步对以上四个单词词意进行分析并在保证了唯一性,继而使用每个单词的前4个字母作为前缀,与com也做了区分.示例如下所示: indi : 个体项目,指个人发起,但非自己独自完成的项目,可公开或私有项目,copyright主要属于发起者. 包名 : indi.发起者名.项目名.模块名.. pers : 个人项目,指个人发起,独自完成,可分享的项目,copyright主要属于个人. 包名 : pers.个人名.项目名.模块名.. priv : 私有项目,指个人发起,独自完成,非公开的私人使用的项目,copyright属于个人. 包名 : priv.个人名.项目名.模块名.. onem : 与indi相同，推荐使用indi.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java reflection","slug":"Java-reflection","date":"2019-04-15T00:39:07.000Z","updated":"2019-08-25T06:31:00.995Z","comments":true,"path":"2019/04/15/Java-reflection/","link":"","permalink":"http://yoursite.com/2019/04/15/Java-reflection/","excerpt":"","text":"Java Reflection概念Reflection(反射)是被认为动态语言的关键,反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息,并能直接操作任意对象的内部属性及方法. 应用动态代理 反射机制提供的功能 在运行时判断任意一个对象所属的类. 在运行时构造人任意一个类的对象. 在运行时判断任意一个类所具有的成员变量和方法. 在运行时调用任意一个对象的成员变量和方法. 生成动态代理(体现动态语言的特性). 反射相关的主要API java.lang.Class : 代表一个类. java.lang.reflect.Method : 代表类的方法. java.lang.reflect.Field : 代表类的成员变量. java.lang.reflect.Constructor : 代表类的构造方法. … 反射的简单应用示例 首先创建一个存储用户信息的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package pers.huangyuhui.reflection.bean;/** * @ClassName: UserInfo * @Description: 用户信息 * @author: HuangYuhui * @date: Apr 15, 2019 9:03:40 AM * */public class UserInfo &#123; public String name; private String sex; private int age; public UserInfo() &#123; super(); &#125; public UserInfo(String name, String sex, int age) &#123; super(); this.name = name; this.sex = sex; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"UserInfo [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\"; &#125; public void showClassInfo() &#123; System.out.println(\"ClassInfo: Store the user information .\"); &#125; public void introduce(String s) &#123; System.out.println(s + \" my name is: \" + name + \" age: \" + age + \" sex: \" + sex); &#125;&#125; 其次利用反射获取该类中的信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package pers.huangyuhui.reflection.bean.test;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import org.junit.Ignore;import org.junit.jupiter.api.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: UserInfoTest * @Description: 用`反射`获取`UserInfo`类中信息 * @author: HuangYuhui * @date: Apr 15, 2019 9:10:08 AM * */public class TestUseInfoByReflection &#123; // 不使用反射 : 创建`UserInfo`类对象,并调用其中的属性及方法 // @Test @Ignore public void commonTest() &#123; UserInfo userInfo = new UserInfo(); userInfo.setName(\"Java reflection\"); userInfo.setAge(1); userInfo.setSex(\"Male\"); userInfo.showClassInfo(); userInfo.introduce(\"Hello !\"); &#125; // 使用反射: 创建`UserInfo`类对象,并调用其中的属性及方法 @Test public void reflectionTest() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException &#123; // 下述两行代码体现了: `UserInfo userInfo = new UserInfo();`的工作 Class&lt;UserInfo&gt; class1 = UserInfo.class; // 创建运行时类`UserInfo`类的对象 UserInfo userInfo = class1.newInstance(); System.out.println(userInfo); /* * 通过`getField`调用别`public`修饰的`name`属性并为其赋值 */ java.lang.reflect.Field fieldName = class1.getField(\"name\");// `name`被`public`修饰,否则抛出: NoSuchFieldException fieldName.set(userInfo, \"Java reflection\"); System.out.println(userInfo); /* * 通过`getField`调用被`private`修饰的`age,sex`属性并为其赋值 */ Field fieldAge = class1.getDeclaredField(\"age\"); Field fieldSex = class1.getDeclaredField(\"sex\"); // 将此对象的 accessible 标志设置为指示的布尔值.值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查. // 值为 false 则指示反射的对象应该实施 Java 语言访问检查.实际上setAccessible是启用和禁用访问安全检查的开关, // 并不是为true就能访问为false就不能访问 ! false时使用对象会抛出 : IllegalAccessException . // 由于JDK的安全检查耗时较多,所以通过`setAccessible(true)`的方式关闭安全检查就可以达到提升反射速度的目的 . fieldAge.setAccessible(true); fieldSex.setAccessible(true); fieldAge.set(userInfo, 2); fieldSex.set(userInfo, \"male\"); System.out.println(userInfo); /* * 通过``调用对象指定的方法 */ java.lang.reflect.Method method = class1.getMethod(\"showClassInfo\"); // return: the result of dispatching the method represented bythis object on obj // with parameters args. method.invoke(userInfo); Method method2 = class1.getMethod(\"introduce\", String.class); method2.invoke(userInfo, \"Hello !\"); &#125;&#125; 程序运行结果如下 12345UserInfo [name=null, sex=null, age=0]UserInfo [name=Java reflection, sex=null, age=0]UserInfo [name=Java reflection, sex=male, age=2]ClassInfo: Store the user information .Hello ! my name is: Java reflection age: 2 sex: male 详解反射的源头 : Class在Object类中定义了以下的方法,此方法被所有子类继承 :12@HotSpotIntrinsicCandidate public final native Class&lt;?&gt; getClass(); 该返回值的类型是一个Class类,此类是Java反射的源头,实际上所谓的反射从程序的运行结果来看也也很理解,既: 可以通过对象反射求出类的名称. 正常方式 : 引入需要的包类名称 ——&gt; 通过new实例化 ——&gt; 取得实例化对象 反射方式 : 实例化对象 ——&gt; getClass() ——&gt; 得到完整的包类名称 getClass()的使用 示例程序如下 123456789101112131415161718192021222324package pers.huangyuhui.reflection.bean.test;import org.junit.jupiter.api.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: TestUserInfoByReflection2 * @Description: 学习反射源头: `Class`类 * @author: HuangYuhui * @date: Apr 15, 2019 11:58:34 AM * */public class TestUserInfoByReflection2 &#123; @Test public void getClassTest() &#123; UserInfo userInfo = new UserInfo(); // getClass() return: The Class object that represents the runtimeclass of this object. // 通过`运行时类`的对象,调用其`getClass()`返回其运行时类 Class&lt;?&gt; class1 = userInfo.getClass(); System.out.println(class1); &#125;&#125; 程序运行结果如下 1class pers.huangyuhui.reflection.bean.UserInfo //`运行时`类 运行时类 : example.java ——编译器(javac.exe)——&gt; example.class ——JVM类加载器——&gt; example.class被加载到内存(此时example.class就是一个运行时类,存放在缓存区,且运行时类本身就是一个Class实例并只加载一次 !) 获取Class类的实例的四种方式获取Class类的实例后我们可以进行如下的操作: 创建对应的运行时类的对象. 调用对应的运行时类的完整结构( 属性,方法,构造器 ). 获取对应的运行时类的完整结构( 属性,方法,构造器,父类,所在的包,异常,注解… ). 获取Class类实例的四种方式的示例程序如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package pers.huangyuhui.reflection.bean.test;import org.junit.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: GetClassObj * @Description: 获取`Class`类实例的四种方式 * @author: HuangYuhui * @date: Apr 15, 2019 12:34:21 PM * */public class GetClassObj &#123; // @Test // 第一种方式: 通过调用运行时类本身的`.class`属性 public void firstWayTest() &#123; Class&lt;UserInfo&gt; class1 = UserInfo.class; Class&lt;String&gt; class2 = String.class; // the result: class pers.huangyuhui.reflection.bean.UserInfo System.out.println(class1); // the result: class java.lang.String System.out.println(class2); &#125; // @Test // 第二种方式: 通过`运行时类`的对象获取 public void secondWayTest() &#123; UserInfo userInfo = new UserInfo(); Class&lt;? extends UserInfo&gt; class1 = userInfo.getClass(); // getName() return: the name of the class or interfacerepresented by this object. // the result: pers.huangyuhui.reflection.bean.UserInfo System.out.println(class1.getName()); &#125; // @Test // 第三种方式: 通过`Class`的静态方法获取 public void thirdWayTest() throws ClassNotFoundException, NoSuchMethodException, SecurityException, NoSuchFieldException &#123; String className = \"pers.huangyuhui.reflection.bean.UserInfo\"; Class&lt;?&gt; class1 = Class.forName(className); // the result: public java.lang.String // pers.huangyuhui.reflection.bean.UserInfo.name System.out.println(class1.getField(\"name\")); &#125; @Test // 第四种方式: 通过类加载器获取 public void fourthWayTest() throws ClassNotFoundException, NoSuchMethodException, SecurityException &#123; String className = \"pers.huangyuhui.reflection.bean.UserInfo\"; ClassLoader classLoader = this.getClass().getClassLoader(); // Invoking this method is equivalentto invoking loadClass(name,false). Class&lt;?&gt; class1 = classLoader.loadClass(className); // the result: public void pers.huangyuhui.reflection.bean.UserInfo.introduce(java.lang.String) System.out.println(class1.getMethod(\"introduce\", String.class)); &#125;&#125; 类加载器ClassLoader概念类加载器的作用:把类(class)装载进内存.如下示例1Java源文件(*.java) ——Java编译器——&gt; 字节码文件(*.class) ——类加载器+字节码效验器+解释器——&gt; 操作系统平台 JVM规范定义了两种类型的类加载器:启动类加载器(bootstrap)和用户自定义加载器(user-defined class loader).JVM在运行时会产生三个类加载器 引导类加载器. JVM自带的类加载器,负责Java平台核心库,用来加载核心类库,该加载器无法直接获取. 扩展类加载器. 负责jar包或将指定目录下的jar包装入工作库. 系统类加载器. 负责java-classpath或java.class.path所指的目录下的类与jar包装入工作.(最常用) 三个类加载器的示例程序如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.reflection.classloader;import org.junit.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: ClassLoader * @Description: 类加载器`Classloader` * @author: HuangYuhui * @date: Apr 15, 2019 5:37:30 PM * */public class TestClassLoader &#123; @Test public void systemClassLoaderTest() throws ClassNotFoundException &#123; /* * 获取`系统类加载器` */ ClassLoader classLoader = ClassLoader.getSystemClassLoader(); // getName() Returns: name of this class loader,or null if this class loader is // not named. // the result: jdk.internal.loader.ClassLoaders$AppClassLoader@28c97a5 System.out.println(classLoader); /* * 获取`系统类加载器`的父类加载器(`平台类加载器: getPlatformClassLoader`) */ ClassLoader classLoader2 = classLoader.getParent(); // the result: jdk.internal.loader.ClassLoaders$PlatformClassLoader@7bedc48a System.out.println(classLoader2); /* * 查看自定义类`UserInfo`由哪个加载器加载 */ Class&lt;UserInfo&gt; class1 = UserInfo.class; ClassLoader classLoader3 = class1.getClassLoader(); // the result: jdk.internal.loader.ClassLoaders$AppClassLoader@28c97a5 // 由运行结果可知,该自定义类被`系统加载器`加载 System.out.println(classLoader3); /* * 查看`java.lang.Object`(核心类库)由哪一个加载器加载 */ Class&lt;?&gt; class2 = Class.forName(\"java.lang.Object\"); ClassLoader classLoader4 = class2.getClassLoader(); // the result: null // 运行结果为`null`,说明该类被`引导类加载器`加载 ! // `引导类加载器`: `JVM`自带的类加载器,负责Java平台核心库,用来加载核心类库,该加载器无法直接获取 System.out.println(classLoader4); &#125;&#125; 类的加载过程当程序主动使用某个类时,如果该类还未被加载到内存中,则系统会通知如下三个步骤来对该类进行初始化. 类的加载 : 将类的Class文件读入到内存,并为之创建一个java.lang.Class对象,此过程由类加载器完成. 类的链接 : 将类的二进制数据合并到JRE中. 类的初始化 : JVM负责对类进行初始化. 类加载器的应用 利用ClassLoader读取指定包下的配置文件(如果不使用类加载器配置文件只能放在项目目录下..).程序示例如下 : 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.reflection.classloader;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.junit.Test;/** * @ClassName: ReadConfigFileInfo * @Description: 利用`ClassLoad` * @author: HuangYuhui * @date: Apr 15, 2019 6:29:39 PM * */public class ReadConfigFileInfo &#123; @Test public void classLoaderTest() throws IOException &#123; Properties properties = new Properties(); // 如果不使用`ClassLoader`,读取当前工程下的配置文件的方式如下: // FileInputStream fileInputStream = new FileInputStream(new File(\"user.properties\")); ClassLoader classLoader = this.getClass().getClassLoader(); // return: An input stream for reading the resource. InputStream inputStream = classLoader .getResourceAsStream(\"pers\\\\huangyuhui\\\\reflection\\\\classloader\\\\user.properties\"); // Reads a property list (key and element pairs) from the inputbyte stream. properties.load(inputStream); System.out.println(\"singer: \" + properties.getProperty(\"singer\") + \"\\nsong: \" + properties.getProperty(\"song\")); &#125;&#125; 在pers.huangyuhui.reflection.classloader包下创建配置文件user.properties 12singer=Justin Biebersong=Love yourself 程序运行结果如下 12singer: Justin Biebersong: Love yourself newInstance()创建运行时类的对象条件创建类的对象: 调用Class对象的newInstance()方法,要求如下： 类必须有一个无参数的构造器. 类的构造器的访问权限需要足够. 示例程序123456789101112131415161718192021222324252627282930package pers.huangyuhui.reflection.newinstance;import org.junit.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: NewInstanceTest * @Description: 使用`newInstance()`创建运行时类的对象 * @author: HuangYuhui * @date: Apr 16, 2019 10:08:37 PM * */public class NewInstanceTest &#123; @Test public void test() throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; String className = \"pers.huangyuhui.reflection.bean.UserInfo\"; Class&lt;?&gt; class1 = Class.forName(className); @SuppressWarnings(\"deprecation\") // 使用`newInstance()`创建对应的运行时类的对象时实际上是调用了运行时类的空参构造器. UserInfo userInfo = (UserInfo) class1.newInstance(); // the result: UserInfo [name=null, sex=null, age=0] System.out.println(userInfo); &#125;&#125; 通过反射调用类的完整结构 获取属性 略 获取方法 略 获取构造器 略 反射的应用之动态代理动态代理介绍 概念动态代理是指客户通过代理类来调用其它对象的方法,并且是在程序运行时根据需要动态创建目标类的代理对象. 使用场合调试及远程方法调用等.. 设计模式的原理使用一个代理将对象包装起来,然后使用该代理对象取代原始对象.任何对原始对象的调用都要通过代理.代理对象决定是否以及何时将方法调用转到原始对象上. 静态代理程序示例为了与动态代理相比较,静态代理程序示例如下.不难发现: 如果添加不同接口则需要不同的代理类来完成其代理!很繁琐!!12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package pers.huangyuhui.reflection.proxy;interface ClothFactory &#123; void createCloth();&#125;//被代理类class NikeClothFactory implements ClothFactory &#123; @Override public void createCloth() &#123; System.out.println(\"Create the cloth ..\"); &#125;&#125;//代理类class ProxyFactory implements ClothFactory &#123; NikeClothFactory nikeClothFactory; public ProxyFactory(NikeClothFactory nike) &#123; this.nikeClothFactory = nike; &#125; @Override public void createCloth() &#123; System.out.println(\"This is static proxy ..\"); nikeClothFactory.createCloth(); &#125;&#125;/** * @ClassName: StaticProxy * @Description: 静态代理 * @author: HuangYuhui * @date: Apr 18, 2019 10:31:27 AM * */public class StaticProxy &#123; public static void main(String[] args) &#123; NikeClothFactory nikeClothFactory = new NikeClothFactory(); ProxyFactory proxyFactory = new ProxyFactory(nikeClothFactory); proxyFactory.createCloth(); //程序运行结果如下所示 : // This is static proxy .. // Create the cloth .. &#125;&#125; 动态代理程序示例 反射是动态语言的关键,程序示例如下 :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package pers.huangyuhui.reflection.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;interface Subjet &#123; void action();&#125;//被代理类class RealSubject implements Subjet &#123; @Override public void action() &#123; System.out.println(\"被代理类执行的动作 ..\"); &#125;&#125;//实现动态代理的核心类class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 实现了接口的被代理类的对象的声明 // 给被代理的对象实例化 public Object dynamicInit(Object object) &#123; this.obj = object; // `动态`地创建指定代理类的对象并返回 return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); &#125; @Override // 当通过代理类的对象发起对被重写的方法调用时,都会转换为对如下`invoke`方法的调用 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object object = method.invoke(obj, args); return object; &#125;&#125;/** * @ClassName: DynamicProxy * @Description: 动态代理 * @author: HuangYuhui * @date: Apr 18, 2019 11:03:54 AM * */public class DynamicProxy &#123; public static void main(String[] args) &#123; MyInvocationHandler myInvocationHandler = new MyInvocationHandler(); RealSubject realSubject = new RealSubject(); // `dynamicInit`方法动态的返回一个同样实现了 `Real ...`所在类实现的接口`Subject`的代理类的对象 Object object = myInvocationHandler.dynamicInit(realSubject); // 此时`subject`为代理类的对象 Subjet subjet = (Subjet) object; // 调用`action`时会转到对`InvocationHandler`接口的实现类的`invoke`方法的调用 subjet.action(); // 为证明动态代理的特性,再实现一个接口的代理类的对象 NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory clothFactory = (ClothFactory) myInvocationHandler.dynamicInit(nikeClothFactory); clothFactory.createCloth(); //程序运行结果如下所示 : //被代理类执行的动作 .. //Create the cloth .. &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java annotation","slug":"Java-annotation","date":"2019-04-14T01:43:16.000Z","updated":"2019-08-25T06:31:00.993Z","comments":true,"path":"2019/04/14/Java-annotation/","link":"","permalink":"http://yoursite.com/2019/04/14/Java-annotation/","excerpt":"","text":"Java注解 (元数据)注解的概念及作用 从JDK1.5开始,Java支持在源文件中嵌入补充信息,这类信息被称为注解(annotation).注解不会改变程序的动作,因此也就不会改变程序的语义,但是在开发和部署期间,各种工具可以使用这类信息,例如: 源代码生成器可以处理注解! 注: 如果没有注解信息处理流程(如:通过反射查询注解),则注解毫无意义 ! 说明: 其实术语元数据(metadata),但是注解这个名称更具有描述性并且更常用. 声明注解 注解是一种代码级别的说明.它与类,接口,枚举在同一个层次,它可以声明在包,类,字段,方法,局部变量,方法参数等的前面,用来对这些元素进行说明,注释.. 注解的分类 特殊的注解 : 标记注解,单成员注解. 内置注解. 类型注解. 重复注解. 内置注解内置注解分类 java.lang.annotation包下的注解分别是 : @Retention,@Documnetd,@Target,@Inherited 以上四个注解被称为元注解,其作用是负责注解其它的注解,用来提供对其它annotation类型做说明. java.lang包下注解分别是 : @Override,@Deprecated,@FunctionalInterface,@SafeVarargs,@SuppressWarnings 注意: JDK8在java.lang.annotation中添加了Repeatable和Native注解.其中Repeatable支持重复注解,Native用于注解本机代码可以访问的域变量. 内置注解 : 非元注解 @SuppressWarnings注解使用详解如下图所示 @Override,@Deprecated,@SafeVarargs,SuppressWarnings程序示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.annotation.built_in_annotation;import java.util.ArrayList;/** * @ClassName: Built_in_annotations * @Description: 非元注解 * @author: HuangYuhui * @date: Apr 14, 2019 9:36:20 AM * */public class Built_in_annotations&lt;T&gt; &#123; @SuppressWarnings(\"unused\") private T[] args; // Type safety: Potential heap pollution via varargs parameter args.. // @SafeVarargs: 为标记注解,只能用于方法和构造方法,指示没有发生与可变长度参数相关的不安全动作. @SafeVarargs public Built_in_annotations(T... args) &#123; this.args = args; &#125; // @SafeVarargs: 该注解只能用于varargs方法或者声明为static或final的构造方法. @SafeVarargs public final void safeVarargsTest(T... args) &#123; for (@SuppressWarnings(\"unused\") T t : args) &#123; System.out.println(args); &#125; &#125; // @Override: 用于确保超类方法被真正地重写,而不是简单地重载. @Override public String toString() &#123; return super.toString(); &#125; // @Deprecated: 为标记注解,用于指示声明是过时的,并且已经被更新到的形式取代. @Deprecated public void deprecatedTest() &#123; &#125; // @SuppressWarnings: 用于抑制一个或多个编译器可能会报告的警告.使用以字符串形式表示的名称来指定要被抑制的警告. @SuppressWarnings(\"rawtypes\") public void supressWarningsTest() &#123; @SuppressWarnings(\"unused\") ArrayList arrayList = new ArrayList&lt;&gt;(); &#125;&#125; @FunctionalInterface程序示例 12345678910111213141516171819202122232425262728293031323334353637383940/** * @ClassName: functionalInterface * @Description: `学习@functionalInterface注解` * @author: HuangYuhui * @date: Apr 14, 2019 10:39:46 AM * *///`Java8`为函数式接口引入了一个新注解`@FunctionalInterface`,其主要用于编译错误检查,//加上该注释后当你写的接口不符合函数式定义时,编译器就会报错 !//注意: 是否添加`@FunctionalInterface`对于接口是不是函数式接口没有影响,//该注释只是提醒`编译器`去检查该接口是否仅仅包含一个抽象方法.@FunctionalInterfaceinterface functionalInterface &#123; // 注意: 函数式接口中只能有一个抽象方法 ! void myLambda(String message); // 函数式接口里是可以包含默认方法,因为默认方法不是抽象方法,其有一个默认实现, //所以是符合函数式接口的定义的. default void defaultMethod() &#123; // method body.. &#125; // 函数式接口里是可以包含静态方法,因为静态方法不能是抽象方法,是一个已经实现了的方法, //所以是符合函数式接口的定义的. static void staticMethod() &#123; // method body.. &#125; // 函数式接口里是可以包含Object里的public方法,这些方法对于函数式接口来说, // 不被当成是抽象方法(虽然它们是抽象方法).因为任何一个函数式接口的实现,默认都继承了Object类, //其包含了来自java.lang.Object里对这些抽象方法的实现! @Override boolean equals(Object object);&#125;//使用`@FunctionalInterface`注解的函数式接口继而可以使用`Lambda`表示式来表示该接口的一个实现.//(Java8 之前一般是使用匿名类实现的).//functionalInterface f = message-&gt;System.out.println(); 内置注解 : 元注解 使用@Target,@Retention自定义注解 12345678910111213141516171819202122232425import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @ClassName: MyTarget_annotation * @Description: 自定义注解 * @author: HuangYuhui * @date: Apr 14, 2019 11:12:54 AM * */@Target(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.CONSTRUCTOR &#125;)//用于指定可以应用注解的声明类型,被设计为只能注解其它注解.@Retention(RetentionPolicy.CLASS)//指定保留策略.public @interface MyTarget_annotation &#123; int id() default -1; //使用默认值 String name(); String[] address() default &#123; \"null\" &#125;;&#125; 使用自定义注解 123456789101112131415161718192021222324252627282930313233import pers.huangyuhui.annotation.myannotation.MyTarget_annotation;/** * @ClassName: TargetTest * @Description: 使用自定义注解 * @author: HuangYuhui * @date: Apr 14, 2019 11:38:23 AM * */@MyTarget_annotation(name = \"\")public class TargetTest &#123; // 由于声明的注解类型包含 : `CONSTRUCTOR`, 所以可以在构造方法前使用. @MyTarget_annotation(name = \"\") public TargetTest() &#123; // TODO Auto-generated constructor stub &#125; // 由于声明的注解类型包含 : `FIELD`, 所以可以在域变量前使用. @MyTarget_annotation(name = \"\") private String s; // 由于声明的注解类型包含 : `METHOD`, 所以可以在方法前使用. @MyTarget_annotation(id = 1, name = \"YUbuntu0109\", address = \"my address\") // 显式的定义注解值 public void testMethod() &#123; // 由于声明的注解类型包含 : `LOCAL_VARIABLE`, 所以可以在局部变量前使用. @SuppressWarnings(\"unused\") @MyTarget_annotation(name = \"\") int i; &#125;&#125; 使用反射获取注解 通过反射获取方法关联的注解 首先自定义一个注解 12345678910111213141516171819202122package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @ClassName: MyAnnotation * @Description: 自定义注解,用于通过反射获取注解信息的测试 * @author: HuangYuhui * @date: Apr 14, 2019 5:52:05 PM * */@Retention(RetentionPolicy.RUNTIME)//指定保留策略@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)public @interface MyAnnotation &#123; int id() default 1; String name() default \"default value\";&#125; 通过反射获取自定义注解信息 12345678910111213141516171819202122232425262728293031323334353637import java.lang.reflect.Method;import pers.huangyuhui.annotation.myannotation.MyAnnotation;/** * @ClassName: getAnnotationInfo * @Description: 通过反射获取方法关联的注解 * @author: HuangYuhui * @date: Apr 14, 2019 5:45:32 PM * */public class getAnnotationInfo &#123; @MyAnnotation(name = \"Hello annotation !\") public void fun(double d, String s) &#123; &#125; public static void main(String[] args) &#123; getAnnotationInfo getInfo = new getAnnotationInfo(); // 获取Class对象 Class&lt;?&gt; class1 = getInfo.getClass(); try &#123; // 通过调用Class泛型类提供的`getMethod`方法获取与方法相关的信息 Method method = class1.getMethod(\"fun\", double.class, String.class); // 通过调用`getAnnotation`获取与对象相关联的特定注解 MyAnnotation annotatioin = method.getAnnotation(MyAnnotation.class); System.out.println(\"id : \" + annotatioin.id() + \"\\nname : \" + annotatioin.name()); &#125; catch (NoSuchMethodException | SecurityException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序运行结果如下 12id : 1 name : Hello annotation ! 通过反射获取所有注解 首先自定义一个注解 1234567891011121314151617package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @ClassName: MyAnnotation2 * @Description: 自定义注解,用于反射获取注解信息的测试 * @author: HuangYuhui * @date: Apr 14, 2019 6:09:15 PM * */@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation2 &#123; String description();&#125; 通过反射获取自定义注解信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package pers.huangyuhui.annotation.reflect;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import pers.huangyuhui.annotation.myannotation.MyAnnotation;import pers.huangyuhui.annotation.myannotation.MyAnnotation2;/** * @ClassName: getAllAnnotationInfo * @Description: 通过反射机制获取所有注解 * @author: HuangYuhui * @date: Apr 14, 2019 6:10:29 PM * */@MyAnnotation()@MyAnnotation2(description = \"Test class\")public class getAllAnnotationInfo &#123; @MyAnnotation(id = 1, name = \"Hello annotation !\") @MyAnnotation2(description = \"Test method\") public void fun() &#123; &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; getAllAnnotationInfo allAnnotationInfo = new getAllAnnotationInfo(); // 通过`getAnnoations`获取该类所有注解信息 Annotation annotation[] = allAnnotationInfo.getClass().getAnnotations(); System.out.println(\"`getAllAnnotationInfo`类的所有注解 : \"); for (Annotation info : annotation) &#123; System.out.println(info); &#125; System.out.println(); // 通过调用Class泛型类提供的`getMethod`方法获取与方法相关的信息 Method method = allAnnotationInfo.getClass().getMethod(\"fun\"); // 通过调用`getAnnotation`获取与对象相关联的特定注解 annotation = method.getAnnotations(); System.out.println(\"方法`fun()`的所有注解 : \"); for (Annotation info : annotation) &#123; System.out.println(info); &#125; &#125;&#125; 程序运行结果如下 1234567`getAllAnnotationInfo`类的所有注解 : @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=1)@pers.huangyuhui.annotation.myannotation.MyAnnotation2(description=\"Test class\")方法`fun()`的所有注解 : @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"Hello annotation !\", id=1)@pers.huangyuhui.annotation.myannotation.MyAnnotation2(description=\"Test method\") 标记注解 编写示例程序来判断标记注解是否存在 12345678910111213141516171819202122232425262728293031323334353637383940import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.reflect.Method;/** * @ClassName: TagTest * @Description: 标记注解 * @author: HuangYuhui * @date: Apr 14, 2019 6:57:26 PM * */@Retention(RetentionPolicy.RUNTIME)@interface MyMarker_annotation &#123;&#125;public class MarketTest &#123; @MyMarker_annotation public static void fun() &#123; MarketTest marketTest = new MarketTest(); try &#123; // 通过调用Class泛型类提供的`getMethod`方法获取与该方法相关的信息 Method method = marketTest.getClass().getMethod(\"fun\"); // 通过使用`AnnotatedElement`接口的`isAnnotationPresent`方法来确定自定义注解中是否存在`标记注解` if (method.isAnnotationPresent(MyMarker_annotation.class)) &#123; System.out.println(\"存在标记注解 !\"); &#125; &#125; catch (Exception e) &#123; System.err.println(\"Method not found !\"); &#125; &#125; public static void main(String[] args) &#123; fun(); &#125;&#125; 程序运行结果如下 1存在标记注解 ! 说明 : 因为标记注解没有成员,所以应用标记注解时,后面不需要有圆括号.如果提供空的圆括号,也不会报错,但不是必需的.类似地,对于所有成员都使用默认值(default)的注解也可以没有圆括号. 重复注解 要创建重复注解,必须创建容器注解 123456789101112131415161718package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @ClassName: MyReapeatable_annotation * @Description: `重复注解`的容器注解 * @author: HuangYuhui * @date: Apr 14, 2019 8:08:21 PM * */@Retention(RetentionPolicy.RUNTIME)public @interface MyReapeatable_annotation &#123; // `value`成员指定的是重复注解类型的数组 MyAnnotation[] value();&#125; 创建重复注解 1234567891011121314151617181920212223package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @ClassName: MyAnnotation * @Description: 重复注解 * @author: HuangYuhui * @date: Apr 14, 2019 5:52:05 PM * *///指定`@Repeatable`注解的`value`成员值为容器注解 : `MyReapeatable_annotation`@Repeatable(MyReapeatable_annotation.class)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; int id() default 1; String name() default \"default value\";&#125; 通过反射获取重复注解信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package pers.huangyuhui.annotation.myannotation_test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import pers.huangyuhui.annotation.myannotation.MyAnnotation;/** * @ClassName: RepeatTest * @Description: 通过反射获取`重复注解`的信息 * @author: HuangYuhui * @date: Apr 14, 2019 7:58:54 PM * */public class RepeatTest &#123; @MyAnnotation @MyAnnotation(id=2) @MyAnnotation(id=3,name=\"YUbuntu0109\") public static void testMethod() &#123; RepeatTest repeatTest = new RepeatTest(); try &#123; // 获取Class对象 Class&lt;?&gt; class1 = repeatTest.getClass(); // 通过调用Class泛型类提供的`getMethod`方法获取与该方法相关的信息 Method method = class1.getMethod(\"testMethod\"); // `getAnnotation`用于获取与指定对象关联的特定注解 // Annotation annotation = method.getAnnotation(MyReapeatable_annotation.class); // System.out.println(annotation); // 使用`getAnnotationsByType`来获取`MyAnnotation`重复注解 Annotation[] annotations = method.getAnnotationsByType(MyAnnotation.class); for (Annotation info : annotations) &#123; System.out.println(info); &#125; &#125; catch (NoSuchMethodException e) &#123; System.err.println(\"Error : Method not found !\"); &#125; &#125; public static void main(String[] args) &#123; testMethod(); &#125;&#125; 程序运行结果如下 1234567891011121314//程序运行结果 :@pers.huangyuhui.annotation.myannotation.MyReapeatable_annotation(value=&#123;@pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=1), @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=2), @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"YUbuntu0109\", id=3)&#125;)//程序运行结果(使用`getAnnotationsByType`来获取`MyAnnotation`重复注解) : @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=1)@pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=2)@pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"YUbuntu0109\", id=3)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"详解Stack的实现方式及其应用","slug":"详解Stack的实现方式及其应用","date":"2019-04-13T02:00:01.000Z","updated":"2019-09-01T14:09:13.902Z","comments":true,"path":"2019/04/13/详解Stack的实现方式及其应用/","link":"","permalink":"http://yoursite.com/2019/04/13/详解Stack的实现方式及其应用/","excerpt":"","text":"栈栈的定义 : 栈(Stack)是一个有序线性表,只能在表的一端(称为栈顶 : top)执行插入和删除操作.最后插入的元素将第一个被删除.所以,栈也称为后进先出(Last In Frist Out: LIFO)或先进后出(Fist In Last Out: FILO)线性表.注意点 : 两个改变栈的操作都有专用名称,一个称为入栈(psuh): 表示在栈中插入一个元素. 另一个称为出栈(pop): 表示从栈中删除一个元素.试图对一个空栈执行出栈的操作称为下溢(underflow). 试图对一个满栈执行入栈操作称为溢出(overflow). 通常溢出和下溢均被认为是异常.栈的应用 直接应用 符号匹配. 中缀表达式转换为后缀表达式. 计算后缀表达式. 实现函数的调用(包括递归). 求范围误差(极差). 网页浏览器中已访问页面的历史记录(后退back按钮). 文本编辑器中的撤销(undo)序列. HTML和XML文件中的标签(tag)匹配. 间接应用 作为一个算法的辅助数据结构(例如: 树的遍历算法). 其它数据结构的组件(例如: 模拟队列). 推荐学习方法 推荐小伙伴们一个数据结构可视化的网站,可以大大提高学习效率哟(っ•̀ω•́)っ✎⁾⁾⁾ GO ! 栈的实现方式 基于简单数组的实现栈 ：程序示例如下*123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * @ClassName: SimpleStack * @Description: 利用简单数组实现栈 * @author: HuangYuhui * @param &lt;T&gt; * @date: Apr 10, 2019 4:15:47 PM * */public class SimArrayStack&lt;T&gt; &#123; // the size of stack private int maxSize; // store the data private Object[] stackArray; // the top pointer of the stack private int topPointer; public SimArrayStack(int max) &#123; maxSize = max; topPointer = -1; stackArray = new Object[maxSize]; &#125; // push new data into the stack public T push(T element) &#123; stackArray[++topPointer] = element; return element; &#125; // peek the top data in the stack public Object peek() &#123; return stackArray[topPointer]; &#125; // determines whether the stack is empty public boolean isEmpty() &#123; return topPointer == -1; &#125; // pop the data in the stack public Object pop() &#123; return stackArray[topPointer--]; &#125; // pop all of data in the stack public boolean popAll() &#123; if (isEmpty()) &#123; return false; &#125; while (!isEmpty()) &#123; System.out.println(\"The element to be poped : \" + pop()); &#125; return true; &#125; // Iterate through all the data in the stack public void traverseElement() &#123; System.out.print(\"All of element in the stack : \"); for (int i = 0; i &lt; stackArray.length; i++) &#123; if (i != stackArray.length - 1) &#123; System.out.print(stackArray[i] + \" , \"); &#125; else &#123; System.out.print(stackArray[i]); &#125; &#125; System.out.println(); &#125; // Test public static void main(String[] args) &#123; // SimpleStack&lt;Character&gt; stack2 = new SimpleStack&lt;Character&gt;(6); SimArrayStack&lt;Integer&gt; stack = new SimArrayStack&lt;Integer&gt;(6); stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); stack.push(6); stack.traverseElement(); System.out.println(\"The element to be poped : \" + stack.pop()); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Push a new element : \" + stack.push(7)); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Pop all of elements : \" + stack.popAll()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); &#125;&#125;/* ## The program running results are as follows :All of element in the stack : 1 , 2 , 3 , 4 , 5 , 6The element to be poped : 6The top element : 5Push a new element : 7The top element : 7Determines whether the stack is empty : falseThe element to be poped : 7The element to be poped : 5The element to be poped : 4The element to be poped : 3The element to be poped : 2The element to be poped : 1Pop all of elements : trueDetermines whether the stack is empty : true */ 局限性 : 栈的最大空间必须预先声明且不能改变.试图对一个满栈执行入栈时操作将产生一个针对简单数组这种特定实现栈方式的异常 ! 基于动态数组的实现栈 ：程序示例如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * @ClassName: DynArrayStack * @Description: 利用动态数组实现栈 * @author: HuangYuhui * @date: Apr 11, 2019 5:49:02 PM * */public class DynArrayStack&lt;T&gt; &#123; private int topPointer; private int capacity; private Object[] array; public DynArrayStack() &#123; topPointer = -1; capacity = 1; array = new Object[capacity]; &#125; // determines whether the stack is empty public boolean isEmpty() &#123; return (topPointer == -1); &#125; // determines whether the stack is full public boolean isStackFull() &#123; return (topPointer == capacity - 1);// or return (topPointer==array.length); &#125; // peek the top data of the stack public Object peek() &#123; return array[topPointer]; &#125; // push a new data into the stack public T push(T element) &#123; if (isStackFull()) &#123; doubleStack(); &#125; array[++topPointer] = element; return element; &#125; // double the size of the array public void doubleStack() &#123; Object newArr[] = new Object[capacity * 2]; System.arraycopy(array, 0, newArr, 0, capacity); capacity *= 2; array = newArr; &#125; // pop the data from the stack public Object pop() &#123; if (isEmpty()) &#123; System.err.println(\"The Stack is overflow !\"); &#125; return array[topPointer--]; &#125; // pop all of data from the stack public boolean popAll() &#123; if (isEmpty()) &#123; return false; &#125; while (!isEmpty()) &#123; System.out.println(\"The element to be poped : \" + pop()); &#125; return true; &#125; // Iterate through all the data in the stack public void traverseElement() &#123; System.out.print(\"all of element in the stack : \"); for (int i = 0; i &lt; array.length; i++) &#123; if (i != array.length - 1) &#123; System.out.print(array[i] + \" , \"); &#125; &#125; System.out.println(); &#125; // delete the stack public void deleteStack() &#123; topPointer = -1; &#125; // Test public static void main(String[] args) &#123; DynArrayStack&lt;Character&gt; stack = new DynArrayStack&lt;Character&gt;(); stack.push('a'); stack.push('b'); stack.push('c'); stack.push('d'); stack.push('e'); stack.push('f'); stack.push('g'); stack.traverseElement(); System.out.println(\"The element to be poped : \" + stack.pop()); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Push a new element : \" + stack.push('h')); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Pop all of elements : \" + stack.popAll()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); &#125;&#125;/*## The program running results are as follows :all of element in the stack : a , b , c , d , e , f , g , The element to be poped : gThe top element : fPush a new element : hThe top element : hDetermines whether the stack is empty : falseThe element to be poped : hThe element to be poped : fThe element to be poped : eThe element to be poped : dThe element to be poped : cThe element to be poped : bThe element to be poped : aPop all of elements : trueDetermines whether the stack is empty : true */ 注意 : 倍增太多可能导致内存溢出 !上述程序中利用重复倍增技术)提高了程序的性能,其总时间开销T(n) ≈ O(n) . 相比采用: 当栈满时,每次将数组的大小增加1更加节省了push操作的总时间开销.其总时间开销T(n) ≈ O(n²) . 基于链表来实现栈 ：程序示例如下12345678910111213141516171819202122232425262728293031323334353637/** * @ClassName: ListNode * @Description: 定义链表 * @author: HuangYuhui * @date: Apr 11, 2019 7:01:35 PM * */public class ListNode&lt;T&gt; &#123; private T data; private ListNode&lt;T&gt; next; public ListNode(T d) &#123; this.data = d; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ListNode&lt;T&gt; getNext() &#123; return next; &#125; public void setNext(ListNode&lt;T&gt; next) &#123; this.next = next; &#125; @Override public String toString() &#123; return \"[\" + data + \"]\"; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/** * @ClassName: ListStack * @Description: 利用链表实现栈 * @author: HuangYuhui * @date: Apr 11, 2019 6:59:46 PM * */public class ListStack&lt;E&gt; &#123; private ListNode&lt;E&gt; headNode; public ListStack() &#123; this.headNode = new ListNode&lt;E&gt;(null); &#125; // push a new node into the linked list public ListNode&lt;E&gt; push(E data) &#123; if (headNode == null) &#123; headNode = new ListNode&lt;E&gt;(data); &#125; else if (headNode.getData() == null) &#123; headNode.setData(data);// initialize header node. &#125; else &#123; ListNode&lt;E&gt; newNode = new ListNode&lt;E&gt;(data); // create a new node. newNode.setNext(headNode);// connect to the header node. headNode = newNode;// set the new node to header node. &#125; return headNode; &#125; // returns the top node of the linked list public E top() &#123; if (headNode == null) &#123; return null; &#125; else &#123; return headNode.getData(); &#125; &#125; // pop top node in the linked list public E pop() &#123; if (headNode == null) &#123; throw new EmptyStackException(); &#125; else &#123; E node = headNode.getData(); headNode = headNode.getNext();// Reset the header node. return node; &#125; &#125; // pop all of nodes in the linked list public boolean popAll() &#123; if (headNode == null) &#123; throw new EmptyStackException(); &#125; while (!isEmpty()) &#123; System.out.println(\"Pop all of nodes : \" + pop()); &#125; if (isEmpty()) &#123; return true; &#125; return true; &#125; // determine whether the linked list is empty public boolean isEmpty() &#123; if (headNode == null) &#123; return true; &#125; else &#123; return false; &#125; &#125; // Iterate through all the node in the linked list public void getNodeByLoop(ListNode&lt;E&gt; head) &#123; if (isEmpty()) &#123; throw new EmptyStackException(); &#125; System.out.print(\"All of nodes of the linked list: \"); while (head != null) &#123; if (head.getNext() != null) &#123; System.out.print(head.getData() + \" , \"); &#125; else &#123; System.out.print(head.getData()); &#125; head = head.getNext(); &#125; System.out.println(); &#125; // destroy the linked list public boolean destroyStack(/* ListNode&lt;E&gt; head */) &#123; ListNode&lt;E&gt; auxilaryNode = null, iterator = headNode; while (iterator != null) &#123; auxilaryNode = iterator.getNext(); iterator = null; iterator = auxilaryNode; headNode = iterator;// Set the node to be deleted as the header node. &#125; if (auxilaryNode == null) &#123; return true; &#125; return false; &#125; // Test public static void main(String[] args) &#123; // ListStack&lt;Integer&gt; stack = new ListStack&lt;Integer&gt;(); ListStack&lt;String&gt; stack = new ListStack&lt;String&gt;(); stack.push(\"A\"); stack.push(\"B\"); stack.push(\"C\"); stack.push(\"D\"); stack.push(\"E\"); stack.push(\"F\"); stack.push(\"G\"); stack.getNodeByLoop(stack.headNode); System.out.println(\"The node to be poped : \" + stack.pop()); System.out.println(\"The top node : \" + stack.top()); System.out.println(\"Push a new node : \" + stack.push(\"H\")); System.out.println(\"The top node : \" + stack.top()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Pop all of nodes(success ?) : \" + stack.popAll()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Push a new node : \" + stack.push(\"I\")); System.out.println(\"Push a new node : \" + stack.push(\"J\")); System.out.println(\"Push a new node : \" + stack.push(\"K\")); System.out.println(\"Destroy the stack(success ?) : \" + stack.destroyStack()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); &#125;&#125;/*## The program running results are as follows :All of nodes of the linked list: G , F , E , D , C , B , AThe node to be poped : GThe top node : FPush a new node : [H]The top node : HDetermines whether the stack is empty : falsePop all of nodes : HPop all of nodes : FPop all of nodes : EPop all of nodes : DPop all of nodes : CPop all of nodes : BPop all of nodes : APop all of nodes(success ?) : trueDetermines whether the stack is empty : truePush a new node : [I]Push a new node : [J]Push a new node : [K]Destroy the stack(success ?) : trueDetermines whether the stack is empty : true */ 栈的各种实现方法的比较 递增策略和倍增策略的比较 通过分析完成n个push操作的总时间开销T(n)来比较递增策略和倍增策略的区别.从长度为1的数组表示的空栈开始,一次push操作的平摊时间等于一组push操作的总时间开销的平均值.记为 : T(n)/n 递增策略 : 实现push操作的平摊时间开销为O(n)[O(n²)/n] . 倍增策略 : 实现push操作的平摊时间开销为O(n)[O(n)/n] . 基于数组实现和基于链表实现的比较(a) ：基于数组实现的栈 各个操作都是常数时间开销. 每隔一段时间倍增操作的开销过大. (从空栈开始)n个操作的任意序列的平摊时间开销为O(n).(b) ：基于链表实现的栈 栈规模的增加和减少都是很简洁. 各个操作都是常数时间开销. 每个操作都要使用额外的空间和时间开销来处理指针. 栈的应用 举例1 ：将用户输入的字符反转 首先定义一个基于简单数组的栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @ClassName: SimpleStack * @Description: 栈 * @author: HuangYuhui * @date: Apr 10, 2019 8:50:56 PM * */public class SimpleStack &#123; // 栈的大小 private int maxSize; // 存储栈元素 private char[] stackArray; // 栈顶指针 private int topPointer; public SimpleStack(int max) &#123; maxSize = max; topPointer = -1; stackArray = new char[maxSize]; &#125; // 逐个向栈中压入元素 public void push(char c) &#123; stackArray[++topPointer] = c; &#125; // 逐个弹出栈中元素 public char pop() &#123; return stackArray[topPointer--]; &#125; // 弹出栈中所有的元素 public void popAll() &#123; while (!isEmpty()) &#123; System.out.println(\"pop element : \" + pop()); &#125; &#125; // 查看栈顶元素 public char peek() &#123; return stackArray[topPointer]; &#125; // 判断栈是否为空 public boolean isEmpty() &#123; return topPointer == -1; &#125;&#125; 利用栈来反转字符 1234567891011121314151617181920212223242526272829303132333435363738/** * @ClassName: MyStack * @Description: 利用栈来反转字符串 * @author: HuangYuhui * @date: Apr 10, 2019 3:46:40 PM * */public class ReversalString &#123; private String input; private String output; public ReversalString(String in) &#123; this.input = in; &#125; // 反转字符 public String doReversal() &#123; int stackSize = input.length(); SimpleStack stack = new SimpleStack(stackSize); // 将字符逐个压入栈中 for (int i = 0; i &lt; input.length(); i++) &#123; char in = input.charAt(i); stack.push(in); &#125; // 将字符逐个从栈中取出 output = \"\"; while (!stack.isEmpty()) &#123; char out = stack.pop(); output += out; &#125; return output; &#125;&#125; 接收用户输入的字符并测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @ClassName: ReversalStringTest * @Description: 测试反转字符程序 * @author: HuangYuhui * @date: Apr 10, 2019 8:53:24 PM * */public class ReversalStringTest &#123; static BufferedReader bufferedReader; @Test public void reversalTest() throws IOException &#123; String input, output; while (true) &#123; System.out.println(\"Please enter a string : \"); // System.out.flush(); input = getString(); if (input.equals(\"exit\")) &#123; bufferedReader.close(); break; &#125; // 将字符串反转 ReversalString reversal = new ReversalString(input); output = reversal.doReversal(); System.out.println(\"Reversed : \" + output); &#125; &#125; @Test @Ignore // 测试BufferedString中的控制字符反转的方法 public void BufferedStringTest() &#123; StringBuffer stringBuffer = new StringBuffer(\"reverse\"); System.err.println(\"Reversed : \" + stringBuffer.reverse()); &#125; // 通过缓冲流中的'readLine'方法高效读入用户输入的数据 public static String getString() &#123; String s = null; bufferedReader = new BufferedReader(new InputStreamReader(System.in)); try &#123; s = bufferedReader.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125; 程序运行结果如下 : 1234567Please enter a string : my qq: 3083968068Reversed : 8608693803 :qq ymPlease enter a string : exit 举例 ：检查用户输入的运算符(括号匹配) 首先定义一个基于简单数组的栈(同上,略写) 利用栈中入栈和出栈操作匹配括号符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @ClassName: BracketChecker * @Description: 匹配括号 * @author: HuangYuhui * @date: Apr 10, 2019 9:58:36 PM * */public class BracketChecker &#123; private String input; public BracketChecker(String in) &#123; this.input = in; &#125; public void chekc() &#123; boolean flag_a = false; boolean flag_b = false; int stackSize = input.length(); SimpleStack stack = new SimpleStack(stackSize); for (int i = 0; i &lt; input.length(); i++) &#123; char in = input.charAt(i); switch (in) &#123; case '&#123;': case '(': case '[': case '&lt;': stack.push(in); break; case '&#125;': case ')': case ']': case '&gt;': // 括号匹配 if (!stack.isEmpty()) &#123; char out = stack.pop(); if ((in == '&#125;' &amp;&amp; out != '&#123;') || (in == ')' &amp;&amp; out != '(') || (in == ']' &amp;&amp; out != '[') || (in == '&gt;' &amp;&amp; out != '&lt;')) &#123; System.err.println(\"error : \" + in + \" at \" + i); &#125; else &#123; flag_a = true; &#125; &#125; else &#123; System.err.println(\"error : \" + in + \" at \" + i); flag_a = false; &#125; break; // 只检查括号 default: break; &#125; &#125; // 如果匹配成功,循环结束后栈中理应为空. if (!stack.isEmpty()) &#123; System.out.println(\"Error : missing right delimiter.\"); &#125; else &#123; flag_b = true; &#125; if (flag_a &amp;&amp; flag_b) &#123; System.out.println(\"Success !\"); &#125; &#125;&#125; 接收用户输入的运算符并测试匹配程序 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @ClassName: BracketCheckerTest * @Description: 测试匹配括号符程序 * @author: HuangYuhui * @date: Apr 10, 2019 9:58:55 PM * */public class BracketCheckerTest &#123; static BufferedReader bufferedReader; public static void main(String[] args) throws IOException &#123; String input; while(true) &#123; System.out.println(\"Please enter containing delimiters : \"); System.out.flush(); input = getString(); if(input.equals(\"exit\")) &#123; bufferedReader.close(); break; &#125; BracketChecker checker = new BracketChecker(input); checker.chekc(); &#125; &#125; // 通过缓冲流中的'readLine'方法高效读入用户的数据. public static String getString() &#123; String s = null; bufferedReader = new BufferedReader(new InputStreamReader(System.in)); try &#123; s = bufferedReader.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125; 程序运行结果如下 : 1234567891011121314151617181920Please enter containing delimiters : &#123;[&lt;a&gt;b]c)d&#125;efgerror : ) at 8error : &#125; at 10Please enter containing delimiters : &#123;([&lt;a&gt;b]c)defgError : missing right delimiter.Please enter containing delimiters : &#123;([&lt;a&gt;b]cd&#125;efgerror : &#125; at 10Error : missing right delimiter.Please enter containing delimiters : &#123;([&lt;a&gt;b]c)d&#125;efgSuccess !Please enter containing delimiters : exit","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"data structures and algorithms","slug":"data-structures-and-algorithms","permalink":"http://yoursite.com/tags/data-structures-and-algorithms/"}]},{"title":"A simple MVC example","slug":"A-simple-MVC-example","date":"2019-04-12T13:34:28.000Z","updated":"2019-08-25T06:31:00.953Z","comments":true,"path":"2019/04/12/A-simple-MVC-example/","link":"","permalink":"http://yoursite.com/2019/04/12/A-simple-MVC-example/","excerpt":"","text":"一个关于JSP的简单MVC案例 程序示例图如下所示 : Java bean : 封装用户的身份信息. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.servlet.bean;/** * @ClassName: UserInfo * @Description: 用户信息 * @author: HuangYuhui * @date: Apr 8, 2019 5:15:21 PM * */public class UserInfo &#123; private String name; private String password; public UserInfo(String name, String password) &#123; super(); this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 操作数据库的工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package pers.huangyuhui.servlet.util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: JDBCUtil * @Description: 操作数据库工具类 * @author: HuangYuhui * @date: Apr 8, 2019 5:08:24 PM * */public class JDBCUtil &#123; // initialize the driver of database. static &#123; try &#123; Class.forName(\"com.mysql.cj.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // Return a database connection object. public static Connection getConnection() &#123; Connection connection = null; try &#123; connection = DriverManager.getConnection( \"jdbc:mysql://LOCALHOST/DatabaseName?\" + \"useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\", \"root\", \"DatabasePassword\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; // release the resource of connecting. public static void freeResource(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet) &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 控制器(controller) : 用于验证用户的登录信息并根据其结果作出相应的处理. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.servlet.controller;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import pers.huangyuhui.servlet.bean.UserInfo;import pers.huangyuhui.servlet.modImpl.DalidateUserInfo;@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); UserInfo userInfo = new UserInfo(name, password); boolean result = new DalidateUserInfo().vaildateUserInfo(userInfo); if (result) &#123; // Sends a temporary redirect response to the client using thespecified redirect // location URL and clears the buffer. response.sendRedirect(\"weclome.jsp\"); &#125; else &#123; response.sendRedirect(\"error.jsp\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 用于操作用户信息的接口. 1234567891011121314package pers.huangyuhui.servlet.model;import pers.huangyuhui.servlet.bean.UserInfo;/** * @ClassName: LoginDao * @Description: 操作用户信息的接口 * @author: HuangYuhui * @date: Apr 8, 2019 5:53:53 PM * */public interface UserInfoDao &#123; public boolean vaildateUserInfo(UserInfo userInfo);&#125; 模型(model) : 实现了操作用户信息接口的类. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.servlet.modImpl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import pers.huangyuhui.servlet.bean.UserInfo;import pers.huangyuhui.servlet.model.UserInfoDao;import pers.huangyuhui.servlet.util.JDBCUtil;/** * @ClassName: DalidateUserInfo * @Description: 验证用户的身份信息 * @author: HuangYuhui * @date: Apr 8, 2019 4:55:27 PM * */public class DalidateUserInfo implements UserInfoDao &#123; private static String sql = \"SELECT name,password FROM user WHERE NAME=? AND PASSWORD=?\"; // 节省JDBC连接资源. private static Connection connection = JDBCUtil.getConnection(); private PreparedStatement preparedStatement; private ResultSet resultSet; public boolean vaildateUserInfo(UserInfo userInfo) &#123; try &#123; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, userInfo.getName()); preparedStatement.setString(2, userInfo.getPassword()); resultSet = preparedStatement.executeQuery(); if (resultSet.next()) &#123; return true; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtil.freeResource(null, preparedStatement, resultSet); &#125; return false; &#125;&#125; 视图(view) : 用户登录界面.: 123456789101112131415161718192021222324252627282930&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Login in&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userName\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userName\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"login in\" &gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 日记 : 今天做了大学第一个兼职!在一个购物广场旁折风车,串风车,固定风车…中午吃坐在地上吃盒饭时让我突然想起了四年前撤学外出的自己,难忘的是青春哟!计划把外快买书嘿嘿嘿..(っ•̀ω•́)っ✎⁾⁾⁾","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"jQuery 过滤器学习笔记","slug":"jQuery-过滤器学习笔记","date":"2019-04-10T01:59:17.000Z","updated":"2019-08-25T06:31:01.110Z","comments":true,"path":"2019/04/10/jQuery-过滤器学习笔记/","link":"","permalink":"http://yoursite.com/2019/04/10/jQuery-过滤器学习笔记/","excerpt":"","text":"jQuery 初学过滤器总结jQuery 过滤器分类 基础过滤器 内容过滤器 子元素过滤器 可见性过滤器 jQuery 基础过滤器 :header : 过滤器用于筛选所有标题元素.从’h1’到’h6’均在此选择范围内. :eq() : 过滤器用于选择指定序号为’n’的元素,序号从0开始. gt() : 过滤器用于选择大于序号为’n’的元素,序号从0开始. lt() : 过滤器用于选择所有小于序号为’n’的元素,序号从0开始. :first : 过滤器用于筛选第一个符合条件的元素. :last : 过滤器用于筛选最后一个符合条件的元素. even : 过滤器用于筛选符合条件的偶数个元素. odd : 过滤器用于筛选符合条件的奇数个元素. not() : 过滤器用于筛选所有不符合条件的元素. jQuery 基础过滤器示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 基础过滤器总结&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':header' : 过滤器用于筛选所有标题元素.从&lt;h1&gt;到&lt;h6&gt;均在此选择范围内 --&gt; $(document).ready(function() &#123; $(\":header\").css(\"background-color\", \"palegreen\"); &#125;); &lt;!--':eq()' : 过滤器用于选择指定序号为'n'的元素,序号从0开始 --&gt; &lt;!--'gt()' : 过滤器用于选择大于序号为'n'的元素,序号从0开始 --&gt; &lt;!--'lt()' : 过滤器用于选择所有小于序号为'n'的元素,序号从0开始 --&gt; $(document).ready(function() &#123; //'equal' : 影响的是第三行的列表选项元素&lt;li&gt;. $(\"li:eq(2)\").css(\"border\", \"1px solid #00FFFF\"); //'less than' : 影响的是第三行之后的所有列表选项. $(\"li:gt(2)\").css(\"border\", \"1px solid blue\"); //'greater than' : 影响的是第三行之前的所有列表选项. $(\"li:lt(2)\").css(\"border\", \"1px solid red\"); &#125;); &lt;!--':first' : 过滤器用于筛选第一个符合条件的元素 --&gt; &lt;!--':last' : 过滤器用于筛选最后一个符合条件的元素 --&gt; $(document).ready(function() &#123; //':first()' : 过滤器用于筛选第一个符合条件的元素. $(\"p:first\").css(\"border\", \"1px solid lawngreen\"); //':last()' : 过滤器用于筛选最后一个符合条件的元素. $(\"p:last\").css(\"background-color\", \"bisque\"); &#125;); &lt;!--'even' : 过滤器用于筛选符合条件的偶数个元素 --&gt; &lt;!--'odd' : 过滤器用于筛选符合条件的奇数个元素 --&gt; $(document).ready(function() &#123; //':even' : 过滤器用于筛选符合条件的偶数个元素. $(\"div#even_old tr:even\").css(\"background-color\", \"lightblue\"); //':odd' : 过滤器用于筛选符合条件的奇数个元素. $(\"div#even_old tr:odd\").css(\"background-color\", \"silver\"); &#125;); &lt;!--'not()' : 过滤器用于筛选所有不符合条件的元素 --&gt; $(document).ready(function() &#123; //注意:为避免冲突不能同时使用两行该过滤器,如果要同时除去两个段落元素可以使用如下语法规则. $(\":not(div#eq_gt_lt ul li,div#first_last p)\").css(\"border\", \"0.5px solid magenta\"); &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; div &#123; width: 160px; height: 180px; border: 1px solid; float: left; margin: 10px; &#125; ul &#123; width: 80px; height: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h3&gt;jQuery 基础过滤器总结&lt;/h3&gt; &lt;/center&gt; &lt;hr&gt; &lt;div id=\"eq_gt_lt\"&gt; &lt;ul&gt; &lt;li&gt;第一章&lt;/li&gt; &lt;li&gt;第二章&lt;/li&gt; &lt;li&gt;第三章&lt;/li&gt; &lt;li&gt;第四章&lt;/li&gt; &lt;li&gt;第五章&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"first_last\"&gt; &lt;p&gt;第一个段落元素&lt;/p&gt; &lt;p&gt;第二个段落元素&lt;/p&gt; &lt;p&gt;第三个段落元素&lt;/p&gt; &lt;/div&gt; &lt;div id=\"even_old\"&gt; &lt;table id=\"test\" border=\"1\" width=\"160\" height=\"180\"&gt; &lt;!-- &lt;caption&gt;table&lt;/caption&gt; --&gt; &lt;tr&gt; &lt;th&gt;Header&lt;/th&gt; &lt;th&gt;Header&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 基础过滤器示例图 jQuery 内容过滤器 :parent() : 用于选择包含子节点(子元素和文本)的元素,和:empty()恰相反哟. :empty() : 用于选择未包含子节点(子元素和文本的元素). :contains() : 用于筛选出所有包含指定文本内容的元素. :has() : 用于选择包含指定选择器的元素. jQuery 内容过滤器示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 内容过滤器总结&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':contains()' : 用于筛选出所有包含指定文本内容的元素 --&gt; $(document).ready(function() &#123; $(\"p:contains('瘦西湖')\").css(\"color\", \"red\"); &#125;); &lt;!--':empty()' : 用于选择未包含子节点(子元素和文本的元素) --&gt; $(document).ready(function() &#123; $(\"div#empty td:empty\").css(\"background\", \"darkgray\"); &#125;); &lt;!--':parent()' : 用于选择包含子节点(子元素和文本)的元素,和':empty()'恰相反哟 --&gt; $(document).ready(function() &#123; $(\"div#parent td:parent\").css(\"background-color\", \"lightblue\"); &#125;); &lt;!--':has()' : 用于选择包含指定选择器的元素 --&gt; $(document).ready(function() &#123; //选择包含&lt;strong&gt;标签的&lt;p&gt;元素. $(\"p:has(strong)\").css(\"background\", \"khaki\"); &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; div &#123; width: 150px; height: 230px; border: 1px solid; float: left; margin: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h3&gt;jQuery 内容过滤器总结&lt;/h3&gt; &lt;/center&gt; &lt;hr&gt; &lt;div id=\"contains\"&gt; &lt;p&gt;大明寺&lt;/p&gt; &lt;p&gt;瘦西湖北门&lt;/p&gt; &lt;p&gt;观音山&lt;/p&gt; &lt;p&gt;瘦西湖南门&lt;/p&gt; &lt;p&gt;扬州动植物园&lt;/p&gt; &lt;p&gt;瘦西湖东门&lt;p&gt; &lt;/div&gt; &lt;div id=\"empty\"&gt; &lt;table border=\"1\" width=\"150\" height=\"230\"&gt; &lt;tr&gt; &lt;th&gt;Header&lt;/th&gt; &lt;th&gt;Header&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=\"parent\"&gt; &lt;table border=\"1\" width=\"150\" height=\"230\"&gt; &lt;tr&gt; &lt;th&gt;Header&lt;/th&gt; &lt;th&gt;Header&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=\"has\"&gt; &lt;p&gt;这是段落元素..&lt;/p&gt; &lt;p&gt;这是&lt;strong&gt;段落&lt;/strong&gt;元素..&lt;/p&gt; &lt;p&gt;这是&lt;span&gt;段落&lt;/span&gt;元素..&lt;/p&gt; &lt;p&gt;这是段落元素..&lt;/p&gt; &lt;p&gt;这是段落元素..&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 内容过滤器示例图 jQuery 子过滤器 :nth-child : 用于筛选页面上每个父元素中的第’n’个子元素.序号从1开始计数 :first-child : 过滤器用于筛选页面上每个父元素中的第一个子元素. :last-child : 过滤器用于筛选页面上每个父元素中的最后一个子元素. :only : 用于筛选所有在父元素中有且只有一个的子元素. jQuery 子过滤器示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 子过滤器总结&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':first-child' : 过滤器用于筛选页面上每个父元素中的第一个子元素 --&gt; $(document).ready(function() &#123; $(\"div#firstChild ul li:first-child\").css(&#123; fontWeight: \"bold\", color: \"red\" &#125;); &#125;); &lt;!--':last-child' : 过滤器用于筛选页面上每个父元素中的最后一个子元素 --&gt; $(document).ready(function() &#123; $(\"div#lastChild p:last-child\").css(&#123; fontWeight: \"bold\", color: \"#0000FF\" &#125;); &#125;); &lt;!--':only' : 用于筛选所有在父元素中有且只有一个的子元素 --&gt; $(document).ready(function() &#123; $(\"div#onlyChild ul li:only-child\").css(&#123; fontWeight: \"bold\", color: \"chartreuse\" &#125;); &#125;); &lt;!--':nth-child' : 用于筛选页面上每个父元素中的第'n'个子元素.序号从1开始计数 --&gt;// $(document).ready(function() &#123;// //筛选奇数项子元素.// $(\"ul#item01 li:nth-child(odd)\").css(\"color\", \"red\");// //选择第一个子元素.// $(\"ul#item02 li:nth-child(2)\").css(\"color\", \"red\");// //选择第3n+2个子元素.// $(\"ul#item03 li:nth-child(3n+2)\").css(\"color\", \"red);// &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; div &#123; width: 150px; height: 180px; border: 1px solid; float: left; margin: 10px; &#125; ul &#123; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h3&gt;jQuery 子过滤器总结&lt;/h3&gt; &lt;/center&gt; &lt;hr&gt; &lt;div id=\"firstChild\"&gt; &lt;ul&gt; &lt;li&gt;Apple&lt;/li&gt; &lt;li&gt;Pear&lt;/li&gt; &lt;li&gt;Grape&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Bread&lt;/li&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"lastChild\"&gt; &lt;p&gt;段落元素01..&lt;/p&gt; &lt;p&gt;段落元素02..&lt;/p&gt; &lt;p&gt;段落元素03..&lt;/p&gt; &lt;p&gt;段落元素05..&lt;/p&gt; &lt;/div&gt; &lt;div id=\"onlyChild\"&gt; &lt;ul&gt; &lt;li&gt;第一个子元素&lt;/li&gt; &lt;li&gt;第二个子元素&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;唯一的子元素&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; 无标签的文本内容.. &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"nthChild\"&gt; &lt;ul id=\"item01\"&gt; &lt;!-- li:nth-child(odd): 筛选奇数项元素 --&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"item02\"&gt; &lt;!-- li:nth-child(2): 筛选第2个元素 --&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;li&gt;e&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"item03\"&gt; &lt;!-- li:nth-child(3n+2): 筛选第3n+2个元素 --&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 子过滤器示例图 jQuery 可见性过滤器 :hidden : 过滤器用于筛选出所有处于隐藏状态的元素. :visible : 过滤器用于筛选出所有处于可见状态的元素. jQuery 可见性过滤器示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 可见性选择器&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':hidden' : 过滤器用于筛选出所有处于隐藏状态的元素 --&gt; &lt;!--':visible' : 过滤器用于筛选出所有处于可见状态的元素 --&gt; $(document).ready(function() &#123; //选择处于隐藏状态的div元素. //find(selector): 用于查找处于可见状态的元素.该方法可以返回符合条件的元素的对象数组. var hideDiv = $(\"body\").find(\"div:hidden\"); //选择处于隐藏状态的input元素. //$(div#test01): 表示在id=\"test01\"的div元素中查找. var hideInput = $(\"div#test01\").find(\"input:hidden\"); //选择处于可见状态的input元素. var visbleInput = $(\"div.test02\").find(\"input:visible\"); //选择处于可见状态的div元素. var visbleDiv = $(\"body\").find(\"div:visible\"); window.alert(\"处于隐藏状态的div元素有:\" + hideDiv.length + \"个!\\n处于隐藏状态的input元素有:\" + hideInput.length + \"个 !\" + \"\\n处于显示状态的div元素有 : \" + visbleDiv.length + \"个!\" + \"\\n处于显示状态的input元素有 : \" + visbleInput.length + \"个!\"); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;&lt;/h3&gt; &lt;hr&gt; &lt;!-- 隐藏状态的div元素 --&gt; &lt;div style=\"display: none\"&gt;display:none&lt;/div&gt; &lt;!-- 显示状态的div元素 --&gt; &lt;div id=\"test01\"&gt; &lt;!-- 隐藏状态的input元素 --&gt; &lt;input type=\"hidden\" /&gt; &lt;/div&gt; &lt;!-- 显示状态的div元素 --&gt; &lt;div class=\"test02\"&gt; &lt;!-- 显示状态的input元素 --&gt; name : &lt;input type=\"text\" name=\"username\" /&gt;&lt;br /&gt;&lt;br&gt; password: &lt;input type=\"password\" name=\"userpassword\" /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 可见性过滤器示例图 Ok,学习笔记很简约,毕竟初学jQuery嘛.后期会不断更新我学习jQuery的学习笔记的(っ•̀ω•́)っ✎⁾⁾ ~ 最近养成了晨跑和夜跑的好习惯,也改掉了熬夜及大量饮咖啡的坏习惯,只想证明: 我会努力让自己更喜欢自己 !让你们喜欢我(✪ω✪) ~","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Java Servlet API","slug":"Java-Servlet-API","date":"2019-04-08T01:42:24.000Z","updated":"2019-08-25T06:31:00.992Z","comments":true,"path":"2019/04/08/Java-Servlet-API/","link":"","permalink":"http://yoursite.com/2019/04/08/Java-Servlet-API/","excerpt":"","text":"学习笔记 : Servlet API Servlet 体系结构图如下 Servlet 2.5 示例程序 web.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic_lifecycle&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;GlobalParamName&lt;/param-name&gt; &lt;param-value&gt;Web容器中的初始化参数值 ..&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;servlet-class&gt;pers.huangyuhui.servlet.test.ServletAPI&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;ServletParamName&lt;/param-name&gt; &lt;param-value&gt;当前Servlet的初始化参数值 ..&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletAPI&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet program 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * ServletConfig 接口中的方法解析如下 : * 1.ServletContext getServletContext(): 获取Servlet上下文对象,如: application.. * 2.String getInitParameter(String name): 在当前Servlet范围内,获取名为name的参数. ... * * ServletContext类中的常用方法解析 : * 1.getContextPath(): 相对路径. GetRealPath(): 绝对路径. * 2.String getInitParameter(String name): 在当前Web容器范围内,获取名为name的参数值(初始化参数值). * */public class ServletAPI extends HttpServlet &#123; private static final long serialVersionUID = -4244028101944729741L; @Override public void init() throws ServletException &#123; //super.init(); System.out.println(\"( Servlet 2.5 )This is init() ..\"); /* * 获取当前Servlet的初始化参数. * String getInitParameter(String name): 在当前Servlet范围内,获取名为name的参数. */ String value = super.getInitParameter(\"ServletParamName\"); //web.xml System.out.println(\"当前的Servlet的参数`ServletParamName`的值为 : \"+value); /* * 获取当前Web容器的初始化参数. * String getInitParameter(String name): 在当前Web容器范围内,获取名为name的参数值(初始化参数值). */ ServletContext servletContext = this.getServletContext(); String globalValue = servletContext.getInitParameter(\"GlobalParamName\"); //web.xml System.out.println(\"当前Web容器的参数`GobalParamName`的值为 : \"+globalValue); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doGet(req, resp); System.out.println(\"( Servlet 2.5 )service() -&gt; doGet()+doPost() ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doPost(req, resp); doGet(req, resp); &#125; @Override public void destroy() &#123; //super.destroy(); System.err.println(\"( Servlet 2.5 )This is destory() ..\"); &#125;&#125;/*### The result be shown as followed : Apr 06, 2019 6:45:24 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.( Servlet 2.5 )This is init() .. &lt;———the result当前的Servlet的参数`ServletParamName`的值为 : 当前Servlet的初始化参数值 .. &lt;———the result当前Web容器的参数`GobalParamName`的值为 : Web容器中的初始化参数值 .. &lt;———the resultApr 06, 2019 6:45:24 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.Apr 06, 2019 6:45:25 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.Apr 06, 2019 6:45:25 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"http-nio-8080\"]Apr 06, 2019 6:45:25 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"ajp-nio-8009\"]Apr 06, 2019 6:45:25 PM org.apache.catalina.startup.Catalina startINFO: Server startup in [3,136] milliseconds( Servlet 2.5 )service() -&gt; doGet()+doPost() .. &lt;———the result */ Servlet 3.0 示例程序 web.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;ServletAPI_3.0&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 注意: 全局的Web容器的参数是无法通过注解来配置的.毕竟注解只隶属于具体的一个Servlet,因此无法为整个Web容器设置初始化参数. 而全局的Web参数并不属任何一个Servlet.如果使用Servlet 3.0需要在web.xml配置文件中初始化该参数. 毕竟web.xml是属于整个容器的配置文件. --&gt; &lt;context-param&gt; &lt;param-name&gt;GobalParamName&lt;/param-name&gt; &lt;param-value&gt;GlobalParamValue&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * 通过注解为当前Servlet初始化参数.如下所示. */@WebServlet(value=\"/ServletAPI\",loadOnStartup=1,initParams= &#123;@WebInitParam(name=\"ServletParamName\",value=\"ServletParamValue\")&#125;)public class ServletAPI extends HttpServlet &#123; private static final long serialVersionUID = -4244028101944729741L; @Override public void init() throws ServletException &#123; //super.init(); System.out.println(\"( Servlet 3.0 )This is init() ..\"); /* * 获取当前Servlet的初始化参数. * String getInitParameter(String name): 在当前Servlet范围内,获取名为name的参数. */ String value = super.getInitParameter(\"ServletParamName\"); //web.xml System.out.println(\"当前的Servlet的参数`ServletParamName`的值为 : \"+value); /* * 获取当前Web容器的初始化参数. * String getInitParameter(String name): 在当前Web容器范围内,获取名为name的参数值(初始化参数值). */ ServletContext servletContext = this.getServletContext(); String globalValue = servletContext.getInitParameter(\"GlobalParamName\"); //web.xml System.out.println(\"当前Web容器的参数`GobalParamName`的值为 : \"+globalValue); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doGet(req, resp); System.out.println(\"( Servlet 3.0 )service() -&gt; doGet()+doPost() ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doPost(req, resp); doGet(req, resp); &#125; @Override public void destroy() &#123; //super.destroy(); System.err.println(\"( Servlet 3.0 )This is destory() ..\"); &#125;&#125;/*###The result be shown as followed : Apr 07, 2019 6:52:11 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.( Servlet 3.0 )This is init() .. &lt;———the result当前的Servlet的参数`ServletParamName`的值为 : ServletParamValue &lt;———the result当前Web容器的参数`GobalParamName`的值为 : GlobalParamValue &lt;———the resultApr 07, 2019 6:52:11 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"http-nio-8080\"] Apr 07, 2019 6:52:11 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"ajp-nio-8009\"]Apr 07, 2019 6:52:11 PM org.apache.catalina.startup.Catalina startINFO: Server startup in [2,502] milliseconds( Servlet 3.0 )service() -&gt; doGet()+doPost() .. &lt;———the result */","categories":[],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Back up the Hexo blog","slug":"Back-up-the-Hexo-blog","date":"2019-04-07T01:55:40.000Z","updated":"2019-08-25T06:31:00.956Z","comments":true,"path":"2019/04/07/Back-up-the-Hexo-blog/","link":"","permalink":"http://yoursite.com/2019/04/07/Back-up-the-Hexo-blog/","excerpt":"","text":"文章主题 : 备份及恢复Hexo博客的详细教程 备份原理: master branch: 管理Hexo生成的静态网页. HexoBackup branch: 管理Hexo 重要的本地源文件及配置文件. 前言 : 如果你利用Hexo搭建了一个静态的网站用于写博客,会发现自己利用Hexo deploy的都是Hexo generate生成的静态网页.而下面的目录并没有被push到远程仓库 ! 需要备份的目录及配置文件 source目录 : 博客文章的.md文件.(需要备份) themes 目录 : 主题文件夹.(需要备份) scaffolds目录 : 文章的模板.(需要备份) package.json : 安装包的名称.(需要备份) .gitignore : 限定在push时哪些文件可以忽略.(需要备份) _config.yml : 站点的配置文件.(需要备份) 不需要备份的目录及配置文件 node_modules/ : 是安装包的目录，在执行npm install的时候会重新生成.(不需要备份) .git/ : 主题和站点都有，标志这是一个git项目.(不需要备份) public是hexo generate生成的静态网页.(不需要备份) .deploy_git : 同3,hexo g也会生成.(不需要备份) db.json : 配置文件.(不需要备份) 注 : 不需要拷贝的文件正是.gitignore中所忽略的哟 ! 备份 创建GitHub仓库Username.github.io如果同名仓库之前已经创建,请将之前的仓库改名,新建的仓库必须是Username.github.io. 在Username.github.io仓库中创建一个新的分支HexoBackup.(此时的默认分支是: master) 在该仓库中的Setting中将HexoBackup修改为为默认分支. 将刚刚创建的新仓库clone至本地后将之前你存放Hexo bolg文件夹中的_config.yml,themes/,source/,scaffolds/,package.json,.gitignore复制至你所clone下来的Username.github.io文件夹中. 将themes/theme-name/中的.git/删除,否则无法将主题文件夹push到远程分支.(易错点 : 详情见文章最后的注意事项) 在Username.github.io文件夹执行npm install和npm install hexo-deployer-git(注意: 此时在该文件内的分支名应该显示为:HexoBackup). 通过执行git add .,git commit -m &quot;A description of the information submitted&quot;,git push origin HexoBackup来提交Hexo bolg网站的源文件. 如果更新博客文章后可以通过执行hexo g -d生成静态网页部署到Github上. 更新( 在本地对博客修改: 包括修改主题样式,发布新文章等.. ) 以下两个步骤没有严格的顺序,小伙伴们随心所欲呗 ~ 首先执行hexo g -d生成静态网页部署至Github上. 其次依次执行git add .,git commit -m &quot;&quot;,git push origin HexoBackup来提交Hexo bolg网站源文件. 恢复 ( 重装电脑后,或者在其它电脑上想修改自己的博客.. ) 安装git. 安装Nodejs和npm. 将博客仓库clone到本地. 在文件夹内执行命令npm install hexo-cli -g,npm install,npm install hexo-deployer-git. 注意事项 ( Hexo无法备份themes主题目录中的部分theme.. ) 如果想正常备份你所喜欢的theme的话,可以在博客目录运行如下命令 : 123456789101112131415161718$ git rm --cached themes\\theme-name\\rm 'themes/theme-name'$ git statusOn branch masterYour branch is up-to-date with 'origin/HexoBackup'.Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) deleted: themes/theme-nameUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) themes/theme-name///最后再执行: `git add themes/theme-name/` 就会发现可以成功备份该主题了哟 ! 原因分析 : 这是因为用到了git的子模块(git submodule)功能,既你在你的git项目里clone的他人的项目.在你的主项目的git库里,子模块只是一个HEAD指针,指向子模块的commit ..详情见下述参考的博客文章哟 (っ•̀ω•́)っ✎⁾⁾ 参考博客文章如下( 甚是感谢 ) : https://blog.itswincer.com/posts/7efd2818/ https://hoxis.github.io/hexo-backup-theme-dir.html","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]},{"title":"Servlet lifecycle","slug":"Servlet-lifecycle","date":"2019-04-06T07:06:10.000Z","updated":"2019-08-25T06:31:01.023Z","comments":true,"path":"2019/04/06/Servlet-lifecycle/","link":"","permalink":"http://yoursite.com/2019/04/06/Servlet-lifecycle/","excerpt":"","text":"学习笔记 ：Java Servlet 的生命周期及其解析 Tomcat v9.0 + JDK 11 + Google Chrome Servlet lifecycle Servlet 2.5 示例 JSP program 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"ISO-8859-1\"&gt; &lt;title&gt;Servlet 2.5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"ServletLifecyle\"&gt;doGet : Servlet 3.0&lt;/a&gt; &lt;!-- 注意: form的默认提交方式为get --&gt; &lt;div&gt; &lt;form action=\"ServletLifecyle\" method=\"get\"&gt;&lt;hr&gt; &lt;input type=\"submit\" value=\"doGet \" /&gt; &lt;/form&gt; &lt;form action=\"ServletLifecyle\" method=\"post\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"doPost\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ServletLifecyle extends HttpServlet &#123; @Override public void init() throws ServletException &#123; // TODO Auto-generated method stub //super.init(); System.out.println(\"(Servlet 2.5)init() ..\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub //super.doGet(req, resp); System.out.println(\"service() -&gt; doGet() + doPost() ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub //super.doPost(req, resp); this.doGet(req, resp); &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub //super.destroy(); System.out.println(\"destory() ..\"); &#125;&#125;/*### 1-第一次点击请求连接时Servlet响应的结果如下 :Apr 05, 2019 10:27:32 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the result### 2-当返回再次点击链接请求时Servlet响应的结果如下 : Apr 05, 2019 10:31:05 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() .. &lt;— 第一次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第一次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第二次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第三次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第四次点击链接时Servlet的相应结果...### 3-上述来回来点击链接请求后且稍许时间后会发现Servlet自动调用了destory() !!!?Apr 05, 2019 10:31:05 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() ..service() -&gt; doGet() + doPost() ..service() -&gt; doGet() + doPost() ..service() -&gt; doGet() + doPost() ..service() -&gt; doGet() + doPost() ..Apr 05, 2019 10:31:41 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] has starteddestory() ..### 由上述1,2,3可得如下结论 : init() : 默认情况下第一次访问Servlet时会被执行( 只执行一次 ),扩 : 也可以通过配置web.xml文件使得Tomcat启动时自动执行.(详见下述`web.xml`示例)service() : 包括doGet()和doPost(),执行的次数与调用次数成正比.destory() : 关闭Tomcat服务时执行一次.*/ web.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic_lifecycle&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- Servlet 2.5 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;servlet-class&gt;pers.huangyuhui.servlet.test.ServletLifecyle&lt;/servlet-class&gt; &lt;!-- 使得tomcat启动时自动加载init()方法,其数字代表: 当有多个Servlet时,规划其启动的顺序,默认值为`-1`. --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletLifecyle&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 12345678910通过在`web.xml`配置文件中添加'&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;'使得Tomcat启动时自动加载init() !INFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.(Servlet 2.5)init() .. &lt;——— the result.Apr 06, 2019 2:31:09 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"http-nio-8080\"]Apr 06, 2019 2:31:09 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"ajp-nio-8009\"]Apr 06, 2019 2:31:09 PM org.apache.catalina.startup.Catalina startINFO: Server startup in [2,686] milliseconds Servlet 3.0 示例12345678910111213/*Servlet 3.0 较2.5可以通过注解使Tomcat启动时自动加载Servlet 中的初始化方法: init().@WebServlet(value=\"/ServletTest\" , loadOnStartup=1)value : 其为一个字符串数组对象,用于接收多个Servlet,当只有一个Servlet时默认可以不写.loadOnStartup : 当有多个Servlet时将按照数字大小顺序执行.其默认为-1. */@WebServlet(value=\"/ServletTest\" , loadOnStartup=1)public class ServletTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; ······ 总结深究 ( 待解决的问题 )发现学习中我并没有关闭Tomcat服务器,但自动执行了销毁方法destory() ! 于是查了一些资料,至今还未发现其答案,我认为 : 应该是Tomcat新版本的特性吧(超时自动销毁Servlet?),但是自动调用Destory()时与Service()时间差也太小了吧 ! 36 秒啊 !12345678910111213### 3-上述来回来点击链接请求后且稍许时间后会发现Servlet自动调用了destory() !!!?Apr 05, 2019 10:31:05 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() ..service() -&gt; doGet() + doPost() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the resultApr 05, 2019 10:31:41 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] has starteddestory() .. &lt;—— the result ? what happend ! ? (I'm not close the the Tomcat server now)······ 注意 : &lt;—— 是本人后期为便于大家审阅代码加上的. 后期在不断学习中会完善这些我未知的问题的 ! Stay hungry,Stay foolish.","categories":[],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java Servlet各版本使用详解","slug":"Java-Servlet各版本使用详解","date":"2019-04-05T07:22:46.000Z","updated":"2019-08-25T06:31:00.993Z","comments":true,"path":"2019/04/05/Java-Servlet各版本使用详解/","link":"","permalink":"http://yoursite.com/2019/04/05/Java-Servlet各版本使用详解/","excerpt":"","text":"详细讲解各版本Java Servlet的使用,这次哥哥讲细节 (✪ω✪) !Servlet 2.5 : 通过配置web.xml文件来映射Servlet ( 示例代码如下 ) Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041public class FirstServlet extends HttpServlet &#123; private static final long serialVersionUID = -7228095681625205247L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"This is doGet ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); System.out.println(\"This is doPost ..\"); &#125;&#125;/* * #(doGet)The result be shown as followed : * * Apr 05, 2019 10:15:33 AM org.apache.catalina.core.StandardContext reload INFO: Reloading Context with * name [/Servlet_basic] is completed * This is doGet .. *//* * #(doPost)The result be shown as followed : * * Apr 05, 2019 10:57:08 AM org.apache.catalina.core.StandardContext reload INFO: Reloading Context with * name [/Servlet_basic] is completed * This is doPost .. * *//* * #(doPost —&gt; doGet)The result be shown as followed : * * Apr 05, 2019 11:22:21 AM org.apache.catalina.core.StandardContext reload NFO: Reloading Context with * name [/Servlet_basic] is completed * This is doGet .. * This is doPost .. * */ JSP Progarm 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"ISO-8859-1\"&gt; &lt;title&gt;Servlet 2.5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- href same as : http://localhost:8080/Servlet_basic_version_2.5/FirstServlet 注意: 构建路径及`WebContent`都属于 : 根目录. JSP中的'/'表示服务器的跟路径.如 : http://localhost:8080/ web.xml中的'/'表示项目的根路径.如 : http://localhost:8080/Servlet_basic_version_2.5/ --&gt; &lt;a href=\"/Servlet_basic_version_2.5/FirstServlet\"&gt;doGet : FirstServlet&lt;/a&gt; &lt;!-- 注意 : `form`的默认提交方式为`get`,所以修改为: method=\"post\" --&gt; &lt;div&gt; &lt;form action=\"FirstServlet\" method=\"get\"&gt;&lt;hr&gt; &lt;input type=\"submit\" value=\"doGet \" /&gt; &lt;/form&gt; &lt;form action=\"FirstServlet\" method=\"post\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"doPost\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 当程序运行后,点击`HiServlet.jsp`页面中的`url`请求时`web.xml`配置文件中的映射关系如下: 1.&lt;servlet-mapping&gt; ↓ ↓ 2.请求被根目录(src/WebContent是根目录)下&lt;url-pattern&gt;标签中的Servlet程序拦截. ↓ ↓ 3.(寻找Servlet.class的桥梁) 匹配与其&lt;servlet-name&gt;名称相同的&lt;servlet&gt;. ↓ ↓ 4.通过&lt;servlet-class&gt;标签中的`Servlet.class`响应用户的请求. 可此得知标签&lt;servlet-name&gt;是&lt;servlet&gt;和&lt;servlet-mapping&gt;之间沟通的桥梁( 其名称任意,但其两者间的名称必须相同 ! ) 如不同`Tomcat`则会抛出如下异常信息: error..Caused by: java.lang.IllegalArgumentException: Servlet mapping specifies an unknown servlet name [sameName].. --&gt; &lt;servlet&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;servlet-class&gt;pers.huangyuhui.servlet.test.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;url-pattern&gt;/FirstServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet 3.0 : 通过注解来映射相应的Servlet. Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*1.Servlet 3.0 与 Servlet 2.5 的区分 : Servlet 3.0 : 较`Servlet 2.0`不需要在web.xml中配置Servlet映射,但需在Servlet类的定义处上编写注解: @WenServlet(\"/Servlet url..\")其中\"/Servlet url..\"与Servlet 2.0在web.xml配置文件中&lt;url-pattern&gt;标签中的内容原理是相同的.2.Servlet3.0 响应请求的路线 : 如: 当点击`HiServlet.jsp`中的url链接时其先与@WebServlet中的值进行匹配,如果匹配成功,则说明请求的就是该注解所对应的类. */@WebServlet(\"/ServletTest\")public class ServletTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ServletTest() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub //response.getWriter().append(\"Served at: \").append(request.getContextPath()); System.out.println(\"This is doGet ..\"); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub //doGet(request, response); System.out.println(\"This is doPost ..\"); &#125;&#125;/*#The result be shown as followed : * * Apr 05, 2019 12:06:08 PM org.apache.catalina.startup.Catalina start * INFO: Server startup in [3,425] milliseconds * This is doGet .. &lt;— 点击`url`链接时`Servlet`触发的响应. * This is doPost .. &lt;— 点击`doPost`按钮时`Servlet`触发的响应. * This is doGet .. &lt;— 点击`doGet`按钮时`Servlet`触发的响应. * */ JSP Program 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"ISO-8859-1\"&gt; &lt;title&gt;Servlet 3.0&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"ServletTest\"&gt;doGet : Servlet 3.0&lt;/a&gt; &lt;div&gt; &lt;form action=\"ServletTest\" method=\"get\"&gt;&lt;hr&gt; &lt;input type=\"submit\" value=\"doGet \" /&gt; &lt;/form&gt; &lt;form action=\"ServletTest\" method=\"post\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"doPost\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; web.xml 12345678910111213&lt;!-- 无需任何修改 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic_version_3.0&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; JSP运行效果示例图 常被问到 : 辉仔啊,都大二下学期了呀,怎还是没有女朋友哟 ! 心想 : 是不是太爱Coding了呢 (灬°ω°灬) ~","categories":[],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Servlet同版本对应的Tomcat及不同版本的web.xml写法","slug":"Servlet同版本对应的Tomcat及不同版本的web-xml写法","date":"2019-04-05T06:34:34.000Z","updated":"2019-08-25T06:31:01.024Z","comments":true,"path":"2019/04/05/Servlet同版本对应的Tomcat及不同版本的web-xml写法/","link":"","permalink":"http://yoursite.com/2019/04/05/Servlet同版本对应的Tomcat及不同版本的web-xml写法/","excerpt":"","text":"Tomcat 实现了Java Servlet规范,Java Servlet Pages技术,不同版本的Tomcat支持不同的Servlet及JSP规范. 最新示例图如下所示 : 不同版本的web.xml写法如下 : web.xml v2.3 12345&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt; &lt;web-app&gt; &lt;!-- ... --&gt;&lt;/web-app&gt; web.xml v2.4 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app id=\"WebApp_9\" version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; &lt;/web-app&gt; web.xml v2.5 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt;&lt;/web-app&gt; web.xml 3.0 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt; &lt;/web-app&gt; web.xml 4.0 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE xml&gt;&lt;web-app version=\"4.0\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"&gt;&lt;/web-app&gt;","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"JDK","slug":"JDK","permalink":"http://yoursite.com/tags/JDK/"}]},{"title":"jQuery selector","slug":"jQuery-selector","date":"2019-04-04T10:39:52.000Z","updated":"2019-08-25T06:31:01.108Z","comments":true,"path":"2019/04/04/jQuery-selector/","link":"","permalink":"http://yoursite.com/2019/04/04/jQuery-selector/","excerpt":"","text":"为了配合Java web项目的学习今天开始学习了jQuery 啦 ! 要知道计算机语言之间是互通的,已学习C和Java的我学习jQuery起来是如此的高效,基本一天就可以学习半本书哟.. 下面是我下午学习jQuery选择器的总结代码.嘿嘿,案例是不是也很搞笑(高效)呢 ?! 啊哈哈 ヾ(◍°∇°◍)ﾉﾞ 代码示例 ( jQuery vision : jquery-1.12.4.js,目前官方最新版本是: jquery-3.3.1.js ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 选择器总结案例&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //全局选择器 (Global Select) : 用于选择文档中所有的元素. $(document).ready(function() &#123; $(\"*\").css(\"border\", \"1px solid red\"); &#125;); //元素选择器 (Element Select) : 用于选择所有指定标签名称的元素. $(document).ready(function() &#123; $(\"p\").css(\"border\", \"1px solid blue\"); &#125;); //ID选择器 (ID Select) : 用于选择指定ID名称的单个元素. $(document).ready(function() &#123; $(\"#test01\").css(\"border\", \"1px solid aqua\"); &#125;); //类选择器 (Class Select) : 用于筛选出具有同一个class属性的所有元素. $(document).ready(function() &#123; $(\".style01\").css(\"border\", \"1px solid fuchsia\"); &#125;); //多重选择器 (Multiple Select) : 适用于需要批量处理的多种元素. $(document).ready(function() &#123; $(\"h3,div.style02\").css(\"border\", \"1px solid forestgreen\"); &#125;); //属性选择器 (Attribute Select) : 选择具有指定属性要求的元素. $(document).ready(function() &#123; $(\"[href$='.cn']\").css(\"background-color\", \"yellow\"); &#125;); //表单选择器 (Form Select) : 用于选择指定类型或处于指定状态的表单元素. $(document).ready(function() &#123; $(\":password\").css(\"border\", \"2px solid blue\"); &#125;); //子元素选择器 (Child Select) : 只能选择指定元素的第一层子元素. $(document).ready(function() &#123; $(\"ul.ul-2&gt;li\").css(\"background-color\", \"yellowgreen\"); &#125;); //后代选择器 (Descendant Select) : 选择指定元素内包含的所有后代元素.比子元素选择器的涵盖范围更广. $(document).ready(function() &#123; $(\"div.style04 strong\").css(\"background-color\", \"chartreuse\"); &#125;); //后相邻选择器 (Next Adjacent Select) : 用于选择与指定元素相邻的后一个元素. $(document).ready(function() &#123; $(\"div.style03+div\").css(\"border\", \"1px solid brown\"); &#125;); //后兄弟选择器 (Next Siblings Selector) : 可用于选择指定元素后面跟随的所有符合条件的兄弟节点元素. $(document).ready(function() &#123; $(\"div.style04~div\").css(\"border\", \"1px solid burlywood\"); &#125;); //CSS 选择器 (CSS Selector) : 用于改变指定HTML元素的CSS属性. $(document).ready(function() &#123; $(\"#test03 span\").css(\"color\", \"fuchsia\"); &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; h4 &#123; margin: 0; text-align: center; font-family: \"lucida console\"; &#125; div, p &#123; width: auto; height: 100px; float: left; padding: 10px; margin: 10px; font-family: \"lucida console\"; border: 1px solid greenyellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;jQuery 选择器总结案例&lt;/h4&gt; &lt;hr /&gt; &lt;div id=\"test01\"&gt; 这是一个'div'标签.. &lt;/div&gt; &lt;div id=\"test02\"&gt; 这是一个'div'标签.. &lt;/div&gt; &lt;div id=\"test03\"&gt; &lt;span&gt;这是一个'div'标签..&lt;/span&gt; &lt;/div&gt; &lt;div class=\"style01\"&gt;这是一个'div'标签..&lt;/div&gt; &lt;p&gt; 这是一个'p'标签.. &lt;/p&gt; &lt;div class=\"style02\"&gt;这是一个'div'标签..&lt;/div&gt; &lt;div&gt; &lt;a href=\"http://www.sina.com.cn\"&gt;新浪&lt;/a&gt; &lt;a href=\"http://163.com\"&gt;网易&lt;/a&gt; &lt;a href=\"http://www.sohu.com\"&gt;搜狐&lt;/a&gt; &lt;/div&gt; &lt;div class=\"style03\"&gt; &lt;ul class=\"ul-1\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;ul&gt; &lt;li&gt;2.1&lt;/li&gt; &lt;ul class=\"ul-2\"&gt; &lt;li&gt;2.1.1&lt;/li&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"style04\"&gt; 这是&lt;span&gt;一个&lt;strong&gt;'div'&lt;/strong&gt;标签&lt;/span&gt;.. &lt;/div&gt; &lt;div&gt; &lt;form method=\"post\" action=\"URL\"&gt; &lt;label&gt;user name &lt;input type=\"text\" name=\"username\" required /&gt; &lt;/label&gt;&lt;br /&gt; &lt;label&gt;passoword &lt;input type=\"password\" name=\"password\" required /&gt; &lt;/label&gt;&lt;br /&gt; &lt;/form&gt;&lt;br&gt; &lt;button type=\"submit\"&gt;confirm&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行效果 ( 是不是以为我会做的花里胡哨的呢,嘿嘿这里只是为了学习所以就简单点吧,后期深入学习后有时间会写一些特炫的网页给大家的 ~ )","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Simple Factory Pattern","slug":"Simple-Factory-Pattern","date":"2019-04-03T04:29:16.000Z","updated":"2019-08-25T06:31:01.032Z","comments":true,"path":"2019/04/03/Simple-Factory-Pattern/","link":"","permalink":"http://yoursite.com/2019/04/03/Simple-Factory-Pattern/","excerpt":"","text":"简单工厂模式结构与实现简单工厂模式结构 Factory(工厂角色) : 工厂角色既工厂类,它是简单工厂模式的核心,负责实现创建所有产品实例的内部逻辑.工厂类还可以被外界直接调用,创建所需的产品对象.在工厂类中提供了静态的工厂方法factoryMethod(),它的返回类型为抽象产品类型Product. Product(抽象产品角色) : 它是工厂类创建的所有对象的父类,封装了各种产品对象的公有方法,它的引入将提高系统的灵活性,使得在工厂类中只需定义一个通用的工厂方法,因为所有创建的具体产品对象都是其子类对象. ConcreteProduct(具体产品角色) : 它是简单的工厂模式的创建目标,所有被创建的对象都充当这个角色的某个具体类的实例,每一个具体产品角色都继承了抽象产品的角色.需要实现在抽象产品中声明的抽象方法. 实例说明123某软件公司要基于Java语言开发一套图表库,该图表库可以为应用程序提供多种不同外观的图表,例如柱状图(HistogramChart),饼状图(PieChart)折线图(LineChart)等..该软件公司图表库设计人员希望为应用系统人员提供一套灵活易用的图标库,通过设置不同的参数即可得到不同类型的图表.而且可以较为方便的对图表库进行扩展,以便能够在将来增加一些新类型的图表. 下述用简单工厂模式来设计该图表库 (1)Chart : 抽象图表接口,充当抽象产品类. 1234public interface Chart &#123; public void display();&#125; (2)HistogramChart : 柱状图类,充当具体产品类. 1234567891011public class HistogramChart implements Chart &#123; public HistogramChart() &#123; System.out.println(\"Create the histogram chart .\"); &#125; public void display() &#123; System.out.println(\"Display the histogram chart .\"); &#125;&#125; (3)PieChart : 饼状体类,充当具体产品类. 1234567891011public class PieChart implements Chart &#123; public PieChart() &#123; System.out.println(\"Create the pie chart .\"); &#125; public void display() &#123; System.out.println(\"Display the pie chart .\"); &#125;&#125; (4)LineChart : 折线图类,充当具体产品类. 1234567891011public class LineChart implements Chart &#123; public LineChart() &#123; System.out.println(\"Create the line chart .\"); &#125; public void display() &#123; System.out.println(\"Display the line chart .\"); &#125;&#125; (5)ChartFactory : 图表工厂类,充当工厂类. 1234567891011121314151617181920public class ChartFactory &#123; public static Chart getChart(String chartType) &#123; Chart chart = null; if (chartType.equalsIgnoreCase(\"histogram\")) &#123; chart = new HistogramChart(); System.out.println(\"Initialize the histogram chart .\"); &#125; else if (chartType.equalsIgnoreCase(\"pie\")) &#123; chart = new PieChart(); System.out.println(\"Initialize the pie chart .\"); &#125; else if (chartType.equalsIgnoreCase(\"line\")) &#123; chart = new LineChart(); System.out.println(\"Initialize the line chart .\"); &#125; else &#123; System.err.println(\"error : Please chakout your object name. \"); &#125; return chart; &#125;&#125; (6)SimpleFactoryPatternTest : 客户端测试类 12345678910111213141516171819202122232425262728public class SimpleFactoryPatternTest &#123; public static void main(String[] args) &#123; Chart chart = ChartFactory.getChart(\"histogram\"); chart.display(); Chart chart2 = ChartFactory.getChart(\"pie\"); chart2.display(); Chart chart3 = ChartFactory.getChart(\"line\"); chart3.display(); /*##The result be shown as followed:## Create the histogram chart . Initialize the histogram chart . Display the histogram chart . Create the pie chart . Initialize the pie chart . Display the pie chart . Create the line chart . Initialize the line chart . Display the line chart . */ &#125;&#125; 不难发现,上述示例中在创建具体Chart对象时必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象.客户端代码需要重新编译,这对于客户端而言违反了开闭原则.下面介绍一种常用的解决方案,可以实现在不修改客户端代码的前提下能让客户端能够更换具体产品对象. 首先可以将静态的工厂方法的参数存储在XML格式的配置文件中(config.xml).如下所示 : 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;config&gt; &lt;chartType&gt;histograma&lt;/chartType&gt;&lt;/config&gt; 再通过一个工具类XML Util来读取配置文件中的字符串参数,XMLUtil类的代码如下 : 1234567891011121314151617181920212223242526272829303132333435public class XMLUtil &#123; private final static String path = \"src\\\\objctConfig.xml\"; // 该方法用于从XML配置文件中提取图表类型,并返回类型名. public static String getChartType() &#123; // 创建文档对象. DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); try &#123; DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); Document document; document = documentBuilder.parse(new File(path)); // 获取包含图标类型的文本节点. NodeList nodeList = document.getElementsByTagName(\"chartType\"); Node node = nodeList.item(0).getFirstChild(); String chartType = node.getNodeValue().trim(); return chartType; &#125; catch (ParserConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SAXException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125;&#125; 在引入配置文件和工具类XMLUtil之后,客户端代码SimpleFactoryPatternTest.java修改如下 : 1234567891011121314151617181920public class SimpleFactoryPatternTest &#123; public static void main(String[] args) &#123; /* * 通过读取配置文件中的参数来初始化指定的对象. */ String chartType = XMLUtil.getChartType(); Chart chart = ChartFactory.getChart(chartType); chart.display(); /*##The result be shown as followed:## Create the histogram chart . Initialize the histogram chart . Display the histogram chart . */ &#125;&#125; 不难发现,在上述客户端代码中并不包含任何与具体图标对象相关的信息,如果需要更换具体图标对象,只需要修改配置文件config.xml,无须修改任何原代码,既而符合开闭原则 开闭原则 : 是面向对象的可复用设计的第一块基石,它是最重要的面向对象设计原则.开闭原则由Bertrand Meyer于1998年提出,其定义如下 : 12345开闭原则 : 软件实体应当对扩展开放,对修改关闭.Open-Closed Principle(OCP) : Software entities should be open for extension,but closed for modification.在开闭原则的定义中,软件实体可以指一个软件模块,一个由多个类组成的局部结构或一个独立的类,开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展. 简单工厂模式优/缺点与适用环境简单工厂模式的优点 工厂类包含必要的判断逻辑,可以决定在什么时候创建哪一个产品类的实例,客户端可以避免直接创建产品对象的职责.而仅仅’消费’产品,简单工厂模式实现了对象创建和使用的分离. 客户端无须知道所创建的具体产品的类名.只需要知道具体产品类所对应的参数即可,对于一些复杂的类名,通过简单工厂模式可以在一定程度上减少使用者的记忆量. 通过引入配置文件,可以在不修改任何客户端代码的情况下更换和增加新的具体产品类,在一定程序上提高了系统的灵活性. 简单工厂模式的缺点 由于工厂类集中了所有产品的创建逻辑,职责过重,一旦不能正常工作,整个系统都要受到影响. 使用简单工厂模式势必会增加系统中类的个数(引入了新的工厂类),增加了系统的复杂度和理解难度. 系统扩展困难,一旦添加新产品就不得不修改工厂逻辑,在新产品类型较多时有可能造成工厂逻辑过于复杂,不利于系统的扩展和维护. 简单工厂模式由于使用了静态工厂方法,造成工厂角色无法形成基于继承的等级结构. 简单工厂模式的适用环境 工厂类负责创建的对象比较少,由于创建的对象比较少,不会造成工厂方法中的业务逻辑过于复杂. 客户端只知道传入工厂类的参数,对于如何创建对象并不关心. 参考书籍《 Java设计模式 》 作者: 刘伟 (可以说本书的代码示例写的非常用心,很适合初学者参考)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://yoursite.com/tags/Design-Pattern/"}]},{"title":"Spring 依赖注入","slug":"Spring-依赖注入","date":"2019-04-02T13:12:43.000Z","updated":"2019-08-25T06:31:01.058Z","comments":true,"path":"2019/04/02/Spring-依赖注入/","link":"","permalink":"http://yoursite.com/2019/04/02/Spring-依赖注入/","excerpt":"","text":"Spring framework 依赖注入篇如果想区分依赖注入与控制反转(IOC)两者之间的不同,可以参考Martin Fowler给出的解释.查看文章: GO 简单来说,依赖注入的情况如下 : 12345678public class A &#123; public void importantMethod() &#123; B b = ... // get an instance of B b.usefulMethod(); ... &#125; ...&#125; 如果要使用B,类A必须先获得组件B的实例引用,若B是一个具体类,则可以通过new关键字直接创建组件B实例.但是,如果B是接口,且有多个实现,则问题就变得复杂了,我们固然可以任意选择接口B的一个实现类,但这也意味着A的可重用性大大降低了,因为无法采用B的其他实现.* 依赖注入是这样处理此类情景的 : 接管对象的创建工作,并将该对象的引用注入需要该对象的组件.以上述例子为例,依赖注入框架会分别创建对象A和对象B,将对象B注入到对象A中.为了能让框架进行依赖注入,程序员需要编写特定的set方法或构建方法,例如: 为了能将B注入到A中,类A会被修改成如下形式 : 123456789101112public class A &#123; private B b; public void importantMethod() &#123; // no need to worry about creating B anymore. // B b = ... // get an instance of B. b.usefulMethod(); ... &#125; public void setB(B b) &#123; this.b = b; &#125;&#125; 修改后的类A新增了一个setter方法,该方法将会被框架调用,以注入一个B的实例.由于对象依赖由依赖注入,类A的importantMethod()方法不再需要在调用B的usefulMethod()方法前去创建一个B的实例. 当然,也可以采用构造器方式注入,如下所示 : (本例中,Spring会先创建B的实例,再创建实例A,然后把B注入到实例A中.) 12345678910111213public class A &#123; private B b; public A(B b)&#123; this.b = b; &#125; public void importantMethod() &#123; // no need to worry about creating B anymore. // B b = ... // get an instance of B. b.usefulMethod(); ... &#125;&#125; 注意 : Spring 管理的对象称为beans . 1234567通过提供一个控制反转器(或者依赖注入器IOC),`Spring`为我们提供一种可以&apos;聪明&apos;地管理Java对象的依赖关系的方法.其优雅之处在于 : 程序员无须了解`Spring`框架的存在,更不需要引入任何`Spring`类型.使用`Spring`,程序几乎将所有重要对象的创建工作移交给了`Spring`,并配置如何注入依赖.`Spring`支持`XML`和`注解`两种配置方式.此外还需要创建是一个`ApplicationContext`对象,其代表一个`Spring`控制反转容器,`org.springframework.context.ApplicationContext`接口有多个实现,包括`ClassPathXmlApplicationContext`和`FileSystemXmlApplicationContext`.这两个实现都需要至少一个包含`beans`信息的`XML`文件. ClassPathXmlApplicationContext : 在类加载路径中加载配置文件. FileSystemXmlApplicationContext : 在文件系统路径中加载文件. 下面为从类路径中加载applicationContext1.xml和applicationContext2.xml的ApplicationContext创建的一个代码示例 :123456ApplicationContext context = new ClassPathXmlApplicationContext( new String[]&#123;\"applicationContext1.xml\",\"applicationContext2.xml\"&#125;)//可以通过调用`ApplicationContext`的`getBean`方法获得对象//getBean方法会查询`id`为`product`且类型为`Product`的`bean`对象.Product product = context.getBean(\"product\",Product.class); 注 : 理想情况下,我们仅需在测试代码中创建一个ApplicationContext,应用程序本身无需处理,对于Spring MVC应用,可以通过一个Spring Servlet来处理ApplicationContext,既而无须直接处理. 摘抄书籍 : 《 Servlet,JSP and Spring MVC - beginner 》 -&gt; author: [加] Budi Kurniawan [美] Paul Deck","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"全国计算机等级考试-三级数据库技术","slug":"全国计算机等级考试-三级数据库技术","date":"2019-03-31T02:46:51.000Z","updated":"2019-08-25T06:31:01.148Z","comments":true,"path":"2019/03/31/全国计算机等级考试-三级数据库技术/","link":"","permalink":"http://yoursite.com/2019/03/31/全国计算机等级考试-三级数据库技术/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 三级数据库技术篇来来来,先欣赏一下昨天去看樱花时拍的风景,语文学的不好的我只能用超级美来形容啦啊哈哈哈 (づ｡◕ᴗᴗ◕｡)づ 哎呦 ~ 要是俺和自己喜欢女孩纸走在这条路上哥哥心里一定美的够够的（づ￣3￣）づ╭❤～ 敲黑板：三级数据库技术题目也不难,较二级概念题多一些 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧开门见山,先感受一下哥哥带来的学习笔记,详细到感动自己的那种..ヾ(❀^ω^)ﾉﾞ填空题总结 笔记共记录了17张卷子所有选择题的解析及易错点,毕竟有30分呢嘿嘿.. (づ｡◕ᴗᴗ◕｡)づ 应用题总结 笔记共记录了9张卷子所有应用题的解析及易错点,同样占据30分哟 (づ｡◕ᴗᴗ◕｡)づ 笔记的下载链接 : , Good luck to you ~","categories":[],"tags":[{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://yoursite.com/tags/SQL-Server/"}]},{"title":"全国计算机等级考试-二级MySQL","slug":"全国计算机等级考试-二级MySQL","date":"2019-03-31T02:10:44.000Z","updated":"2019-08-25T06:31:01.159Z","comments":true,"path":"2019/03/31/全国计算机等级考试-二级MySQL/","link":"","permalink":"http://yoursite.com/2019/03/31/全国计算机等级考试-二级MySQL/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 二级MySQL篇敲黑板：二级考试的试题都是在往年的试卷中随机抽取的 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧ 嘿嘿,没想到你点进来啦,其实我大一报考MySQL二级时并没有记笔记,这就尴尬啦..既然你点击近来啦,那就推荐一波学习资源吧 (っ•̀ω•́)っ✎⁾⁾ 我在备考时使用的都是未来教育提供的考试模拟系统,如下图示例( 没有打广告哟,是真的挺不错的！ ) 很多同学使用的基本都是未来教育的考试模拟系统,可以说和真实考试的系统几乎相似,虽然说2019/3月份的全国计算机等考的考试系统更新了..但题目的基本模块还是没有变化的,如果大家想考二级/三级/四级,真的非常建议使用未来教育的考试模拟系统！至于说能否考过那就要看你自己认真度啦嘿嘿 ~ 未来教育的官方网站 : , GO ~","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"}]},{"title":"全国计算机等级考试-二级C语言","slug":"全国计算机等级考试-二级C语言","date":"2019-03-31T01:45:04.000Z","updated":"2019-08-25T06:31:01.156Z","comments":true,"path":"2019/03/31/全国计算机等级考试-二级C语言/","link":"","permalink":"http://yoursite.com/2019/03/31/全国计算机等级考试-二级C语言/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 二级C篇来来来,先欣赏一下昨天去看樱花时拍的风景,语文学的不好的我只能用超级美来形容啦啊哈哈哈 (づ｡◕ᴗᴗ◕｡)づ 敲黑板：二级考试的试题都是在往年的试卷中随机抽取的 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧ OK ! 说直白一点,二级考试真是的傻白甜,毕竟考试范围都已经给你了,况且还有可能遇到原题呢...但是！但是！但是！过程很重要,相信这一切都是你走向春天的必经之路,大家千万不因傲慢而忽略了路边的风景 ！ 下面是我考试前的一些练习题,阔以说将题目要求,运行结果,注意事项,易错点写的的非常的详细啦！( 嘿嘿,大家阔以省下买试卷的钱咯 (づ｡◕ᴗᴗ◕｡)づ ) 试卷及笔记的下载链接 : , Good luck to you ~ 建议多多刷题哟,尽情体验C语言中指针与数据结构及算法的美吧 (っ•̀ω•́)っ✎⁾⁾","categories":[],"tags":[{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"static keyword","slug":"static-keyword","date":"2019-03-16T14:03:17.000Z","updated":"2019-08-25T06:31:01.114Z","comments":true,"path":"2019/03/16/static-keyword/","link":"","permalink":"http://yoursite.com/2019/03/16/static-keyword/","excerpt":"","text":"今天刷C语言程序题时遇到很多关于static关键字的题目,为区分Java中的static继而回到寝室写一篇关于Java中static关键字的使用详解.先来谈谈Java中的static123\"static方法就是没有this的方法.在static方法内部不能调用非静态方法,反过来是可以的.而且可以在没有创建任何对象的前提下,仅仅通过类本身来调用static方法.这实际上正是static方法的主要用途. ———— 《 Java编程思想 》\"总结为一句话：方便在没有创建对象的情况下来进行调用(方法/变量). static 变量123static 变量也称作静态变量.静态变量: 静态变量被所有的对象所共享,在内存中只有一个副本.它当且仅当在类初次加载时会被初始化.非静态变量: 是对象所拥有的,在创建对象的时候被初始化.存在多个副本,各个对象拥有的副本互不影响. static 方法123使用 static 修饰的方法一般称作静态方法.由于静态方法不依赖于任何对象就可以进行访问,因此对于静态方法来内说是无法使用 this 关键字的,因为它不依附于任何对象,既然都没有对象,就谈不上 this 了 ! 继而由于这个特性,在静态方法中不能访问类的非静态成员变量和非静态成员方法,因为非静态成员方法/变量都是必须依赖具体的`对象`才能够被调用. static 代码块12静态代码块以优化程序性能.static 块可以置于类中的任何地方,类中可以有多个static块.在类初次被加载的时候,会按照 static 代码块的顺序逐个执行,并且只会执行一次. 使用JDBC中简单的Data access obejct实例来讲解如何利用static关键字优化程序性能 ! (っ•̀ω•́)っ✎⁾⁾ 首先创建一个连接数据库的工具类,使用static 代码块解决重复加载驱动问题,提高性能. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @ClassName: JDBCUtil * @Description: Connect to the database. * @author: Huang Yuhui * @date: Mar 13, 2019 3:19:41 PM */public class JDBCUtil &#123; private JDBCUtil() &#123; // TODO Auto-generated constructor stub &#125; // initialize the driver of database. static &#123; try &#123; Class.forName(\"com.mysql.cj.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // Return a database connection object. public static Connection getConnection() &#123; Connection connection = null; try &#123; connection = DriverManager.getConnection(\"jdbc:mysql://localhost/databaseName?\" + \"useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\", \"username\", \"password\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; // release the resource of connecting. public static void freeResource(Connection connection,PreparedStatement preparedStatement,ResultSet resultSet) &#123; if(connection!=null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(preparedStatement!=null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(resultSet!=null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用static修饰单独抽取出来的Connection对象使其成为静态变量.继而使得整个DAO可以共享此对象. 12345678910/** * @ClassName: basicConnection * @Description: Share this object of Connection. * @author: Huang Yuhui * @date: Mar 13, 2019 3:15:43 PM */public class basicConnection &#123; public static Connection connection = JDBCUtil.getConnection();&#125; 小哥就简写一下DAO层类,便于举例: 增加数据表信息的类 + 删除数据表信息的类 + ······ 12345678910111213141516/** * @ClassName: basicConnectionTest * @Description: Insert the specified data into the database. * @author: Huang Yuhui * @date: Mar 16, 2019 10:40:11 PM */public class InsertTest &#123; Connection connection = basicConnection.connection; @Test public void insertInfoTest() &#123; System.out.println(\"insertInfoTest : \" + connection); &#125;&#125; 12345678910111213141516/** * @ClassName: DeleteTest * @Description: Delete the specified data from the database. * @author: Huang Yuhui * @date: Mar 16, 2019 11:05:44 PM */public class DeleteTest &#123; Connection connection2 = basicConnection.connection; @Test public void deleteInfoTest() &#123; System.out.println(\"deleteInfoTest : \" + connection2); &#125;&#125; 利用JUnit测试套件测试Data acess object中所有的测试类. 123456789101112/** * @ClassName: AllTest * @Description: Test all class. * @author: Huang Yuhui * @date: Mar 16, 2019 11:04:58 PM * */@RunWith(Suite.class)@SuiteClasses(&#123; InsertTest.class, DeleteTest.class &#125;)public class AllTest &#123;&#125; 输出结果如下所示.由于Connection对象被抽取且被static修饰为了静态对象.继而在整个DAO中可以共享这个连接数据库的对象.而不必每一个类中都实例化一次连接数据库的对象(Connection)继而提升程序的性能（づ￣3￣）づ╭❤～ 12insertInfoTest : com.mysql.cj.jdbc.ConnectionImpl@158a8276deleteInfoTest : com.mysql.cj.jdbc.ConnectionImpl@158a8276 哎哟,不知觉又半夜啦! 晚安,好梦. remember love yourself deeply.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JUnit","slug":"JUnit","permalink":"http://yoursite.com/tags/JUnit/"}]},{"title":"全国计算机等级考试-Java","slug":"全国计算机等级考试-Java","date":"2019-03-15T03:10:42.000Z","updated":"2019-08-25T06:31:01.135Z","comments":true,"path":"2019/03/15/全国计算机等级考试-Java/","link":"","permalink":"http://yoursite.com/2019/03/15/全国计算机等级考试-Java/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 二级Java篇 敲黑板：二级考试的试题都是在往年的试卷中随机抽取的 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧ 选择题总结(重点+易错点) try与catch的匹配是: catch到的异常是try中可能抛出的异常或其子类的实例. 按照标准的I/O模型,Java提供了三种标准流,分别为：System.in , System.out , System.err. 属于过滤字节输出流的类是：BufferedOutputSteam. 当窗口被激活时，调用的窗口事件的方法是：public void windowActivated(WindowEvent) 对类进行并发控制，需要私有属性进行定义变量(private),用锁将方法锁起来synchronized,这样就不会出现并发出现异常情况. Swing组件的外观与具体平台无关. 在Java中的开发包1.7之前，switch不支持String类型数据,case值和key值匹配时,程序会报错 ! 在一个类中可以定义为多个名称相同,但参数不同的方法,这种机制叫做：重载. 匿名内部类也就是没有名字的内部类,正因为没有名字,所以匿名内部类只能使用一次!它通常用来简化代码编写,但使用匿名内部类还有一个前提条 件：必须继承一个父类或实现一个接口 ! 类变量必须带有的修饰符为：static 在Java中二维数组定义的语法为：数据类型[][]数组名=new 数据类型[行数][列数]; 在Java.io包的字节输入流中,过滤器输入流的基类是: FilterInputStream 所有字符输入流都从Reader类继承,所有字符输出流都从Writer类继承. Swing除继续沿用了AWT中的FlowLayout,BorderLayout,CardLayout,GridLayout,GridBagLayout布局管理器外,新增了一个BoxLayout布局管理 器.BoxLayout布局管理器按照自上而下(y轴)或者从左到右(x轴)的顺序布局依次加入构件. java.awt.event包中定义了适配器类；该包中定义的适配器类包括以下几个: ComponentAdapter 构件适配器 ContainerAdapter 容器适配器 FocusAdapter 焦点适配器 MouseAdapter 鼠标适配器 KeyAdapter 键盘适配器 MouseMotionAdapter 鼠标运动适配器 WindowAdapters 窗口适配器 而FrameAdapter 不属于事件适配器类 !* 如果发生下面几种情况时,处于运行状态的线程就进入阻塞状态 : 线程调用sleep(); / join(); / wait();方法. 如果线程中使用sychronized来请求对象的所未获得时. 如果线程中有输入/输出操作,则进入阻塞状态;待输入/输出操作结束后,线程进入可运行状态. 在Java中,使用synchronized关键字标识临界区.Java平台将每个由synchronized语句设置的对象设置一个锁,称为对象锁,它是一种独占的排 他锁,既同一时刻最多只能有一个线程获取该锁,为了能够正常地使用对象锁，对共享数据的所有访问都必须在临界区内.同时临界区的共享数据必须是私 有的,确保只能通过对象的方法才能访问到. 算法的空间复杂度是指算法在执行过程中所需的内存空间.算法执行期间所需的存储空间包括3个部分: 输入数据的存储空间 程序本身所占的存储空间 算法执行过程中所需要的额外空间 需求分析是对待开发软件提出的需求进行分析并给出详细设计,是解决软件做什么的阶段. 软件设计可以使用的工具有总体结构图,程序流程图,N-S图,PAD图..注意：数据流程图(DFD)是需求分析使用的工具 ! 逻辑设计阶段形成逻辑数据模型(从E-R图向关系模式转换).注意点：关系模式设计属于：逻辑设计 能够运行Java字节码的命令为: javac break在java起到跳出循环的作用.continue是跳过当次循环继续执行下一次循环. XML只是一个配置文件通过流将XML件读取出来，并不属于字节流 ! yield()该方法与sleep()类似,只是不能由用户指定暂停多长时间,并且yield()方法只能让同优级的线程有执行的机会 ! javap的作用: Javap是 Java class文件分解器,可以反编译,也可以查看java编译器生成的字节码. 在数据库设计中,在需求分析阶段建立数据字典. 注意: 在 / 运算中并不存四舍五入的操作!只取整数部分! 正则表达式是一种描述某种匹配检索规则的字符串. java.util.regex 包中有一个Pattern类,用于进行快速模拟匹配. java.util.regex 包还具有一个Matcher匹配器类. javax.swing.text是文本类包,javax.swing.table是表格类包,javax.swing.plaf包括一些对外观样式操作的类和接口. JFrame是页面容器,JToolBar为工具条(属于容器的一种). Java中的线程包含CPU,代码,数据三个部分 interrupt();中断线程:中断状态被清除. start();用于开启一个线程. notify();用于唤醒一个处于等待状态的线程. 当一个Applet所在的浏览器被最小化以后,不能被调用的Applet方法是init() init(); 当浏览器加载applet,进行初始化的时候调用该方法. start(); 该方法在init()方法之后调用,当用户从其它页面转到包含applet的页面时该方法也被调用. stop(); 在用户离开包含applet的页面时被调用. destroy(); 当applet不再被使用,或浏览器退出的时候,该方法被调用. 操作题总结(重点+API介绍) 数组的算法排序继承于 Comparable JApplet(init()方法中接收来自html页面上的参数). 通过setName(String str);为继承Thread的子类的线程初始化名字. equals();方法比较的是两个字符串的内容是否相等.而 == 符号比较的是: 两个字符串的地址是否相同. 当程序中涉及鼠标点击事件需要继承MouseAdapter类来对鼠标做出的动作进行相应的回应 ! paint(Graphics g),调用 g.drawOval();可以画同心圆. Applet中绘制指定文本字符串使用：drawString(); Java中String类提供了charAt();方法遍历每个字符. 常用布局管理器 FlowLayout,BorderLayout,GridLayout,CardLayout,GridBagLayout. 注意: JLabel对象可以显示文本,图像或同时显示两者,创建对象时,在构造函数中输入要显示的对象即可. getContentPane();方法获得JFrame的内容面板. getSource(); 找到给定名称的资源. frame.pack();-Method in class java.awt. Window. 使此窗口的大小适合其子组件的首选大小和布局. JPanel是Java图形用户界面(GUI)工具包swing中的面板容器类,包含于javax.swing包,是一种轻量级容器,可以加入到JFrame窗体中,所以我们 需要继承此类作为画板供JFrame类来操作 通过鼠标点击获取相应的请求命令方法为: e.getActionCommand(); beep() - Method in class java.awt. Toolkit. 根据本地系统设置和硬件功能发出音频蜂鸣声. for example: Toolkit.getDefaultToolkit().beep(); drawRect(int, int, int, int) - Method in class java.awt.Graphics 绘制指定矩形的轮廓. DataOutputStream 数据输出流允许应用程序以机器无关方式将Java基本数据类型写到底层输出流, DataInputStream 类提供readChar();方法来读取文件中的字符. Java IO 123 System.getProperty(\"user.dir\"); 获取当前的工作路径.getName(); 方法获取文件名，getPath();获取文件路径.isDirectory(); 判断是否是文件. extends Thread 与 implements Runnable 使用 123456789101112 当通过`implements Runnable`创建线程:将实现了Runnable接口的对象作为`target`参数传递给Thread类即可,格式如下:new Thread(`实现了Runnable接口的对象名`);举例: public class Java_2 implements Runnable &#123; public static void main(String[]args) &#123; Java_2 r = new Java_2(); Thread t = new Thread( r ); t.start(); &#125;··· 通过`extends Thread`创建线程:Thread本身实现了`Runnable`接口,重写其`run()`方法即可;线程创建后,需要调用`start();`方法运行. 12345setPreferredSize(new Dimension(280, 60));public void setPreferredSize(Dimension preferredSize)&#123;...&#125;将此组件的首选大小设置为常量值. 随后`getPreferredSize()`总是返回此值.将首选大小设置为`null`可恢复默认行为. `Dimension` : 类封装单个对象中组件的宽度和高度(以整数精度). DecimalFormat类提供的format();方法可以将数据格式化. 123public class DecimalFormat extends NumberFormatDecimalFormat()&#123;...&#125;`DecimalFormat`是格式为十进制数的NumberFormat的具体子类. 它具有各种功能,旨在使任何地区的数字解析和格式化,包括支持西方,阿拉伯语和印度数字。它还支持不同类型的数字,包括整数(123..),定点数(123.4),科学记数法(1.23E4),百分比(12％),和货币金额(123美元),所有这些都可以进行本地化. 窗体事件 1234setDefaultCloseOperation(); 设置用户在此窗口上发起\"close\"时默认执行操作.JFrame.EXIT_ON_CLOSE; `close`式关闭程序退出窗口.for example: frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 常用事件类 12345public void addActionListener(ActionListener e)&#123;..&#125;添加指定的动作侦听器以从此按钮接收动作事件.当用户按下或释放鼠标在此按钮上时,会发生动作事件.如果`e`为空,则不会抛出任何异常.也不会执行任何操作.for example: saveButton.addActionListener(this); 哎哟终于写好了 ! 伸个懒腰 ٩(๑❛ᴗ❛๑)۶ ~ 最近没零花钱买麦斯威尔了,然后每天的状态就像下面的俺的小黄人一样 ╰( ´・ω・)つ──☆✿✿✿ 后期有时间还写推出NCRE-MySQL,NCRE-C,NCRE-三级数据库等全国计算机等考题目解析 ! 最近忙于备考,所以先写作先放一放 ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"}]},{"title":"JDBC 常见错误分析","slug":"JDBC-常见错误分析","date":"2019-03-14T11:32:12.000Z","updated":"2019-08-25T06:31:00.980Z","comments":true,"path":"2019/03/14/JDBC-常见错误分析/","link":"","permalink":"http://yoursite.com/2019/03/14/JDBC-常见错误分析/","excerpt":"","text":"JDBC ( Java Database Connectivity ) 常见错误分析今遇到一个网友问到JDBC中一个常见的错误,让我想起了大一时自己学习JDBC时整理的文档,继而公布出来分享给大家. 根据不同问题给出相应的解析问题一 : 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);错误 程序报错信息123456Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. ()...[译文如下]加载类 'com.mysql.jdbc.Driver' 这是不赞成的.新的驱动程序类是 'com.mysql.cj.jdbc.Driver' 驱动程序.驱动程序是通过SPI自动注册的，并且手动加载驱动类通常是不必要的... 解析123新版的驱动类位置有了变化(不影响使用，但会报警告) 旧版连接(MySQL Connection/J 5.x) ——&gt; jdbc.url = com.mysql.jdbc.Driver 新版连接(MySQL Connection/J 6.x) ——&gt; jdbc.url= com.mysql.cj.jdbc.Driver 解决方案1将 \"com.mysql.jdbc.Driver\" 改成 \"com.mysql.cj.jdbc.Driver\" . 问题二 ：连接错误 程序报错信息1234SunAug 19 17:39:12 CST 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServer Certificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.[译文如下]SunAug 19 17:39∶12 CST 2018警告：不建议建立没有服务器身份验证的SSL连接.根据MySQL 5.5.45 +、5.626+和5.7.6+的要求,如果没有设置显式选项，默认情况下必须建立SSL连接.对于不使用SSL的现有应用程序,'ValuyServer'证书属性设置为'false'.您需要通过设置'USESL=false'来显式禁用'SSL',或者设置'useSSL=true',并为服务器证书验证提供信任存储. 解析以及解决方案123由报错信息可得知,MySQL版本更新后的新特性: 如果连接数据库必须通过服务器的身份验证,当然上述已给出解决方案的建议. 方案一 ： 在url后加：useSSL=false; (简单易操作) 方案二 ： 在url后加：useSSL=true; (并未服务器证书验证提供信任存储) 问题三 ：时区错误 程序报错信息1234Exception in thread \"main\" java.sql.SQLException: The server time zone value '???ú±ê×??±??' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.[译文如下]java.sql.SQLException ：服务器时区值 '？？±××？±？' 是不被识别的,或者表示一个以上的时区.如果要利用时区支持,必须配置服务器或JDBC驱动程序(通过 serverTimezone 配置属性)使用更具体的时区值. 解析及解决方案1为URL添加参数 serverTimezone=UTC 即可,这里的时区可以根据自己数据库的设定来设置（GMT/UTC ）. 问题四 ：当上述问题全部已经解决后可以正常连接数据库,但是如果重启MySQL服务器后重新连接数据库时发现报错！ 程序报错信息1java.sql.SQLNonTransientConnectionException: Public Key Retrieval is not allowed. 解决方案1在URL连接后添加 ： allowPublicKeyRetrieval = true 哎哟不知觉又在图书馆又待了一天..都不知已将近九点了,收拾下回寝室啦 ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"Ubuntu18.04-Mac theme","slug":"Ubuntu18-04-Mac-theme","date":"2019-03-12T13:55:26.000Z","updated":"2019-08-25T06:31:01.063Z","comments":true,"path":"2019/03/12/Ubuntu18-04-Mac-theme/","link":"","permalink":"http://yoursite.com/2019/03/12/Ubuntu18-04-Mac-theme/","excerpt":"","text":"Ubuntu18.04 桌面美化( Mac theme )小哥哥我特意写了一些注意事项,可以提高效率,避免浪费时间哟 ~ 注意 ：千万不要认为在官网下载的包都是一个作用，继而导致后期不按规则存放解压后的包而发生 Tweak 无法识别装饰包的尴尬 !!! 在Ubuntu18.04 中美化桌面分为三个美化部分(装饰包也分为以下三种) 主题美化(Themes) (/usr/share/themes) shell主题美化(shell) (/usr/share/themes) 图标美化(icon) (/usr/share/icon) Ubuntu18.04发布以后不难发现其桌面发生了改版！Unity——&gt;Gnome,其实吧 : Gnomez桌面可自定制,美化后也非常酷 ~ 还有一个特别需要注意的问题：当执行以下命令安装中文名为 ‘优化’ 的软件后，你会发现在Extensions(扩展)选项中没有User themes ?!1sudo apt install gnome-tweak-tool 解决方案是你需要安装: Gnome-shell Extensions谈到这里俺要感谢一个篇写的超认真的CSDN博客,如果不想看官方文档/教程的话,她的这篇关于Ubuntu18.04美化桌面的博客是非常值得参考的,而且作者头像超美的哟(✪ω✪) ! GO ~ (建议)如果想要深入了解,最好去相应官方网站去看文档说明/指导,毕竟这才是原版,原汁原味 (っ•̀ω•́)っ✎⁾⁾ ~例如讲解 : HOW TO CUSTOMIZE GNOME 3 DESKTOP ENVIRONMENT ON UBUNTU 17.10 . GO ~ 关于如何使用 Gnome Shell 扩展，在此再给出一值得个参考学习的文章(作者写的超认真! 向这位学者致敬 ~). GO ~ 好啦 ~ 来 ! 感受一下我特爱的Ubuntu美化后的截图 ! 特美吧嘿嘿嘿 ~(◍´꒳`◍)~ 小伙伴们自定义Ubuntu桌面后是不是很开心呢 ! 请小哥哥我喝杯咖啡呗嘿嘿嘿 （づ￣3￣）づ╭❤～ 摘自我的CSDN博客,这篇博客是：2018/10/03 写的. CSDN主页 : https://blog.csdn.net/qq_43313515","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"Data structures and algorithm analysis in C","slug":"Data-structures-and-algorithm-analysis-in-C","date":"2019-03-12T11:04:44.000Z","updated":"2019-08-25T06:31:00.958Z","comments":true,"path":"2019/03/12/Data-structures-and-algorithm-analysis-in-C/","link":"","permalink":"http://yoursite.com/2019/03/12/Data-structures-and-algorithm-analysis-in-C/","excerpt":"","text":"数据结构与算法分析 - C语言描述著名计算机科学家沃思(Niklaus Wirth)曾提出一个程序公式：程序 = 数据结构 + 算法. 由此体现程序最美的灵魂所在 ~ 12345来! 小哥哥带大家体现一下`灵魂`的美 -(っ•̀ω•́)っ✎⁾⁾-约瑟夫问题(`Josephus problem `)是循环链表的一个典型应用,其描述如下: M个人围成一个圈,从其中任意一个人开始,按顺时针使所有人从一开始报数,报到N的人出列,然后使N之后的人接着从1开始报数,再次使报到N的人出列···如此下去,求出列的顺序及最后留下来的人的编号.很有趣的题目对吧! 小哥哥在这里简单实现一下哟 ~ Declare.h 12345678910111213141516171819202122232425262728293031323334353637#ifndef _Josephus_problem_#define _Josephus_problem_ /*Simplify the code*/typedef struct Head *pHead;typedef struct Node *pNode; /*Define the header node*/struct Head&#123; int length; pNode next;&#125;;/*Define data nodes*/struct Node&#123; int data; pNode next;&#125;; /*DECLARE THE FUNCTION*//*CATCH THE EXCETPION*/void HeadIsNullException(pHead ph);/*CATCH THE EXCEPTION OF INPUT*/void InputIsUnresonable(int input);/*CREATE A CRICULAR LIST*/pHead Create();/*DETERMINE WHETHER THE LINK IS EMPTY*/int IsEmpty(pHead ph);/*INSET THE NODE INTO LINKE IN SPECIFIED POSITION*/int Insert(pHead ph, int position, int value);/*PRINT THE DATA OF NODE OF ALL*/void print(pHead ph);/*THE HEART OF ALGORITHM*/void The_Heart_Of_Algorithm_(pHead ph, int n); #endif Functions.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include \"Declare.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /*CATCH THE EXCEPTION OF CIRCULAR LINK*/void HeadIsNullException(pHead ph)&#123; if (ph == NULL) printf(\"ERROR : THE NODE HEAD IS NULL !\\n\");&#125; /*CATCH THE EXCEPTION OF INPUT*/void InputIsUnresonable(int input)&#123; if (input &lt; 0) printf(\"ERROR : THE NUMBER THAT YOU ENTERED IS UNREASONABLE !\\n\");&#125; /*CREATE A CIRCULAR LIST*/pHead Create()&#123; pHead ph = (pHead)malloc(sizeof(struct Head)); HeadIsNullException(ph); ph-&gt;length = 0; ph-&gt;next = NULL; return ph;&#125; /*DETERMINE WHETHER THE LINK IS EMPTY*/int IsEmpty(pHead ph)&#123; HeadIsNullException(ph); if (ph-&gt;length == 0) return 1; else return 0;&#125; /*INSERT THE NODE INTO LINK IN SPECIFIED POSITION*/int Insert(pHead ph, int position, int value)&#123; if (ph == NULL || position &lt; 0 || position &gt; ph-&gt;length) printf(\"ERROR : Insertion anomaly !\"); pNode p_value = (pNode)malloc(sizeof(struct Node)); p_value-&gt;data = value; //--(っ•̀ω•́)っ✎⁾⁾-- TO DETERMINE THE INSERTION POSITION. //FIRST DETERMINE WHETHER THE LIST IS EMPTY. if (IsEmpty(ph)) &#123; ph-&gt;next = p_value; p_value-&gt;next = p_value; //o(*￣︶￣*)o ~ YOU ARE NOT ALONE .. &#125; else &#123; //INSERT IN THT FIST POSITION. pNode p_node = ph-&gt;next; if (position == 0) &#123; //FIND THE LAST NODE. while (p_node-&gt;next != ph-&gt;next) p_node = p_node-&gt;next; p_value-&gt;next = ph-&gt;next; ph-&gt;next = p_value; p_node-&gt;next = p_value; &#125; else &#123; pNode p_node_ = ph-&gt;next; for (int i = 1; i &lt; position; i++) p_node_ = p_node_-&gt;next; p_value-&gt;next = p_node_-&gt;next; p_node_-&gt;next = p_value; &#125; &#125; ph-&gt;length++; return 1;&#125; /*PRINT THE DATA OF NODE OF ALL*/void print(pHead ph)&#123; if (ph == NULL || ph-&gt;length == 0) printf(\"ERROR : THE LENGTH OF LIST IS ZERO !\"); pNode pTemp = ph-&gt;next; for (int i = 0; i &lt; ph-&gt;length; i++) &#123; printf(\"%d \", pTemp-&gt;data); pTemp = pTemp-&gt;next; &#125; printf(\"\\n\");&#125; /*THE HEART OF ALGORITHM*/void The_Heart_Of_Algorithm_(pHead ph,int n)&#123; pNode node = ph-&gt;next; while (node-&gt;next != node) //KEEP THE LAST NODE. &#123; for (int i = 1; i &lt; n - 1; i++) node = node-&gt;next; pNode pTemp = node-&gt;next; //--(っ•̀ω•́)っ✎⁾⁾--DETERMINE THE LOCATION OF NODE. //First, determine if the position of this node is zero. if (pTemp == ph-&gt;next) &#123; ph-&gt;next = pTemp-&gt;next; node-&gt;next = pTemp-&gt;next; printf(\"%d \", pTemp-&gt;data); free(pTemp); ph-&gt;length--; &#125; //Second, the position of this node is others. else &#123; node-&gt;next = pTemp-&gt;next; printf(\"%d \", pTemp-&gt;data); free(pTemp); ph-&gt;length--; &#125; node = node-&gt;next; &#125; node-&gt;next = node; //YOU ARE NOT ALONE ~(*^▽^*)~ printf(\"\\n\");&#125; Main.c 1234567891011121314151617181920212223242526272829303132333435363738#include \"Declare.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char const *argv[])&#123; int m, n; /*INITIALIZED DATA*/ printf(\"Please enter the total number of peoples of Josphus problem :\\n\"); scanf(\"%d\", &amp;m); InputIsUnresonable(m); printf(\"Please enter the index of node which you want to delete :\\n\"); scanf(\"%d\", &amp;n); InputIsUnresonable(n); /*CREATE A CRICULAR LIST*/ pHead ph = NULL; //&lt;—————————— 'INITIALIZED THE CIRCULAR LINK'. ph = Create(); HeadIsNullException(ph); for (int i = m; i &gt; 0; i--) Insert(ph, 0, i); printf(\"\\n\"); printf(\"--- The data of all node inserted by you. ---\\n\"); print(ph); /*--- THE HEART OF ALGORITHM ---*/ printf(\"--- out put the order of the loop list ---\\n\"); The_Heart_Of_Algorithm_(ph, n); /*FINAL RESULT*/ printf(\"--- THE LAST OF NODE ---\\n\"); print(ph); system(\"pause\"); return 0;&#125; The result of a program running 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Please enter the total number of peoples of Josphus problem :10000Please enter the index of node which you want to delete :6 --- The data of all node inserted by you. ---1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 3723 3724 3725 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 3750 3751 3752 3753 3754 3755 3756 3757 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 3905 3906 3907 3908 3909 3910 3911 3912 3913 3914 3915 3916 3917 3918 3919 3920 3921 3922 3923 3924 3925 3926 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 3988 3989 3990 3991 3992 3993 3994 3995 3996 3997 3998 3999 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 4016 4017 4018 4019 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 4032 4033 4034 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 4129 4130 4131 4132 4133 4134 4135 4136 4137 4138 4139 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 4224 4225 4226 4227 4228 4229 4230 4231 4232 4233 4234 4235 4236 4237 4238 4239 4240 4241 4242 4243 4244 4245 4246 4247 4248 4249 4250 4251 4252 4253 4254 4255 4256 4257 4258 4259 4260 4261 4262 4263 4264 4265 4266 4267 4268 4269 4270 4271 4272 4273 4274 4275 4276 4277 4278 4279 4280 4281 4282 4283 4284 4285 4286 4287 4288 4289 4290 4291 4292 4293 4294 4295 4296 4297 4298 4299 4300 4301 4302 4303 4304 4305 4306 4307 4308 4309 4310 4311 4312 4313 4314 4315 4316 4317 4318 4319 4320 4321 4322 4323 4324 4325 4326 4327 4328 4329 4330 4331 4332 4333 4334 4335 4336 4337 4338 4339 4340 4341 4342 4343 4344 4345 4346 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 4377 4378 4379 4380 4381 4382 4383 4384 4385 4386 4387 4388 4389 4390 4391 4392 4393 4394 4395 4396 4397 4398 4399 4400 4401 4402 4403 4404 4405 4406 4407 4408 4409 4410 4411 4412 4413 4414 4415 4416 4417 4418 4419 4420 4421 4422 4423 4424 4425 4426 4427 4428 4429 4430 4431 4432 4433 4434 4435 4436 4437 4438 4439 4440 4441 4442 4443 4444 4445 4446 4447 4448 4449 4450 4451 4452 4453 4454 4455 4456 4457 4458 4459 4460 4461 4462 4463 4464 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 4480 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 4496 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 4515 4516 4517 4518 4519 4520 4521 4522 4523 4524 4525 4526 4527 4528 4529 4530 4531 4532 4533 4534 4535 4536 4537 4538 4539 4540 4541 4542 4543 4544 4545 4546 4547 4548 4549 4550 4551 4552 4553 4554 4555 4556 4557 4558 4559 4560 4561 4562 4563 4564 4565 4566 4567 4568 4569 4570 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 4581 4582 4583 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 4598 4599 4600 4601 4602 4603 4604 4605 4606 4607 4608 4609 4610 4611 4612 4613 4614 4615 4616 4617 4618 4619 4620 4621 4622 4623 4624 4625 4626 4627 4628 4629 4630 4631 4632 4633 4634 4635 4636 4637 4638 4639 4640 4641 4642 4643 4644 4645 4646 4647 4648 4649 4650 4651 4652 4653 4654 4655 4656 4657 4658 4659 4660 4661 4662 4663 4664 4665 4666 4667 4668 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 4693 4694 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 4870 4871 4872 4873 4874 4875 4876 4877 4878 4879 4880 4881 4882 4883 4884 4885 4886 4887 4888 4889 4890 4891 4892 4893 4894 4895 4896 4897 4898 4899 4900 4901 4902 4903 4904 4905 4906 4907 4908 4909 4910 4911 4912 4913 4914 4915 4916 4917 4918 4919 4920 4921 4922 4923 4924 4925 4926 4927 4928 4929 4930 4931 4932 4933 4934 4935 4936 4937 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 5011 5012 5013 5014 5015 5016 5017 5018 5019 5020 5021 5022 5023 5024 5025 5026 5027 5028 5029 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5049 5050 5051 5052 5053 5054 5055 5056 5057 5058 5059 5060 5061 5062 5063 5064 5065 5066 5067 5068 5069 5070 5071 5072 5073 5074 5075 5076 5077 5078 5079 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 5103 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 5125 5126 5127 5128 5129 5130 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 5147 5148 5149 5150 5151 5152 5153 5154 5155 5156 5157 5158 5159 5160 5161 5162 5163 5164 5165 5166 5167 5168 5169 5170 5171 5172 5173 5174 5175 5176 5177 5178 5179 5180 5181 5182 5183 5184 5185 5186 5187 5188 5189 5190 5191 5192 5193 5194 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207 5208 5209 5210 5211 5212 5213 5214 5215 5216 5217 5218 5219 5220 5221 5222 5223 5224 5225 5226 5227 5228 5229 5230 5231 5232 5233 5234 5235 5236 5237 5238 5239 5240 5241 5242 5243 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 5265 5266 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 5424 5425 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 5446 5447 5448 5449 5450 5451 5452 5453 5454 5455 5456 5457 5458 5459 5460 5461 5462 5463 5464 5465 5466 5467 5468 5469 5470 5471 5472 5473 5474 5475 5476 5477 5478 5479 5480 5481 5482 5483 5484 5485 5486 5487 5488 5489 5490 5491 5492 5493 5494 5495 5496 5497 5498 5499 5500 5501 5502 5503 5504 5505 5506 5507 5508 5509 5510 5511 5512 5513 5514 5515 5516 5517 5518 5519 5520 5521 5522 5523 5524 5525 5526 5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 5574 5575 5576 5577 5578 5579 5580 5581 5582 5583 5584 5585 5586 5587 5588 5589 5590 5591 5592 5593 5594 5595 5596 5597 5598 5599 5600 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 5636 5637 5638 5639 5640 5641 5642 5643 5644 5645 5646 5647 5648 5649 5650 5651 5652 5653 5654 5655 5656 5657 5658 5659 5660 5661 5662 5663 5664 5665 5666 5667 5668 5669 5670 5671 5672 5673 5674 5675 5676 5677 5678 5679 5680 5681 5682 5683 5684 5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 5725 5726 5727 5728 5729 5730 5731 5732 5733 5734 5735 5736 5737 5738 5739 5740 5741 5742 5743 5744 5745 5746 5747 5748 5749 5750 5751 5752 5753 5754 5755 5756 5757 5758 5759 5760 5761 5762 5763 5764 5765 5766 5767 5768 5769 5770 5771 5772 5773 5774 5775 5776 5777 5778 5779 5780 5781 5782 5783 5784 5785 5786 5787 5788 5789 5790 5791 5792 5793 5794 5795 5796 5797 5798 5799 5800 5801 5802 5803 5804 5805 5806 5807 5808 5809 5810 5811 5812 5813 5814 5815 5816 5817 5818 5819 5820 5821 5822 5823 5824 5825 5826 5827 5828 5829 5830 5831 5832 5833 5834 5835 5836 5837 5838 5839 5840 5841 5842 5843 5844 5845 5846 5847 5848 5849 5850 5851 5852 5853 5854 5855 5856 5857 5858 5859 5860 5861 5862 5863 5864 5865 5866 5867 5868 5869 5870 5871 5872 5873 5874 5875 5876 5877 5878 5879 5880 5881 5882 5883 5884 5885 5886 5887 5888 5889 5890 5891 5892 5893 5894 5895 5896 5897 5898 5899 5900 5901 5902 5903 5904 5905 5906 5907 5908 5909 5910 5911 5912 5913 5914 5915 5916 5917 5918 5919 5920 5921 5922 5923 5924 5925 5926 5927 5928 5929 5930 5931 5932 5933 5934 5935 5936 5937 5938 5939 5940 5941 5942 5943 5944 5945 5946 5947 5948 5949 5950 5951 5952 5953 5954 5955 5956 5957 5958 5959 5960 5961 5962 5963 5964 5965 5966 5967 5968 5969 5970 5971 5972 5973 5974 5975 5976 5977 5978 5979 5980 5981 5982 5983 5984 5985 5986 5987 5988 5989 5990 5991 5992 5993 5994 5995 5996 5997 5998 5999 6000 6001 6002 6003 6004 6005 6006 6007 6008 6009 6010 6011 6012 6013 6014 6015 6016 6017 6018 6019 6020 6021 6022 6023 6024 6025 6026 6027 6028 6029 6030 6031 6032 6033 6034 6035 6036 6037 6038 6039 6040 6041 6042 6043 6044 6045 6046 6047 6048 6049 6050 6051 6052 6053 6054 6055 6056 6057 6058 6059 6060 6061 6062 6063 6064 6065 6066 6067 6068 6069 6070 6071 6072 6073 6074 6075 6076 6077 6078 6079 6080 6081 6082 6083 6084 6085 6086 6087 6088 6089 6090 6091 6092 6093 6094 6095 6096 6097 6098 6099 6100 6101 6102 6103 6104 6105 6106 6107 6108 6109 6110 6111 6112 6113 6114 6115 6116 6117 6118 6119 6120 6121 6122 6123 6124 6125 6126 6127 6128 6129 6130 6131 6132 6133 6134 6135 6136 6137 6138 6139 6140 6141 6142 6143 6144 6145 6146 6147 6148 6149 6150 6151 6152 6153 6154 6155 6156 6157 6158 6159 6160 6161 6162 6163 6164 6165 6166 6167 6168 6169 6170 6171 6172 6173 6174 6175 6176 6177 6178 6179 6180 6181 6182 6183 6184 6185 6186 6187 6188 6189 6190 6191 6192 6193 6194 6195 6196 6197 6198 6199 6200 6201 6202 6203 6204 6205 6206 6207 6208 6209 6210 6211 6212 6213 6214 6215 6216 6217 6218 6219 6220 6221 6222 6223 6224 6225 6226 6227 6228 6229 6230 6231 6232 6233 6234 6235 6236 6237 6238 6239 6240 6241 6242 6243 6244 6245 6246 6247 6248 6249 6250 6251 6252 6253 6254 6255 6256 6257 6258 6259 6260 6261 6262 6263 6264 6265 6266 6267 6268 6269 6270 6271 6272 6273 6274 6275 6276 6277 6278 6279 6280 6281 6282 6283 6284 6285 6286 6287 6288 6289 6290 6291 6292 6293 6294 6295 6296 6297 6298 6299 6300 6301 6302 6303 6304 6305 6306 6307 6308 6309 6310 6311 6312 6313 6314 6315 6316 6317 6318 6319 6320 6321 6322 6323 6324 6325 6326 6327 6328 6329 6330 6331 6332 6333 6334 6335 6336 6337 6338 6339 6340 6341 6342 6343 6344 6345 6346 6347 6348 6349 6350 6351 6352 6353 6354 6355 6356 6357 6358 6359 6360 6361 6362 6363 6364 6365 6366 6367 6368 6369 6370 6371 6372 6373 6374 6375 6376 6377 6378 6379 6380 6381 6382 6383 6384 6385 6386 6387 6388 6389 6390 6391 6392 6393 6394 6395 6396 6397 6398 6399 6400 6401 6402 6403 6404 6405 6406 6407 6408 6409 6410 6411 6412 6413 6414 6415 6416 6417 6418 6419 6420 6421 6422 6423 6424 6425 6426 6427 6428 6429 6430 6431 6432 6433 6434 6435 6436 6437 6438 6439 6440 6441 6442 6443 6444 6445 6446 6447 6448 6449 6450 6451 6452 6453 6454 6455 6456 6457 6458 6459 6460 6461 6462 6463 6464 6465 6466 6467 6468 6469 6470 6471 6472 6473 6474 6475 6476 6477 6478 6479 6480 6481 6482 6483 6484 6485 6486 6487 6488 6489 6490 6491 6492 6493 6494 6495 6496 6497 6498 6499 6500 6501 6502 6503 6504 6505 6506 6507 6508 6509 6510 6511 6512 6513 6514 6515 6516 6517 6518 6519 6520 6521 6522 6523 6524 6525 6526 6527 6528 6529 6530 6531 6532 6533 6534 6535 6536 6537 6538 6539 6540 6541 6542 6543 6544 6545 6546 6547 6548 6549 6550 6551 6552 6553 6554 6555 6556 6557 6558 6559 6560 6561 6562 6563 6564 6565 6566 6567 6568 6569 6570 6571 6572 6573 6574 6575 6576 6577 6578 6579 6580 6581 6582 6583 6584 6585 6586 6587 6588 6589 6590 6591 6592 6593 6594 6595 6596 6597 6598 6599 6600 6601 6602 6603 6604 6605 6606 6607 6608 6609 6610 6611 6612 6613 6614 6615 6616 6617 6618 6619 6620 6621 6622 6623 6624 6625 6626 6627 6628 6629 6630 6631 6632 6633 6634 6635 6636 6637 6638 6639 6640 6641 6642 6643 6644 6645 6646 6647 6648 6649 6650 6651 6652 6653 6654 6655 6656 6657 6658 6659 6660 6661 6662 6663 6664 6665 6666 6667 6668 6669 6670 6671 6672 6673 6674 6675 6676 6677 6678 6679 6680 6681 6682 6683 6684 6685 6686 6687 6688 6689 6690 6691 6692 6693 6694 6695 6696 6697 6698 6699 6700 6701 6702 6703 6704 6705 6706 6707 6708 6709 6710 6711 6712 6713 6714 6715 6716 6717 6718 6719 6720 6721 6722 6723 6724 6725 6726 6727 6728 6729 6730 6731 6732 6733 6734 6735 6736 6737 6738 6739 6740 6741 6742 6743 6744 6745 6746 6747 6748 6749 6750 6751 6752 6753 6754 6755 6756 6757 6758 6759 6760 6761 6762 6763 6764 6765 6766 6767 6768 6769 6770 6771 6772 6773 6774 6775 6776 6777 6778 6779 6780 6781 6782 6783 6784 6785 6786 6787 6788 6789 6790 6791 6792 6793 6794 6795 6796 6797 6798 6799 6800 6801 6802 6803 6804 6805 6806 6807 6808 6809 6810 6811 6812 6813 6814 6815 6816 6817 6818 6819 6820 6821 6822 6823 6824 6825 6826 6827 6828 6829 6830 6831 6832 6833 6834 6835 6836 6837 6838 6839 6840 6841 6842 6843 6844 6845 6846 6847 6848 6849 6850 6851 6852 6853 6854 6855 6856 6857 6858 6859 6860 6861 6862 6863 6864 6865 6866 6867 6868 6869 6870 6871 6872 6873 6874 6875 6876 6877 6878 6879 6880 6881 6882 6883 6884 6885 6886 6887 6888 6889 6890 6891 6892 6893 6894 6895 6896 6897 6898 6899 6900 6901 6902 6903 6904 6905 6906 6907 6908 6909 6910 6911 6912 6913 6914 6915 6916 6917 6918 6919 6920 6921 6922 6923 6924 6925 6926 6927 6928 6929 6930 6931 6932 6933 6934 6935 6936 6937 6938 6939 6940 6941 6942 6943 6944 6945 6946 6947 6948 6949 6950 6951 6952 6953 6954 6955 6956 6957 6958 6959 6960 6961 6962 6963 6964 6965 6966 6967 6968 6969 6970 6971 6972 6973 6974 6975 6976 6977 6978 6979 6980 6981 6982 6983 6984 6985 6986 6987 6988 6989 6990 6991 6992 6993 6994 6995 6996 6997 6998 6999 7000 7001 7002 7003 7004 7005 7006 7007 7008 7009 7010 7011 7012 7013 7014 7015 7016 7017 7018 7019 7020 7021 7022 7023 7024 7025 7026 7027 7028 7029 7030 7031 7032 7033 7034 7035 7036 7037 7038 7039 7040 7041 7042 7043 7044 7045 7046 7047 7048 7049 7050 7051 7052 7053 7054 7055 7056 7057 7058 7059 7060 7061 7062 7063 7064 7065 7066 7067 7068 7069 7070 7071 7072 7073 7074 7075 7076 7077 7078 7079 7080 7081 7082 7083 7084 7085 7086 7087 7088 7089 7090 7091 7092 7093 7094 7095 7096 7097 7098 7099 7100 7101 7102 7103 7104 7105 7106 7107 7108 7109 7110 7111 7112 7113 7114 7115 7116 7117 7118 7119 7120 7121 7122 7123 7124 7125 7126 7127 7128 7129 7130 7131 7132 7133 7134 7135 7136 7137 7138 7139 7140 7141 7142 7143 7144 7145 7146 7147 7148 7149 7150 7151 7152 7153 7154 7155 7156 7157 7158 7159 7160 7161 7162 7163 7164 7165 7166 7167 7168 7169 7170 7171 7172 7173 7174 7175 7176 7177 7178 7179 7180 7181 7182 7183 7184 7185 7186 7187 7188 7189 7190 7191 7192 7193 7194 7195 7196 7197 7198 7199 7200 7201 7202 7203 7204 7205 7206 7207 7208 7209 7210 7211 7212 7213 7214 7215 7216 7217 7218 7219 7220 7221 7222 7223 7224 7225 7226 7227 7228 7229 7230 7231 7232 7233 7234 7235 7236 7237 7238 7239 7240 7241 7242 7243 7244 7245 7246 7247 7248 7249 7250 7251 7252 7253 7254 7255 7256 7257 7258 7259 7260 7261 7262 7263 7264 7265 7266 7267 7268 7269 7270 7271 7272 7273 7274 7275 7276 7277 7278 7279 7280 7281 7282 7283 7284 7285 7286 7287 7288 7289 7290 7291 7292 7293 7294 7295 7296 7297 7298 7299 7300 7301 7302 7303 7304 7305 7306 7307 7308 7309 7310 7311 7312 7313 7314 7315 7316 7317 7318 7319 7320 7321 7322 7323 7324 7325 7326 7327 7328 7329 7330 7331 7332 7333 7334 7335 7336 7337 7338 7339 7340 7341 7342 7343 7344 7345 7346 7347 7348 7349 7350 7351 7352 7353 7354 7355 7356 7357 7358 7359 7360 7361 7362 7363 7364 7365 7366 7367 7368 7369 7370 7371 7372 7373 7374 7375 7376 7377 7378 7379 7380 7381 7382 7383 7384 7385 7386 7387 7388 7389 7390 7391 7392 7393 7394 7395 7396 7397 7398 7399 7400 7401 7402 7403 7404 7405 7406 7407 7408 7409 7410 7411 7412 7413 7414 7415 7416 7417 7418 7419 7420 7421 7422 7423 7424 7425 7426 7427 7428 7429 7430 7431 7432 7433 7434 7435 7436 7437 7438 7439 7440 7441 7442 7443 7444 7445 7446 7447 7448 7449 7450 7451 7452 7453 7454 7455 7456 7457 7458 7459 7460 7461 7462 7463 7464 7465 7466 7467 7468 7469 7470 7471 7472 7473 7474 7475 7476 7477 7478 7479 7480 7481 7482 7483 7484 7485 7486 7487 7488 7489 7490 7491 7492 7493 7494 7495 7496 7497 7498 7499 7500 7501 7502 7503 7504 7505 7506 7507 7508 7509 7510 7511 7512 7513 7514 7515 7516 7517 7518 7519 7520 7521 7522 7523 7524 7525 7526 7527 7528 7529 7530 7531 7532 7533 7534 7535 7536 7537 7538 7539 7540 7541 7542 7543 7544 7545 7546 7547 7548 7549 7550 7551 7552 7553 7554 7555 7556 7557 7558 7559 7560 7561 7562 7563 7564 7565 7566 7567 7568 7569 7570 7571 7572 7573 7574 7575 7576 7577 7578 7579 7580 7581 7582 7583 7584 7585 7586 7587 7588 7589 7590 7591 7592 7593 7594 7595 7596 7597 7598 7599 7600 7601 7602 7603 7604 7605 7606 7607 7608 7609 7610 7611 7612 7613 7614 7615 7616 7617 7618 7619 7620 7621 7622 7623 7624 7625 7626 7627 7628 7629 7630 7631 7632 7633 7634 7635 7636 7637 7638 7639 7640 7641 7642 7643 7644 7645 7646 7647 7648 7649 7650 7651 7652 7653 7654 7655 7656 7657 7658 7659 7660 7661 7662 7663 7664 7665 7666 7667 7668 7669 7670 7671 7672 7673 7674 7675 7676 7677 7678 7679 7680 7681 7682 7683 7684 7685 7686 7687 7688 7689 7690 7691 7692 7693 7694 7695 7696 7697 7698 7699 7700 7701 7702 7703 7704 7705 7706 7707 7708 7709 7710 7711 7712 7713 7714 7715 7716 7717 7718 7719 7720 7721 7722 7723 7724 7725 7726 7727 7728 7729 7730 7731 7732 7733 7734 7735 7736 7737 7738 7739 7740 7741 7742 7743 7744 7745 7746 7747 7748 7749 7750 7751 7752 7753 7754 7755 7756 7757 7758 7759 7760 7761 7762 7763 7764 7765 7766 7767 7768 7769 7770 7771 7772 7773 7774 7775 7776 7777 7778 7779 7780 7781 7782 7783 7784 7785 7786 7787 7788 7789 7790 7791 7792 7793 7794 7795 7796 7797 7798 7799 7800 7801 7802 7803 7804 7805 7806 7807 7808 7809 7810 7811 7812 7813 7814 7815 7816 7817 7818 7819 7820 7821 7822 7823 7824 7825 7826 7827 7828 7829 7830 7831 7832 7833 7834 7835 7836 7837 7838 7839 7840 7841 7842 7843 7844 7845 7846 7847 7848 7849 7850 7851 7852 7853 7854 7855 7856 7857 7858 7859 7860 7861 7862 7863 7864 7865 7866 7867 7868 7869 7870 7871 7872 7873 7874 7875 7876 7877 7878 7879 7880 7881 7882 7883 7884 7885 7886 7887 7888 7889 7890 7891 7892 7893 7894 7895 7896 7897 7898 7899 7900 7901 7902 7903 7904 7905 7906 7907 7908 7909 7910 7911 7912 7913 7914 7915 7916 7917 7918 7919 7920 7921 7922 7923 7924 7925 7926 7927 7928 7929 7930 7931 7932 7933 7934 7935 7936 7937 7938 7939 7940 7941 7942 7943 7944 7945 7946 7947 7948 7949 7950 7951 7952 7953 7954 7955 7956 7957 7958 7959 7960 7961 7962 7963 7964 7965 7966 7967 7968 7969 7970 7971 7972 7973 7974 7975 7976 7977 7978 7979 7980 7981 7982 7983 7984 7985 7986 7987 7988 7989 7990 7991 7992 7993 7994 7995 7996 7997 7998 7999 8000 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020 8021 8022 8023 8024 8025 8026 8027 8028 8029 8030 8031 8032 8033 8034 8035 8036 8037 8038 8039 8040 8041 8042 8043 8044 8045 8046 8047 8048 8049 8050 8051 8052 8053 8054 8055 8056 8057 8058 8059 8060 8061 8062 8063 8064 8065 8066 8067 8068 8069 8070 8071 8072 8073 8074 8075 8076 8077 8078 8079 8080 8081 8082 8083 8084 8085 8086 8087 8088 8089 8090 8091 8092 8093 8094 8095 8096 8097 8098 8099 8100 8101 8102 8103 8104 8105 8106 8107 8108 8109 8110 8111 8112 8113 8114 8115 8116 8117 8118 8119 8120 8121 8122 8123 8124 8125 8126 8127 8128 8129 8130 8131 8132 8133 8134 8135 8136 8137 8138 8139 8140 8141 8142 8143 8144 8145 8146 8147 8148 8149 8150 8151 8152 8153 8154 8155 8156 8157 8158 8159 8160 8161 8162 8163 8164 8165 8166 8167 8168 8169 8170 8171 8172 8173 8174 8175 8176 8177 8178 8179 8180 8181 8182 8183 8184 8185 8186 8187 8188 8189 8190 8191 8192 8193 8194 8195 8196 8197 8198 8199 8200 8201 8202 8203 8204 8205 8206 8207 8208 8209 8210 8211 8212 8213 8214 8215 8216 8217 8218 8219 8220 8221 8222 8223 8224 8225 8226 8227 8228 8229 8230 8231 8232 8233 8234 8235 8236 8237 8238 8239 8240 8241 8242 8243 8244 8245 8246 8247 8248 8249 8250 8251 8252 8253 8254 8255 8256 8257 8258 8259 8260 8261 8262 8263 8264 8265 8266 8267 8268 8269 8270 8271 8272 8273 8274 8275 8276 8277 8278 8279 8280 8281 8282 8283 8284 8285 8286 8287 8288 8289 8290 8291 8292 8293 8294 8295 8296 8297 8298 8299 8300 8301 8302 8303 8304 8305 8306 8307 8308 8309 8310 8311 8312 8313 8314 8315 8316 8317 8318 8319 8320 8321 8322 8323 8324 8325 8326 8327 8328 8329 8330 8331 8332 8333 8334 8335 8336 8337 8338 8339 8340 8341 8342 8343 8344 8345 8346 8347 8348 8349 8350 8351 8352 8353 8354 8355 8356 8357 8358 8359 8360 8361 8362 8363 8364 8365 8366 8367 8368 8369 8370 8371 8372 8373 8374 8375 8376 8377 8378 8379 8380 8381 8382 8383 8384 8385 8386 8387 8388 8389 8390 8391 8392 8393 8394 8395 8396 8397 8398 8399 8400 8401 8402 8403 8404 8405 8406 8407 8408 8409 8410 8411 8412 8413 8414 8415 8416 8417 8418 8419 8420 8421 8422 8423 8424 8425 8426 8427 8428 8429 8430 8431 8432 8433 8434 8435 8436 8437 8438 8439 8440 8441 8442 8443 8444 8445 8446 8447 8448 8449 8450 8451 8452 8453 8454 8455 8456 8457 8458 8459 8460 8461 8462 8463 8464 8465 8466 8467 8468 8469 8470 8471 8472 8473 8474 8475 8476 8477 8478 8479 8480 8481 8482 8483 8484 8485 8486 8487 8488 8489 8490 8491 8492 8493 8494 8495 8496 8497 8498 8499 8500 8501 8502 8503 8504 8505 8506 8507 8508 8509 8510 8511 8512 8513 8514 8515 8516 8517 8518 8519 8520 8521 8522 8523 8524 8525 8526 8527 8528 8529 8530 8531 8532 8533 8534 8535 8536 8537 8538 8539 8540 8541 8542 8543 8544 8545 8546 8547 8548 8549 8550 8551 8552 8553 8554 8555 8556 8557 8558 8559 8560 8561 8562 8563 8564 8565 8566 8567 8568 8569 8570 8571 8572 8573 8574 8575 8576 8577 8578 8579 8580 8581 8582 8583 8584 8585 8586 8587 8588 8589 8590 8591 8592 8593 8594 8595 8596 8597 8598 8599 8600 8601 8602 8603 8604 8605 8606 8607 8608 8609 8610 8611 8612 8613 8614 8615 8616 8617 8618 8619 8620 8621 8622 8623 8624 8625 8626 8627 8628 8629 8630 8631 8632 8633 8634 8635 8636 8637 8638 8639 8640 8641 8642 8643 8644 8645 8646 8647 8648 8649 8650 8651 8652 8653 8654 8655 8656 8657 8658 8659 8660 8661 8662 8663 8664 8665 8666 8667 8668 8669 8670 8671 8672 8673 8674 8675 8676 8677 8678 8679 8680 8681 8682 8683 8684 8685 8686 8687 8688 8689 8690 8691 8692 8693 8694 8695 8696 8697 8698 8699 8700 8701 8702 8703 8704 8705 8706 8707 8708 8709 8710 8711 8712 8713 8714 8715 8716 8717 8718 8719 8720 8721 8722 8723 8724 8725 8726 8727 8728 8729 8730 8731 8732 8733 8734 8735 8736 8737 8738 8739 8740 8741 8742 8743 8744 8745 8746 8747 8748 8749 8750 8751 8752 8753 8754 8755 8756 8757 8758 8759 8760 8761 8762 8763 8764 8765 8766 8767 8768 8769 8770 8771 8772 8773 8774 8775 8776 8777 8778 8779 8780 8781 8782 8783 8784 8785 8786 8787 8788 8789 8790 8791 8792 8793 8794 8795 8796 8797 8798 8799 8800 8801 8802 8803 8804 8805 8806 8807 8808 8809 8810 8811 8812 8813 8814 8815 8816 8817 8818 8819 8820 8821 8822 8823 8824 8825 8826 8827 8828 8829 8830 8831 8832 8833 8834 8835 8836 8837 8838 8839 8840 8841 8842 8843 8844 8845 8846 8847 8848 8849 8850 8851 8852 8853 8854 8855 8856 8857 8858 8859 8860 8861 8862 8863 8864 8865 8866 8867 8868 8869 8870 8871 8872 8873 8874 8875 8876 8877 8878 8879 8880 8881 8882 8883 8884 8885 8886 8887 8888 8889 8890 8891 8892 8893 8894 8895 8896 8897 8898 8899 8900 8901 8902 8903 8904 8905 8906 8907 8908 8909 8910 8911 8912 8913 8914 8915 8916 8917 8918 8919 8920 8921 8922 8923 8924 8925 8926 8927 8928 8929 8930 8931 8932 8933 8934 8935 8936 8937 8938 8939 8940 8941 8942 8943 8944 8945 8946 8947 8948 8949 8950 8951 8952 8953 8954 8955 8956 8957 8958 8959 8960 8961 8962 8963 8964 8965 8966 8967 8968 8969 8970 8971 8972 8973 8974 8975 8976 8977 8978 8979 8980 8981 8982 8983 8984 8985 8986 8987 8988 8989 8990 8991 8992 8993 8994 8995 8996 8997 8998 8999 9000 9001 9002 9003 9004 9005 9006 9007 9008 9009 9010 9011 9012 9013 9014 9015 9016 9017 9018 9019 9020 9021 9022 9023 9024 9025 9026 9027 9028 9029 9030 9031 9032 9033 9034 9035 9036 9037 9038 9039 9040 9041 9042 9043 9044 9045 9046 9047 9048 9049 9050 9051 9052 9053 9054 9055 9056 9057 9058 9059 9060 9061 9062 9063 9064 9065 9066 9067 9068 9069 9070 9071 9072 9073 9074 9075 9076 9077 9078 9079 9080 9081 9082 9083 9084 9085 9086 9087 9088 9089 9090 9091 9092 9093 9094 9095 9096 9097 9098 9099 9100 9101 9102 9103 9104 9105 9106 9107 9108 9109 9110 9111 9112 9113 9114 9115 9116 9117 9118 9119 9120 9121 9122 9123 9124 9125 9126 9127 9128 9129 9130 9131 9132 9133 9134 9135 9136 9137 9138 9139 9140 9141 9142 9143 9144 9145 9146 9147 9148 9149 9150 9151 9152 9153 9154 9155 9156 9157 9158 9159 9160 9161 9162 9163 9164 9165 9166 9167 9168 9169 9170 9171 9172 9173 9174 9175 9176 9177 9178 9179 9180 9181 9182 9183 9184 9185 9186 9187 9188 9189 9190 9191 9192 9193 9194 9195 9196 9197 9198 9199 9200 9201 9202 9203 9204 9205 9206 9207 9208 9209 9210 9211 9212 9213 9214 9215 9216 9217 9218 9219 9220 9221 9222 9223 9224 9225 9226 9227 9228 9229 9230 9231 9232 9233 9234 9235 9236 9237 9238 9239 9240 9241 9242 9243 9244 9245 9246 9247 9248 9249 9250 9251 9252 9253 9254 9255 9256 9257 9258 9259 9260 9261 9262 9263 9264 9265 9266 9267 9268 9269 9270 9271 9272 9273 9274 9275 9276 9277 9278 9279 9280 9281 9282 9283 9284 9285 9286 9287 9288 9289 9290 9291 9292 9293 9294 9295 9296 9297 9298 9299 9300 9301 9302 9303 9304 9305 9306 9307 9308 9309 9310 9311 9312 9313 9314 9315 9316 9317 9318 9319 9320 9321 9322 9323 9324 9325 9326 9327 9328 9329 9330 9331 9332 9333 9334 9335 9336 9337 9338 9339 9340 9341 9342 9343 9344 9345 9346 9347 9348 9349 9350 9351 9352 9353 9354 9355 9356 9357 9358 9359 9360 9361 9362 9363 9364 9365 9366 9367 9368 9369 9370 9371 9372 9373 9374 9375 9376 9377 9378 9379 9380 9381 9382 9383 9384 9385 9386 9387 9388 9389 9390 9391 9392 9393 9394 9395 9396 9397 9398 9399 9400 9401 9402 9403 9404 9405 9406 9407 9408 9409 9410 9411 9412 9413 9414 9415 9416 9417 9418 9419 9420 9421 9422 9423 9424 9425 9426 9427 9428 9429 9430 9431 9432 9433 9434 9435 9436 9437 9438 9439 9440 9441 9442 9443 9444 9445 9446 9447 9448 9449 9450 9451 9452 9453 9454 9455 9456 9457 9458 9459 9460 9461 9462 9463 9464 9465 9466 9467 9468 9469 9470 9471 9472 9473 9474 9475 9476 9477 9478 9479 9480 9481 9482 9483 9484 9485 9486 9487 9488 9489 9490 9491 9492 9493 9494 9495 9496 9497 9498 9499 9500 9501 9502 9503 9504 9505 9506 9507 9508 9509 9510 9511 9512 9513 9514 9515 9516 9517 9518 9519 9520 9521 9522 9523 9524 9525 9526 9527 9528 9529 9530 9531 9532 9533 9534 9535 9536 9537 9538 9539 9540 9541 9542 9543 9544 9545 9546 9547 9548 9549 9550 9551 9552 9553 9554 9555 9556 9557 9558 9559 9560 9561 9562 9563 9564 9565 9566 9567 9568 9569 9570 9571 9572 9573 9574 9575 9576 9577 9578 9579 9580 9581 9582 9583 9584 9585 9586 9587 9588 9589 9590 9591 9592 9593 9594 9595 9596 9597 9598 9599 9600 9601 9602 9603 9604 9605 9606 9607 9608 9609 9610 9611 9612 9613 9614 9615 9616 9617 9618 9619 9620 9621 9622 9623 9624 9625 9626 9627 9628 9629 9630 9631 9632 9633 9634 9635 9636 9637 9638 9639 9640 9641 9642 9643 9644 9645 9646 9647 9648 9649 9650 9651 9652 9653 9654 9655 9656 9657 9658 9659 9660 9661 9662 9663 9664 9665 9666 9667 9668 9669 9670 9671 9672 9673 9674 9675 9676 9677 9678 9679 9680 9681 9682 9683 9684 9685 9686 9687 9688 9689 9690 9691 9692 9693 9694 9695 9696 9697 9698 9699 9700 9701 9702 9703 9704 9705 9706 9707 9708 9709 9710 9711 9712 9713 9714 9715 9716 9717 9718 9719 9720 9721 9722 9723 9724 9725 9726 9727 9728 9729 9730 9731 9732 9733 9734 9735 9736 9737 9738 9739 9740 9741 9742 9743 9744 9745 9746 9747 9748 9749 9750 9751 9752 9753 9754 9755 9756 9757 9758 9759 9760 9761 9762 9763 9764 9765 9766 9767 9768 9769 9770 9771 9772 9773 9774 9775 9776 9777 9778 9779 9780 9781 9782 9783 9784 9785 9786 9787 9788 9789 9790 9791 9792 9793 9794 9795 9796 9797 9798 9799 9800 9801 9802 9803 9804 9805 9806 9807 9808 9809 9810 9811 9812 9813 9814 9815 9816 9817 9818 9819 9820 9821 9822 9823 9824 9825 9826 9827 9828 9829 9830 9831 9832 9833 9834 9835 9836 9837 9838 9839 9840 9841 9842 9843 9844 9845 9846 9847 9848 9849 9850 9851 9852 9853 9854 9855 9856 9857 9858 9859 9860 9861 9862 9863 9864 9865 9866 9867 9868 9869 9870 9871 9872 9873 9874 9875 9876 9877 9878 9879 9880 9881 9882 9883 9884 9885 9886 9887 9888 9889 9890 9891 9892 9893 9894 9895 9896 9897 9898 9899 9900 9901 9902 9903 9904 9905 9906 9907 9908 9909 9910 9911 9912 9913 9914 9915 9916 9917 9918 9919 9920 9921 9922 9923 9924 9925 9926 9927 9928 9929 9930 9931 9932 9933 9934 9935 9936 9937 9938 9939 9940 9941 9942 9943 9944 9945 9946 9947 9948 9949 9950 9951 9952 9953 9954 9955 9956 9957 9958 9959 9960 9961 9962 9963 9964 9965 9966 9967 9968 9969 9970 9971 9972 9973 9974 9975 9976 9977 9978 9979 9980 9981 9982 9983 9984 9985 9986 9987 9988 9989 9990 9991 9992 9993 9994 9995 9996 9997 9998 9999 10000--- out put the order of the loop list ---6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 96 102 108 114 120 126 132 138 144 150 156 162 168 174 180 186 192 198 204 210 216 222 228 234 240 246 252 258 264 270 276 282 288 294 300 306 312 318 324 330 336 342 348 354 360 366 372 378 384 390 396 402 408 414 420 426 432 438 444 450 456 462 468 474 480 486 492 498 504 510 516 522 528 534 540 546 552 558 564 570 576 582 588 594 600 606 612 618 624 630 636 642 648 654 660 666 672 678 684 690 696 702 708 714 720 726 732 738 744 750 756 762 768 774 780 786 792 798 804 810 816 822 828 834 840 846 852 858 864 870 876 882 888 894 900 906 912 918 924 930 936 942 948 954 960 966 972 978 984 990 996 1002 1008 1014 1020 1026 1032 1038 1044 1050 1056 1062 1068 1074 1080 1086 1092 1098 1104 1110 1116 1122 1128 1134 1140 1146 1152 1158 1164 1170 1176 1182 1188 1194 1200 1206 1212 1218 1224 1230 1236 1242 1248 1254 1260 1266 1272 1278 1284 1290 1296 1302 1308 1314 1320 1326 1332 1338 1344 1350 1356 1362 1368 1374 1380 1386 1392 1398 1404 1410 1416 1422 1428 1434 1440 1446 1452 1458 1464 1470 1476 1482 1488 1494 1500 1506 1512 1518 1524 1530 1536 1542 1548 1554 1560 1566 1572 1578 1584 1590 1596 1602 1608 1614 1620 1626 1632 1638 1644 1650 1656 1662 1668 1674 1680 1686 1692 1698 1704 1710 1716 1722 1728 1734 1740 1746 1752 1758 1764 1770 1776 1782 1788 1794 1800 1806 1812 1818 1824 1830 1836 1842 1848 1854 1860 1866 1872 1878 1884 1890 1896 1902 1908 1914 1920 1926 1932 1938 1944 1950 1956 1962 1968 1974 1980 1986 1992 1998 2004 2010 2016 2022 2028 2034 2040 2046 2052 2058 2064 2070 2076 2082 2088 2094 2100 2106 2112 2118 2124 2130 2136 2142 2148 2154 2160 2166 2172 2178 2184 2190 2196 2202 2208 2214 2220 2226 2232 2238 2244 2250 2256 2262 2268 2274 2280 2286 2292 2298 2304 2310 2316 2322 2328 2334 2340 2346 2352 2358 2364 2370 2376 2382 2388 2394 2400 2406 2412 2418 2424 2430 2436 2442 2448 2454 2460 2466 2472 2478 2484 2490 2496 2502 2508 2514 2520 2526 2532 2538 2544 2550 2556 2562 2568 2574 2580 2586 2592 2598 2604 2610 2616 2622 2628 2634 2640 2646 2652 2658 2664 2670 2676 2682 2688 2694 2700 2706 2712 2718 2724 2730 2736 2742 2748 2754 2760 2766 2772 2778 2784 2790 2796 2802 2808 2814 2820 2826 2832 2838 2844 2850 2856 2862 2868 2874 2880 2886 2892 2898 2904 2910 2916 2922 2928 2934 2940 2946 2952 2958 2964 2970 2976 2982 2988 2994 3000 3006 3012 3018 3024 3030 3036 3042 3048 3054 3060 3066 3072 3078 3084 3090 3096 3102 3108 3114 3120 3126 3132 3138 3144 3150 3156 3162 3168 3174 3180 3186 3192 3198 3204 3210 3216 3222 3228 3234 3240 3246 3252 3258 3264 3270 3276 3282 3288 3294 3300 3306 3312 3318 3324 3330 3336 3342 3348 3354 3360 3366 3372 3378 3384 3390 3396 3402 3408 3414 3420 3426 3432 3438 3444 3450 3456 3462 3468 3474 3480 3486 3492 3498 3504 3510 3516 3522 3528 3534 3540 3546 3552 3558 3564 3570 3576 3582 3588 3594 3600 3606 3612 3618 3624 3630 3636 3642 3648 3654 3660 3666 3672 3678 3684 3690 3696 3702 3708 3714 3720 3726 3732 3738 3744 3750 3756 3762 3768 3774 3780 3786 3792 3798 3804 3810 3816 3822 3828 3834 3840 3846 3852 3858 3864 3870 3876 3882 3888 3894 3900 3906 3912 3918 3924 3930 3936 3942 3948 3954 3960 3966 3972 3978 3984 3990 3996 4002 4008 4014 4020 4026 4032 4038 4044 4050 4056 4062 4068 4074 4080 4086 4092 4098 4104 4110 4116 4122 4128 4134 4140 4146 4152 4158 4164 4170 4176 4182 4188 4194 4200 4206 4212 4218 4224 4230 4236 4242 4248 4254 4260 4266 4272 4278 4284 4290 4296 4302 4308 4314 4320 4326 4332 4338 4344 4350 4356 4362 4368 4374 4380 4386 4392 4398 4404 4410 4416 4422 4428 4434 4440 4446 4452 4458 4464 4470 4476 4482 4488 4494 4500 4506 4512 4518 4524 4530 4536 4542 4548 4554 4560 4566 4572 4578 4584 4590 4596 4602 4608 4614 4620 4626 4632 4638 4644 4650 4656 4662 4668 4674 4680 4686 4692 4698 4704 4710 4716 4722 4728 4734 4740 4746 4752 4758 4764 4770 4776 4782 4788 4794 4800 4806 4812 4818 4824 4830 4836 4842 4848 4854 4860 4866 4872 4878 4884 4890 4896 4902 4908 4914 4920 4926 4932 4938 4944 4950 4956 4962 4968 4974 4980 4986 4992 4998 5004 5010 5016 5022 5028 5034 5040 5046 5052 5058 5064 5070 5076 5082 5088 5094 5100 5106 5112 5118 5124 5130 5136 5142 5148 5154 5160 5166 5172 5178 5184 5190 5196 5202 5208 5214 5220 5226 5232 5238 5244 5250 5256 5262 5268 5274 5280 5286 5292 5298 5304 5310 5316 5322 5328 5334 5340 5346 5352 5358 5364 5370 5376 5382 5388 5394 5400 5406 5412 5418 5424 5430 5436 5442 5448 5454 5460 5466 5472 5478 5484 5490 5496 5502 5508 5514 5520 5526 5532 5538 5544 5550 5556 5562 5568 5574 5580 5586 5592 5598 5604 5610 5616 5622 5628 5634 5640 5646 5652 5658 5664 5670 5676 5682 5688 5694 5700 5706 5712 5718 5724 5730 5736 5742 5748 5754 5760 5766 5772 5778 5784 5790 5796 5802 5808 5814 5820 5826 5832 5838 5844 5850 5856 5862 5868 5874 5880 5886 5892 5898 5904 5910 5916 5922 5928 5934 5940 5946 5952 5958 5964 5970 5976 5982 5988 5994 6000 6006 6012 6018 6024 6030 6036 6042 6048 6054 6060 6066 6072 6078 6084 6090 6096 6102 6108 6114 6120 6126 6132 6138 6144 6150 6156 6162 6168 6174 6180 6186 6192 6198 6204 6210 6216 6222 6228 6234 6240 6246 6252 6258 6264 6270 6276 6282 6288 6294 6300 6306 6312 6318 6324 6330 6336 6342 6348 6354 6360 6366 6372 6378 6384 6390 6396 6402 6408 6414 6420 6426 6432 6438 6444 6450 6456 6462 6468 6474 6480 6486 6492 6498 6504 6510 6516 6522 6528 6534 6540 6546 6552 6558 6564 6570 6576 6582 6588 6594 6600 6606 6612 6618 6624 6630 6636 6642 6648 6654 6660 6666 6672 6678 6684 6690 6696 6702 6708 6714 6720 6726 6732 6738 6744 6750 6756 6762 6768 6774 6780 6786 6792 6798 6804 6810 6816 6822 6828 6834 6840 6846 6852 6858 6864 6870 6876 6882 6888 6894 6900 6906 6912 6918 6924 6930 6936 6942 6948 6954 6960 6966 6972 6978 6984 6990 6996 7002 7008 7014 7020 7026 7032 7038 7044 7050 7056 7062 7068 7074 7080 7086 7092 7098 7104 7110 7116 7122 7128 7134 7140 7146 7152 7158 7164 7170 7176 7182 7188 7194 7200 7206 7212 7218 7224 7230 7236 7242 7248 7254 7260 7266 7272 7278 7284 7290 7296 7302 7308 7314 7320 7326 7332 7338 7344 7350 7356 7362 7368 7374 7380 7386 7392 7398 7404 7410 7416 7422 7428 7434 7440 7446 7452 7458 7464 7470 7476 7482 7488 7494 7500 7506 7512 7518 7524 7530 7536 7542 7548 7554 7560 7566 7572 7578 7584 7590 7596 7602 7608 7614 7620 7626 7632 7638 7644 7650 7656 7662 7668 7674 7680 7686 7692 7698 7704 7710 7716 7722 7728 7734 7740 7746 7752 7758 7764 7770 7776 7782 7788 7794 7800 7806 7812 7818 7824 7830 7836 7842 7848 7854 7860 7866 7872 7878 7884 7890 7896 7902 7908 7914 7920 7926 7932 7938 7944 7950 7956 7962 7968 7974 7980 7986 7992 7998 8004 8010 8016 8022 8028 8034 8040 8046 8052 8058 8064 8070 8076 8082 8088 8094 8100 8106 8112 8118 8124 8130 8136 8142 8148 8154 8160 8166 8172 8178 8184 8190 8196 8202 8208 8214 8220 8226 8232 8238 8244 8250 8256 8262 8268 8274 8280 8286 8292 8298 8304 8310 8316 8322 8328 8334 8340 8346 8352 8358 8364 8370 8376 8382 8388 8394 8400 8406 8412 8418 8424 8430 8436 8442 8448 8454 8460 8466 8472 8478 8484 8490 8496 8502 8508 8514 8520 8526 8532 8538 8544 8550 8556 8562 8568 8574 8580 8586 8592 8598 8604 8610 8616 8622 8628 8634 8640 8646 8652 8658 8664 8670 8676 8682 8688 8694 8700 8706 8712 8718 8724 8730 8736 8742 8748 8754 8760 8766 8772 8778 8784 8790 8796 8802 8808 8814 8820 8826 8832 8838 8844 8850 8856 8862 8868 8874 8880 8886 8892 8898 8904 8910 8916 8922 8928 8934 8940 8946 8952 8958 8964 8970 8976 8982 8988 8994 9000 9006 9012 9018 9024 9030 9036 9042 9048 9054 9060 9066 9072 9078 9084 9090 9096 9102 9108 9114 9120 9126 9132 9138 9144 9150 9156 9162 9168 9174 9180 9186 9192 9198 9204 9210 9216 9222 9228 9234 9240 9246 9252 9258 9264 9270 9276 9282 9288 9294 9300 9306 9312 9318 9324 9330 9336 9342 9348 9354 9360 9366 9372 9378 9384 9390 9396 9402 9408 9414 9420 9426 9432 9438 9444 9450 9456 9462 9468 9474 9480 9486 9492 9498 9504 9510 9516 9522 9528 9534 9540 9546 9552 9558 9564 9570 9576 9582 9588 9594 9600 9606 9612 9618 9624 9630 9636 9642 9648 9654 9660 9666 9672 9678 9684 9690 9696 9702 9708 9714 9720 9726 9732 9738 9744 9750 9756 9762 9768 9774 9780 9786 9792 9798 9804 9810 9816 9822 9828 9834 9840 9846 9852 9858 9864 9870 9876 9882 9888 9894 9900 9906 9912 9918 9924 9930 9936 9942 9948 9954 9960 9966 9972 9978 9984 9990 9996 2 9 16 23 31 38 45 52 59 67 74 81 88 95 103 110 117 124 131 139 146 153 160 167 175 182 189 196 203 211 218 225 232 239 247 254 261 268 275 283 290 297 304 311 319 326 333 340 347 355 362 369 376 383 391 398 405 412 419 427 434 441 448 455 463 470 477 484 491 499 506 513 520 527 535 542 549 556 563 571 578 585 592 599 607 614 621 628 635 643 650 657 664 671 679 686 693 700 707 715 722 729 736 743 751 758 765 772 779 787 794 801 808 815 823 830 837 844 851 859 866 873 880 887 895 902 909 916 923 931 938 945 952 959 967 974 981 988 995 1003 1010 1017 1024 1031 1039 1046 1053 1060 1067 1075 1082 1089 1096 1103 1111 1118 1125 1132 1139 1147 1154 1161 1168 1175 1183 1190 1197 1204 1211 1219 1226 1233 1240 1247 1255 1262 1269 1276 1283 1291 1298 1305 1312 1319 1327 1334 1341 1348 1355 1363 1370 1377 1384 1391 1399 1406 1413 1420 1427 1435 1442 1449 1456 1463 1471 1478 1485 1492 1499 1507 1514 1521 1528 1535 1543 1550 1557 1564 1571 1579 1586 1593 1600 1607 1615 1622 1629 1636 1643 1651 1658 1665 1672 1679 1687 1694 1701 1708 1715 1723 1730 1737 1744 1751 1759 1766 1773 1780 1787 1795 1802 1809 1816 1823 1831 1838 1845 1852 1859 1867 1874 1881 1888 1895 1903 1910 1917 1924 1931 1939 1946 1953 1960 1967 1975 1982 1989 1996 2003 2011 2018 2025 2032 2039 2047 2054 2061 2068 2075 2083 2090 2097 2104 2111 2119 2126 2133 2140 2147 2155 2162 2169 2176 2183 2191 2198 2205 2212 2219 2227 2234 2241 2248 2255 2263 2270 2277 2284 2291 2299 2306 2313 2320 2327 2335 2342 2349 2356 2363 2371 2378 2385 2392 2399 2407 2414 2421 2428 2435 2443 2450 2457 2464 2471 2479 2486 2493 2500 2507 2515 2522 2529 2536 2543 2551 2558 2565 2572 2579 2587 2594 2601 2608 2615 2623 2630 2637 2644 2651 2659 2666 2673 2680 2687 2695 2702 2709 2716 2723 2731 2738 2745 2752 2759 2767 2774 2781 2788 2795 2803 2810 2817 2824 2831 2839 2846 2853 2860 2867 2875 2882 2889 2896 2903 2911 2918 2925 2932 2939 2947 2954 2961 2968 2975 2983 2990 2997 3004 3011 3019 3026 3033 3040 3047 3055 3062 3069 3076 3083 3091 3098 3105 3112 3119 3127 3134 3141 3148 3155 3163 3170 3177 3184 3191 3199 3206 3213 3220 3227 3235 3242 3249 3256 3263 3271 3278 3285 3292 3299 3307 3314 3321 3328 3335 3343 3350 3357 3364 3371 3379 3386 3393 3400 3407 3415 3422 3429 3436 3443 3451 3458 3465 3472 3479 3487 3494 3501 3508 3515 3523 3530 3537 3544 3551 3559 3566 3573 3580 3587 3595 3602 3609 3616 3623 3631 3638 3645 3652 3659 3667 3674 3681 3688 3695 3703 3710 3717 3724 3731 3739 3746 3753 3760 3767 3775 3782 3789 3796 3803 3811 3818 3825 3832 3839 3847 3854 3861 3868 3875 3883 3890 3897 3904 3911 3919 3926 3933 3940 3947 3955 3962 3969 3976 3983 3991 3998 4005 4012 4019 4027 4034 4041 4048 4055 4063 4070 4077 4084 4091 4099 4106 4113 4120 4127 4135 4142 4149 4156 4163 4171 4178 4185 4192 4199 4207 4214 4221 4228 4235 4243 4250 4257 4264 4271 4279 4286 4293 4300 4307 4315 4322 4329 4336 4343 4351 4358 4365 4372 4379 4387 4394 4401 4408 4415 4423 4430 4437 4444 4451 4459 4466 4473 4480 4487 4495 4502 4509 4516 4523 4531 4538 4545 4552 4559 4567 4574 4581 4588 4595 4603 4610 4617 4624 4631 4639 4646 4653 4660 4667 4675 4682 4689 4696 4703 4711 4718 4725 4732 4739 4747 4754 4761 4768 4775 4783 4790 4797 4804 4811 4819 4826 4833 4840 4847 4855 4862 4869 4876 4883 4891 4898 4905 4912 4919 4927 4934 4941 4948 4955 4963 4970 4977 4984 4991 4999 5006 5013 5020 5027 5035 5042 5049 5056 5063 5071 5078 5085 5092 5099 5107 5114 5121 5128 5135 5143 5150 5157 5164 5171 5179 5186 5193 5200 5207 5215 5222 5229 5236 5243 5251 5258 5265 5272 5279 5287 5294 5301 5308 5315 5323 5330 5337 5344 5351 5359 5366 5373 5380 5387 5395 5402 5409 5416 5423 5431 5438 5445 5452 5459 5467 5474 5481 5488 5495 5503 5510 5517 5524 5531 5539 5546 5553 5560 5567 5575 5582 5589 5596 5603 5611 5618 5625 5632 5639 5647 5654 5661 5668 5675 5683 5690 5697 5704 5711 5719 5726 5733 5740 5747 5755 5762 5769 5776 5783 5791 5798 5805 5812 5819 5827 5834 5841 5848 5855 5863 5870 5877 5884 5891 5899 5906 5913 5920 5927 5935 5942 5949 5956 5963 5971 5978 5985 5992 5999 6007 6014 6021 6028 6035 6043 6050 6057 6064 6071 6079 6086 6093 6100 6107 6115 6122 6129 6136 6143 6151 6158 6165 6172 6179 6187 6194 6201 6208 6215 6223 6230 6237 6244 6251 6259 6266 6273 6280 6287 6295 6302 6309 6316 6323 6331 6338 6345 6352 6359 6367 6374 6381 6388 6395 6403 6410 6417 6424 6431 6439 6446 6453 6460 6467 6475 6482 6489 6496 6503 6511 6518 6525 6532 6539 6547 6554 6561 6568 6575 6583 6590 6597 6604 6611 6619 6626 6633 6640 6647 6655 6662 6669 6676 6683 6691 6698 6705 6712 6719 6727 6734 6741 6748 6755 6763 6770 6777 6784 6791 6799 6806 6813 6820 6827 6835 6842 6849 6856 6863 6871 6878 6885 6892 6899 6907 6914 6921 6928 6935 6943 6950 6957 6964 6971 6979 6986 6993 7000 7007 7015 7022 7029 7036 7043 7051 7058 7065 7072 7079 7087 7094 7101 7108 7115 7123 7130 7137 7144 7151 7159 7166 7173 7180 7187 7195 7202 7209 7216 7223 7231 7238 7245 7252 7259 7267 7274 7281 7288 7295 7303 7310 7317 7324 7331 7339 7346 7353 7360 7367 7375 7382 7389 7396 7403 7411 7418 7425 7432 7439 7447 7454 7461 7468 7475 7483 7490 7497 7504 7511 7519 7526 7533 7540 7547 7555 7562 7569 7576 7583 7591 7598 7605 7612 7619 7627 7634 7641 7648 7655 7663 7670 7677 7684 7691 7699 7706 7713 7720 7727 7735 7742 7749 7756 7763 7771 7778 7785 7792 7799 7807 7814 7821 7828 7835 7843 7850 7857 7864 7871 7879 7886 7893 7900 7907 7915 7922 7929 7936 7943 7951 7958 7965 7972 7979 7987 7994 8001 8008 8015 8023 8030 8037 8044 8051 8059 8066 8073 8080 8087 8095 8102 8109 8116 8123 8131 8138 8145 8152 8159 8167 8174 8181 8188 8195 8203 8210 8217 8224 8231 8239 8246 8253 8260 8267 8275 8282 8289 8296 8303 8311 8318 8325 8332 8339 8347 8354 8361 8368 8375 8383 8390 8397 8404 8411 8419 8426 8433 8440 8447 8455 8462 8469 8476 8483 8491 8498 8505 8512 8519 8527 8534 8541 8548 8555 8563 8570 8577 8584 8591 8599 8606 8613 8620 8627 8635 8642 8649 8656 8663 8671 8678 8685 8692 8699 8707 8714 8721 8728 8735 8743 8750 8757 8764 8771 8779 8786 8793 8800 8807 8815 8822 8829 8836 8843 8851 8858 8865 8872 8879 8887 8894 8901 8908 8915 8923 8930 8937 8944 8951 8959 8966 8973 8980 8987 8995 9002 9009 9016 9023 9031 9038 9045 9052 9059 9067 9074 9081 9088 9095 9103 9110 9117 9124 9131 9139 9146 9153 9160 9167 9175 9182 9189 9196 9203 9211 9218 9225 9232 9239 9247 9254 9261 9268 9275 9283 9290 9297 9304 9311 9319 9326 9333 9340 9347 9355 9362 9369 9376 9383 9391 9398 9405 9412 9419 9427 9434 9441 9448 9455 9463 9470 9477 9484 9491 9499 9506 9513 9520 9527 9535 9542 9549 9556 9563 9571 9578 9585 9592 9599 9607 9614 9621 9628 9635 9643 9650 9657 9664 9671 9679 9686 9693 9700 9707 9715 9722 9729 9736 9743 9751 9758 9765 9772 9779 9787 9794 9801 9808 9815 9823 9830 9837 9844 9851 9859 9866 9873 9880 9887 9895 9902 9909 9916 9923 9931 9938 9945 9952 9959 9967 9974 9981 9988 9995 3 11 20 28 37 46 55 63 71 80 89 98 106 115 123 133 141 149 158 166 176 184 193 201 209 219 227 236 244 253 262 271 279 287 296 305 314 322 331339 349 357 365 374 382 392 400 409 417 425 435 443 452 460 469 478 487 495 503 512 521 530 538 547 555 565 573 581 590 598 608 616 625 633 641 651 659 668 676 685 694 703 711 719 728 737 746 754 763 771 781 789 797 806 814 824 832 841 849 857 867 875 884 892901 910 919 927 935 944 953 962 970 979 987 997 1005 1013 1022 1030 1040 1048 1057 1065 1073 1083 1091 1100 1108 1117 1126 1135 1143 1151 1160 1169 1178 1186 1195 1203 1213 1221 1229 1238 1246 1256 1264 1273 1281 1289 1299 1307 1316 1324 1333 1342 1351 1359 1367 1376 1385 1394 1402 1411 1419 1429 1437 1445 1454 1462 1472 1480 1489 1497 1505 1515 1523 1532 1540 1549 1558 1567 1575 1583 1592 1601 1610 1618 1627 1635 1645 1653 1661 1670 1678 1688 1696 1705 1713 1721 1731 1739 1748 1756 1765 1774 1783 1791 1799 1808 1817 1826 1834 1843 1851 1861 1869 1877 1886 1894 1904 1912 1921 1929 1937 1947 1955 1964 1972 1981 1990 1999 2007 2015 2024 2033 2042 2050 2059 2067 2077 2085 2093 2102 2110 2120 2128 2137 2145 2153 2163 2171 2180 2188 2197 2206 2215 2223 2231 2240 2249 2258 2266 2275 2283 2293 2301 2309 2318 2326 2336 2344 2353 2361 2369 2379 2387 2396 2404 2413 2422 2431 2439 2447 2456 2465 2474 2482 2491 2499 2509 2517 2525 2534 2542 2552 2560 2569 2577 2585 2595 2603 2612 2620 2629 2638 2647 2655 2663 2672 2681 2690 2698 2707 2715 2725 2733 2741 2750 2758 2768 2776 2785 2793 2801 2811 2819 2828 2836 2845 2854 2863 2871 2879 2888 2897 2906 2914 2923 2931 2941 2949 2957 2966 2974 2984 2992 3001 3009 3017 3027 3035 3044 3052 3061 3070 3079 3087 3095 3104 3113 3122 3130 3139 3147 3157 3165 3173 3182 3190 3200 3208 3217 3225 3233 3243 3251 3260 3268 3277 3286 3295 3303 3311 3320 3329 3338 3346 3355 3363 3373 3381 3389 3398 3406 3416 3424 3433 3441 3449 3459 3467 3476 3484 3493 3502 3511 3519 3527 3536 3545 3554 3562 3571 3579 3589 3597 3605 3614 3622 3632 3640 3649 3657 3665 3675 3683 3692 3700 3709 3718 3727 3735 3743 3752 3761 3770 3778 3787 3795 3805 3813 3821 3830 3838 3848 3856 3865 3873 3881 3891 3899 3908 3916 3925 3934 3943 3951 3959 3968 3977 3986 3994 4003 4011 4021 4029 4037 4046 4054 4064 4072 4081 4089 4097 4107 4115 4124 4132 4141 4150 4159 4167 4175 4184 4193 4202 4210 4219 4227 4237 4245 4253 4262 4270 4280 4288 4297 4305 4313 4323 4331 4340 4348 4357 4366 4375 4383 4391 4400 4409 4418 4426 4435 4443 4453 4461 4469 4478 4486 4496 4504 4513 4521 4529 4539 4547 4556 4564 4573 4582 4591 4599 4607 4616 4625 4634 4642 4651 4659 4669 4677 4685 4694 4702 4712 4720 4729 4737 4745 4755 4763 4772 4780 4789 4798 4807 4815 4823 4832 4841 4850 4858 4867 4875 4885 4893 4901 4910 4918 4928 4936 4945 4953 4961 4971 4979 4988 4996 5005 5014 5023 5031 5039 5048 5057 5066 5074 5083 5091 5101 5109 5117 5126 5134 5144 5152 5161 5169 5177 5187 5195 5204 5212 5221 5230 5239 5247 5255 5264 5273 5282 5290 5299 5307 5317 5325 5333 5342 5350 5360 5368 5377 5385 5393 5403 5411 5420 5428 5437 5446 5455 5463 5471 5480 5489 5498 5506 5515 5523 5533 5541 5549 5558 5566 5576 5584 5593 5601 5609 5619 5627 5636 5644 5653 5662 5671 5679 5687 5696 5705 5714 5722 5731 5739 5749 5757 5765 5774 5782 5792 5800 5809 5817 5825 5835 5843 5852 5860 5869 5878 5887 5895 5903 5912 5921 5930 5938 5947 5955 5965 5973 5981 5990 5998 6008 6016 6025 6033 6041 6051 6059 6068 6076 6085 6094 6103 6111 6119 6128 6137 6146 6154 6163 6171 6181 6189 6197 6206 6214 6224 6232 6241 6249 6257 6267 6275 6284 6292 6301 6310 6319 6327 6335 6344 6353 6362 6370 6379 6387 6397 6405 6413 6422 6430 6440 6448 6457 6465 6473 6483 6491 6500 6508 6517 6526 6535 6543 6551 6560 6569 6578 6586 6595 6603 6613 6621 6629 6638 6646 6656 6664 6673 6681 6689 6699 6707 6716 6724 6733 6742 6751 6759 6767 6776 6785 6794 6802 6811 6819 6829 6837 6845 6854 6862 6872 6880 6889 6897 6905 6915 6923 6932 6940 6949 6958 6967 6975 6983 6992 7001 7010 7018 7027 7035 7045 7053 7061 7070 7078 7088 7096 7105 7113 7121 7131 7139 7148 7156 7165 7174 7183 7191 7199 7208 7217 7226 7234 7243 7251 7261 7269 7277 7286 7294 7304 7312 7321 7329 7337 7347 7355 7364 7372 7381 7390 7399 7407 7415 7424 7433 7442 7450 7459 7467 7477 7485 7493 7502 7510 7520 7528 7537 7545 7553 7563 7571 7580 7588 7597 7606 7615 7623 7631 7640 7649 7658 7666 7675 7683 7693 7701 7709 7718 7726 7736 7744 7753 7761 7769 7779 7787 7796 7804 7813 7822 7831 7839 7847 7856 7865 7874 7882 7891 7899 7909 7917 7925 7934 7942 7952 7960 7969 7977 7985 7995 8003 8012 8020 8029 8038 8047 8055 8063 8072 8081 8090 8098 8107 8115 8125 8133 8141 8150 8158 8168 8176 8185 8193 8201 8211 8219 8228 8236 8245 8254 8263 8271 8279 8288 8297 8306 8314 8323 8331 8341 8349 8357 8366 8374 8384 8392 8401 8409 8417 8427 8435 8444 8452 8461 8470 8479 8487 8495 8504 8513 8522 8530 8539 8547 8557 8565 8573 8582 8590 8600 8608 8617 8625 8633 8643 8651 8660 8668 8677 8686 8695 8703 8711 8720 8729 8738 8746 8755 8763 8773 8781 8789 8798 8806 8816 8824 8833 8841 8849 8859 8867 8876 8884 8893 8902 8911 8919 8927 8936 8945 8954 8962 8971 8979 8989 8997 9005 9014 9022 9032 9040 9049 9057 9065 9075 9083 9092 9100 9109 9118 9127 9135 9143 9152 9161 9170 9178 9187 9195 9205 9213 9221 9230 9238 9248 9256 9265 9273 9281 9291 9299 9308 9316 9325 9334 9343 9351 9359 9368 9377 9386 9394 9403 9411 9421 9429 9437 9446 9454 9464 9472 9481 9489 9497 9507 9515 9524 9532 9541 9550 9559 9567 9575 9584 9593 9602 9610 9619 9627 9637 9645 9653 9662 9670 9680 9688 9697 9705 9713 9723 9731 9740 9748 9757 9766 9775 9783 9791 9800 9809 9818 9826 9835 9843 9853 9861 9869 9878 9886 9896 9904 9913 9921 9929 9939 9947 9956 9964 9973 9982 9991 9999 8 19 29 40 50 61 70 82 92 101 112 122 134 143 154 164 173 185 195 206 215 226 237 248 257 267 278 289 299 309 320 329 341 351 361 371 381 393 403 413 423 433 445 454 465 475 485 496 507 517 526 537 548559 568 579 589 601 610 620 631 640 652 662 673 682 692 704 713 724 734 745 755 766 776 785 796 807 818 827 838 848 860 869 879 890 899 911 921 932 941 951 963 973 983 993 1004 1015 1025 1035 1045 1055 1066 1077 1087 1097 1107 1119 1129 1138 1149 1159 1171 1180 1191 1201 1210 1222 1232 1243 1252 1263 1274 1285 1294 1304 1315 1325 1336 1346 1357 1366 1378 1388 1397 1408 1418 1430 1439 1450 1460 1469 1481 1491 1502 1511 1522 1533 1544 1553 1563 1574 1585 1595 1605 1616 1625 1637 1647 1657 1667 1677 1689 1699 1709 1719 1729 1741 1750 1761 1771 1781 1792 1803 1813 1822 1833 1844 1855 1864 1875 1885 1897 1906 1916 1927 1936 1948 1958 1969 1978 1988 2000 2009 2020 2030 2041 2051 2062 2072 2081 2092 2103 2114 2123 2134 2144 2156 2165 2175 2186 2195 2207 2217 2228 2237 2247 2259 2269 2279 2289 2300 2311 2321 2331 2341 2351 2362 2373 2383 2393 2403 2415 2425 2434 2445 2455 2467 2476 2487 2497 2506 2518 2528 2539 2548 2559 2570 2581 2590 2600 2611 2621 2632 2642 2653 2662 2674 2684 2693 2704 2714 2726 2735 2746 2756 2765 2777 2787 2798 2807 2818 2829 2840 2849 2859 2870 2881 2891 2901 2912 2921 2933 2943 2953 2963 2973 2985 2995 3005 3015 3025 3037 3046 3057 3067 3077 3088 3099 3109 3118 3129 3140 3151 3160 3171 3181 3193 3202 3212 3223 3232 3244 3254 3265 3274 3284 3296 3305 3316 3326 3337 3347 3358 3368 3377 3388 3399 3410 3419 3430 3440 3452 3461 3471 3482 3491 3503 3513 3524 3533 3543 3555 3565 3575 3585 3596 3607 3617 3627 3637 3647 3658 3669 3679 3689 3699 3711 3721 3730 3741 3751 3763 3772 3783 3793 3802 3814 3824 3835 3844 3855 3866 3877 3886 3896 3907 3917 3928 3938 3949 3958 3970 3980 3989 4000 4010 4022 4031 4042 4052 4061 4073 4083 4094 4103 4114 4125 4136 4145 4155 4166 4177 4187 4197 4208 4217 4229 4239 4249 4259 4269 4281 4291 4301 4311 4321 4333 4342 4353 4363 4373 4384 4395 4405 4414 4425 4436 4447 4456 4467 4477 4489 4498 4508 4519 4528 4540 4550 4561 4570 4580 4592 4601 4612 4622 4633 4643 4654 4664 4673 4684 4695 4706 4715 4726 4736 4748 4757 4767 4778 4787 4799 4809 4820 4829 4839 4851 4861 4871 4881 4892 4903 4913 4923 4933 4943 4954 4965 4975 4985 4995 5007 5017 5026 5037 5047 5059 5068 5079 5089 5098 5110 5120 5131 5140 5151 5162 5173 5182 5192 5203 5213 5224 5234 5245 5254 5266 5276 5285 5296 5306 5318 5327 5338 5348 5357 5369 5379 5390 5399 5410 5421 5432 5441 5451 5462 5473 5483 5493 5504 5513 5525 5535 5545 5555 5565 5577 5587 5597 5607 5617 5629 5638 5649 5659 5669 5680 5691 5701 5710 5721 5732 5743 5752 5763 5773 5785 5794 5804 5815 5824 5836 5846 5857 5866 5876 5888 5897 5908 5918 5929 5939 5950 5960 5969 5980 5991 6002 6011 6022 6032 6044 6053 6063 6074 6083 6095 6105 6116 6125 6135 6147 6157 6167 6177 6188 6199 6209 6219 6229 6239 6250 6261 6271 6281 6291 6303 6313 6322 6333 6343 6355 6364 6375 6385 6394 6406 6416 6427 6436 6447 6458 6469 6478 6488 6499 6509 6520 6530 6541 6550 6562 6572 6581 6592 6602 6614 6623 6634 6644 6653 6665 6675 6686 6695 6706 6717 6728 6737 6747 6758 6769 6779 6789 6800 6809 6821 6831 6841 6851 6861 6873 6883 6893 6903 6913 6925 6934 6945 6955 6965 6976 6987 6997 7006 7017 7028 7039 7048 7059 7069 7081 7090 7100 7111 7120 7132 7142 7153 7162 7172 7184 7193 7204 7214 7225 7235 7246 7256 7265 7276 7287 7298 7307 7318 7328 7340 7349 7359 7370 7379 7391 7401 7412 7421 7431 7443 7453 7463 7473 7484 7495 7505 7515 7525 7535 7546 7557 7567 7577 7587 7599 7609 7618 7629 7639 7651 7660 7671 7681 7690 7702 7712 7723 7732 7743 7754 7765 7774 7784 7795 7805 7816 7826 7837 7846 7858 7868 7877 7888 7898 7910 7919 7930 7940 7949 7961 7971 7982 7991 8002 8013 8024 8033 8043 8054 8065 8075 8085 8096 8105 8117 8127 8137 8147 8157 8169 8179 8189 8199 8209 8221 8230 8241 8251 8261 8272 8283 8293 8302 8313 8324 8335 8344 8355 8365 8377 8386 8396 8407 8416 8428 8438 8449 8458 8468 8480 8489 8500 8510 8521 8531 8542 8552 8561 8572 8583 8594 8603 8614 8624 8636 8645 8655 8666 8675 8687 8697 8708 8717 8727 8739 8749 8759 8769 8780 8791 8801 8811 8821 8831 8842 8853 8863 8873 8883 8895 8905 8914 8925 8935 8947 8956 8967 8977 8986 8998 9008 9019 9028 9039 9050 9061 9070 9080 9091 9101 9112 9122 9133 9142 9154 9164 9173 9184 9194 9206 9215 9226 9236 9245 9257 9267 9278 9287 9298 9309 9320 9329 9339 9350 9361 9371 9381 9392 9401 9413 9423 9433 9443 9453 9465 9475 9485 9495 9505 9517 9526 9537 9547 9557 9568 9579 9589 9598 9609 9620 9631 9640 9651 9661 9673 9682 9692 9703 9712 9724 9734 9745 9754 9764 9776 9785 9796 9806 9817 9827 9838 9848 9857 9868 9879 9890 9899 9910 9920 9932 9941 9951 9962 9971 9983 9993 4 15 27 41 53 65 77 91 104 116 128 140 152 165 178 190 202 214 229 241 251 265 277 291 302 315 327 338 352 364 377 388 401 415 428 439 451 464 476 489 501 514 525 539 551 562 575 587 602 613 626 638 649 663 675 688 699 712 725 739 749 761 775 788 800 812 825 836 850 862 874 886 898 913 925 937 949 961 975 986 999 1011 1023 1036 1049 1061 1072 1085 1099 1112 1123 1136 1148 1162 1173 1185 1198 1209 1223 1235 1249 1259 1271 1286 1297 1310 1322 1335 1347 1360 1372 1383 1396 1409 1423 1433 1447 1459 1473 1484 1496 1509 1520 1534 1546 1559 1570 1582 1597 1609 1621 1633 1646 1659 1671 1683 1695 1707 1720 1733 1745 1757 1769 1784 1796 1807 1820 1832 1846 1857 1870 1882 1893 1907 1919 1933 1943 1957 1970 1983 1994 2006 2019 2031 2044 2056 2069 2080 2095 2107 2117 2131 2143 2157 2168 2181 2193 2204 2218 2230 2243 2254 2267 2281 2294 2305 2317 2330 2343 2355 2367 2380 2391 2405 2417 2429 2441 2453 2468 2480 2492 2504 2516 2530 2541 2554 2566 2578 2591 2605 2617 2627 2641 2654 2667 2678 2691 2703 2717 2728 2740 2753 2764 2779 2791 2804 2815 2827 2841 2852 2865 2877 2890 2902 2915 2927 2938 2951 2965 2978 2989 3002 3014 3028 3039 3051 3064 3075 3089 3101 3115 3125 3137 3152 3164 3176 3188 3201 3214 3226 3238 3250 3262 3275 3289 3301 3313 3325 3339 3351 3362 3375 3387 3401 3412 3425 3437 3448 3463 3475 3488 3499 3512 3525 3538 3549 3561 3574 3586 3599 3611 3625 3635 3650 3662 3673 3686 3698 3712 3723 3736 3748 3759 3773 3785 3799 3809 3823 3836 3849 3860 3872 3885 3898 3910 3922 3935 3946 3961 3973 3985 3997 4009 4023 4035 4047 4059 4071 4085 4096 4109 4121 4133 4147 4160 4172 4183 4196 4209 4222 4233 4246 4258 4273 4283 4295 4309 4319 4334 4346 4359 4370 4382 4396 4407 4420 4432 4445 4457 4471 4483 4493 4507 4520 4533 4544 4557 4569 4583 4594 4606 4619 4630 4645 4657 4670 4681 4693 4707 4719 4731 4743 4756 4769 4781 4793 4805 4817 4831 4844 4856 4868 4880 4894 4906 4917 4930 4942 4957 4967 4981 4993 5003 5018 5030 5043 5054 5067 5080 5093 5104 5116 5129 5141 5155 5167 5180 5191 5205 5217 5228 5241 5253 5267 5278 5291 5303 5314 5329 5341 5354 5365 5378 5391 5404 5415 5427 5440 5453 5465 5477 5491 5501 5516 5528 5540 5552 5564 5578 5590 5602 5614 5626 5641 5651 5665 5677 5689 5702 5715 5727 5738 5751 5764 5777 5788 5801 5813 5828 5839 5851 5864 5875 5889 5901 5914 5925 5937 5951 5962 5975 5987 6001 6013 6026 6038 6049 6062 6075 6088 6099 6112 6124 6139 6149 6161 6175 6185 6200 6212 6225 6236 6248 6262 6274 6286 6298 6311 6325 6337 6349 6361 6373 6386 6399 6411 6423 6435 6449 6461 6472 6485 6497 6512 6523 6536 6548 6559 6573 6585 6598 6609 6622 6635 6649 6659 6671 6685 6697 6710 6722 6735 6746 6760 6772 6783 6796 6808 6823 6833 6847 6859 6869 6884 6896 6909 6920 6933 6946 6959 6970 6982 6995 7009 7021 7033 7046 7057 7071 7083 7095 7107 7119 7133 7145 7157 7169 7181 7196 7207 7220 7232 7244 7257 7270 7282 7293 7306 7319 7333 7343 7357 7369 7383 7394 7406 7419 7430 7444 7456 7469 7480 7492 7507 7517 7531 7543 7556 7568 7581 7593 7604 7617 7630 7643 7654 7667 7679 7694 7705 7717 7730 7741 7755 7767 7780 7791 7803 7817 7829 7841 7853 7867 7880 7892 7904 7916 7928 7941 7954 7966 7978 7990 8005 8017 8027 8041 8053 8067 8078 8091 8103 8114 8128 8140 8153 8164 8177 8191 8204 8215 8227 8240 8252 8265 8277 8290 8301 8315 8327 8338 8351 8363 8378 8389 8402 8414 8425 8439 8451 8464 8475 8488 8501 8515 8525 8537 8551 8564 8576 8588 8601 8612 8626 8638 8650 8662 8674 8689 8701 8713 8725 8737 8751 8762 8775 8787 8799 8812 8825 8837 8848 8861 8875 8888 8899 8912 8924 8938 8949 8961 8974 8985 8999 9011 9025 9035 9047 9062 9073 9086 9098 9111 9123 9136 9148 9159 9172 9185 9199 9209 9223 9235 9249 9260 9272 9285 9296 9310 9322 9335 9346 9358 9373 9385 9397 9409 9422 9435 9447 9459 9471 9483 9496 9509 9521 9533 9545 9560 9572 9583 9596 9608 9622 9633 9646 9658 9669 9683 9695 9709 9719 9733 9746 9759 9770 9782 9795 9807 9820 9832 9845 9856 9871 9883 9893 9907 9919 9933 9944 9957 9969 9980 9994 7 22 3551 68 83 97 111 127 142 157 171 187 200 217 231 245 260 274 292 307 321 335 350 367 380 395 410 424 440 457 471 483 500 515 531 544 560 574 591 604 619 634 647 665 680 695 709 723 740 753 769 783 799 813 829 843 856 872 889 904 917 933 947 964 977 992 1007 1021 1037 1052 1069 1081 1095 1113 1127 1142 1156 1172 1187 1202 1216 1231 1245 1261 1277 1292 1306 1321 1337 1352 1365 1381 1395 1412 1425 1441 1455 1468 1486 1501 1516 1529 1545 1561 1576 1589 1604 1619 1634 1649 1664 1681 1693 1711 1725 1738 1754 1768 1785 1798 1814 1828 1841 1858 1873 1889 1901 1918 1934 1949 1963 1977 1993 2008 2023 2037 2053 2066 2084 2098 2113 2127 2141 2158 2173 2187 2201 2216 2233 2246 2261 2276 2290 2307 2323 2337 2350 2366 2381 2397 2410 2426 2440 2458 2470 2485 2501 2513 2531 2546 2561 2575 2589 2606 2619 2635 2649 2665 2679 2696 2710 2722 2739 2755 2770 2783 2799 2813 2830 2843 2858 2873 2887 2905 2919 2935 2948 2962 2979 2993 3008 3022 3038 3053 3068 3082 3097 3111 3128 3143 3158 3172 3187 3203 3218 3231 3247 3261 3279 3291 3308 3322 3334 3352 3367 3382 3395 3411 3427 3442 3455 3470 3485 3500 3517 3531 3547 3560 3577 3591 3604 3620 3634 3651 3664 3680 3694 3707 3725 3740 3755 3769 3784 3800 3815 3829 3843 3859 3874 3889 3903 3920 3932 3950 3964 3979 3993 4007 4024 4039 4053 4067 4082 4100 4112 4129 4143 4157 4173 4189 4203 4216 4232 4247 4263 4276 4292 4306 4324 4337 4352 4367 4381 4397 4412 4427 4441 4455 4472 4485 4501 4515 4532 4546 4562 4576 4589 4605 4621 4636 4649 4665 4679 4697 4709 4724 4741 4753 4771 4785 4801 4814 4828 4845 4859 4874 4888 4904 4921 4935 4949 4964 4978 4994 5009 5024 5038 5053 5069 5084 5097 5113 5127 5145 5158 5174 5188 5201 5218 5233 5248 5261 5277 5293 5309 5321 5336 5353 5367 5383 5397 5413 5426 5443 5457 5470 5486 5500 5518 5530 5547 5561 5573 5591 5606 5621 5635 5650 5666 5681 5695 5709 5725 5741 5756 5770 5786 5799 5816 5830 5845 5859 5873 5890 5905 5919 5933 5948 5966 5979 5995 6009 6023 6039 6055 6069 6082 6098 6113 6130 6142 6159 6173 6190 6203 6218 6233 6247 6263 6278 6293 6307 6321 6339 6351 6368 6382 6398 6412 6428 6442 6455 6471 6487 6502 6515 6531 6545 6563 6577 6591 6607 6620 6637 6651 6667 6680 6694 6711 6725 6740 6754 6771 6787 6801 6815 6830 6844 6860 6875 6890 6904 6919 6937 6951 6963 6980 6994 7011 7024 7040 7054 7067 7084 7099 7114 7127 7143 7160 7175 7189 7203 7219 7233 7249 7263 7279 7292 7309 7323 7336 7352 7366 7384 7397 7413 7427 7441 7457 7472 7487 7501 7516 7532 7549 7561 7575 7592 7607 7622 7636 7652 7665 7682 7696 7711 7725 7739 7757 7772 7786 7801 7815 7832 7845 7861 7875 7889 7905 7921 7935 7948 7964 7981 7996 8009 8025 8039 8056 8069 8084 8099 8113 8129 8144 8161 8173 8187 8205 8218 8234 8248 8264 8278 8294 8308 8321 8337 8353 8369 8381 8398 8413 8429 8443 8457 8473 8486 8503 8517 8533 8546 8560 8578 8593 8607 8621 8637 8653 8667 8681 8696 8710 8726 8741 8756 8770 8785 8803 8817 8830 8846 8860 8877 8890 8906 8920 8933 8950 8965 8981 8993 9010 9026 9041 9055 9069 9085 9099 9115 9129 9145 9158 9176 9190 9202 9219 9233 9250 9263 9279 9293 9307 9323 9338 9353 9367 9382 9399 9415 9428 9442 9458 9473 9488 9502 9518 9531 9548 9562 9577 9591 9605 9623 9638 9652 9667 9681 9698 9711 9727 9741 9755 9771 9788 9802 9814 9831 9847 9862 9875 9891 9905 9922 9935 9950 9965 9979 9997 13 32 47 64 85 100 119 136 155 172 191 208 224 243 263 281 298 316 334 353 370 387 406 422 442 459 479 494 511 532 550 567 584 603 622 639 656 674 691 710 730 747 764 782 802 819 835 854 871 891 907 926 943 958 980 998 1016 1033 1051 1070 1088 1105 1121 1141 1157 1177 1193 1214 1228 1250 1267 1282 1301 1318 1339 1354 1373 1390 1407 1426 1444 1465 1479 1498 1517 1537 1552 1569 1588 1606 1624 1641 1660 1676 1697 1714 1732 1749 1767 1786 1804 1821 1839 1856 1876 1892 1911 1928 1945 1965 1984 2001 2017 2036 2055 2073 2089 2108 2125 2146 2161 2179 2199 2213 2235 2252 2271 2287 2303 2324 2339 2359 2375 2395 2411 2432 2449 2463 2483 2503 2521 2537 2555 2573 2593 2609 2626 2645 2661 2683 2699 2719 2734 2751 2771 2789 2806 2823 2842 2861 2878 2895 2913 2930 2950 2969 2986 3003 3021 3041 3058 3074 3093 3110 3131 3146 3166 3183 3197 3219 3237 3255 3272 3290 3309 3327 3344 3361 3380 3397 3417 3434 3453 3469 3489 3506 3521 3541 3557 3578 3593 3613 3629 3646 3668 3685 3704 3719 3737 3757 3776 3791 3808 3827 3845 3863 3880 3901 3915 3937 3953 3971 3988 4006 4025 4043 4060 4078 4095 4117 4131 4151 4168 4186 4204 4223 4240 4256 4275 4294 4312 4328 4347 4364 4385 4402 4419 4438 4454 4474 4491 4510 4526 4543 4563 4579 4598 4615 4635 4652 4671 4688 4705 4723 4742 4760 4777 4795 4813 4834 4849 4865 4886 4900 4922 4939 4958 4973 4990 5011 5029 5045 5062 5081 5102 5119 5137 5153 5170 5189 5209 5225 5242 5260 5281 5297 5313 5332 5349 5371 5386 5405 5422 5439 5458 5476 5494 5511 5529 5548 5569 5583 5600 5620 5637 5656 5673 5692 5708 5728 5745 5761 5780 5797 5818 5833 5853 5871 5885 5907 5924 5943 5959 5977 5996 6015 6031 6047 6067 6087 6104 6121 6140 6155 6176 6193 6211 6227 6245 6265 6283 6299 6317 6334 6356 6371 6391 6407 6425 6443 6463 6479 6495 6514 6533 6553 6567 6587 6605 6625 6641 6658 6677 6693 6713 6730 6749 6765 6782 6803 6818 6838 6855 6874 6891 6910 6927 6944 6962 6981 6999 7016 7034 7052 7073 7089 7106 7125 7141 7161 7178 7197 7213 7229 7250 7268 7285 7301 7322 7341 7358 7376 7393 7409 7429 7448 7465 7481 7499 7521 7538 7552 7573 7589 7610 7625 7645 7661 7678 7697 7715 7733 7750 7768 7789 7808 7823 7840 7859 7876 7895 7912 7931 7947 7967 7984 8000 8019 8036 8057 8074 8092 8110 8126 8146 8163 8182 8198 8216 8235 8255 8270 8287 8307 8326 8343 8360 8379 8395 8415 8432 8450 8467 8485 8506 8523 8540 8558 8575 8595 8611 8630 8647 8665 8683 8702 8719 8734 8753 8774 8792 8809 8827 8845 8864 8881 8897 8917 8932 8953 8969 8990 9004 9021 9043 9058 9077 9094 9113 9130 9149 9166 9183 9201 9220 9241 9255 9274 9292 9313 9328 9345 9364 9380 9400 9417 9436 9452 9469 9490 9508 9525 9543 9561 9580 9597 9615 9632 9649 9668 9687 9704 9721 9739 9760 9777 9793 9812 9829 9849 9865 9884 9901 9917 9937 9955 9975 9989 10 33 56 75 94 118 137 161 181 205 223 249 269 286 310 332 356 375 397 418 437 461 482 505 524 545 569 593 611 632 655 677 698 718 741 760 784 805 826 847 868 893 914 934 956 976 1000 1019 1042 1063 1084 1106 1130 1150 1167 1192 1215 1237 12571279 1300 1323 1343 1364 1387 1405 1431 1451 1474 1493 1513 1538 1556 1580 1599 1623 1642 1666 1685 1706 1727 1753 1775 1793 18151837 1862 1880 1900 1923 1942 1966 1987 2012 2029 2049 2074 2096 2116 2138 2159 2182 2203 2224 2245 2265 2288 2312 2332 2354 23742398 2419 2438 2461 2481 2505 2524 2547 2567 2588 2613 2633 2656 2675 2697 2720 2743 2762 2782 2805 2825 2848 2869 2893 2909 29362956 2977 2998 3020 3043 3063 3085 3106 3124 3149 3169 3194 3211 3236 3257 3280 3298 3319 3341 3365 3385 3405 3428 3447 3473 34953514 3535 3556 3581 3601 3621 3643 3663 3687 3706 3729 3749 3771 3794 3817 3837 3857 3879 3902 3923 3944 3965 3987 4013 4030 40514075 4093 4118 4138 4161 4180 4201 4225 4244 4267 4287 4310 4330 4354 4376 4393 4417 4439 4462 4481 4503 4525 4549 4568 4587 46114629 4655 4676 4699 4717 4738 4762 4784 4803 4825 4846 4870 4889 4911 4931 4952 4976 5000 5019 5041 5061 5086 5105 5125 5147 51685194 5211 5235 5257 5275 5300 5320 5343 5362 5384 5407 5429 5449 5469 5492 5512 5536 5557 5579 5599 5623 5643 5663 5685 5707 57295750 5771 5793 5811 5837 5858 5881 5900 5923 5944 5967 5986 6005 6029 6052 6073 6092 6117 6134 6160 6182 6202 6221 6243 6268 62896308 6329 6350 6376 6393 6418 6437 6459 6481 6505 6524 6544 6566 6589 6610 6631 6652 6674 6700 6718 6739 6761 6781 6805 6825 68486867 6887 6911 6931 6953 6974 6998 7019 7041 7063 7082 7103 7126 7149 7168 7190 7211 7237 7255 7275 7299 7316 7342 7363 7385 74057426 7449 7471 7491 7513 7534 7558 7579 7600 7621 7642 7664 7687 7707 7729 7748 7773 7793 7811 7834 7855 7881 7901 7923 7945 79637988 8007 8031 8049 8071 8093 8119 8135 8156 8180 8200 8223 8243 8266 8285 8309 8330 8350 8372 8393 8420 8437 8459 8481 8499 85248545 8567 8587 8609 8631 8654 8673 8693 8716 8740 8761 8782 8804 8823 8847 8869 8889 8909 8931 8955 8975 8996 9017 9037 9063 90829105 9125 9147 9169 9191 9212 9231 9253 9277 9301 9317 9341 9363 9387 9406 9425 9449 9467 9493 9512 9536 9554 9574 9601 9617 96419663 9685 9706 9728 9749 9769 9790 9813 9836 9855 9877 9898 9925 9943 9963 9986 5 34 58 86 109 135 163 188 213 238 266 293 317 344 368 394 421 447 472 497 523 553 577 597 627 653 681 705 731 757 778 809 833 861 883 908 939 965 989 1012 1041 1064 1093 1115 1144 1166 1196 1220 1244 1270 1295 1328 1349 1375 1401 1424 1453 1477 1504 1527 1555 1581 1611 1631 1655 1684 1712 1736 1762 1789 1811 1840 1865 1891 1915 1941 1971 1995 2021 2045 2071 2099 2122 2150 2174 2200 2225 2253 2278 2302 2329 2357 2384 2408 2433 2459 2488 2511 2535 2563 2584 2614 2639 2668 2689 2713 2744 2769 2794 2821 2847 2872 2899 2924 2945 2972 2999 3029 3050 3080 3103 3133 3154 3179 3207 3230 3259 3283 3310 3333 3359 3391 3413 3439 3464 3490 3518 3542 3568 3592 3619 3644 3671 3697 3722 3747 3777 3801 3826 3851 3878 3905 3929 3956 3981 4004 4033 4058 4087 4108 4137 4162 4190 4213 4238 4265 4289 4317 4341 4369 4390 4421 4448 4468 4497 4522 4551 4575 4600 4627 4648 4678 4701 4730 4751 4779 4808 4835 4857 4882 4909 4937 4960 4987 5012 5036 5065 5090 5115 5139 5165 5197 5219 5246 5270 5295 5324 5347 5374 5398 5425 5450 5479 5505 5527 5554 5581 5608 5631 5657 5684 5713 5735 5759 5787 5810 5840 5865 5893 5915 5941 5968 5993 6019 6045 6070 6097 6123 6148 6170 6196 6226 6254 6277 6304 6328 6357 6380 6404 6433 6454 6484 6507 6537 6557 6584 6615 6639 6663 6688 6715 6743 6766 6793 6817 6843 6868 6898 6922 6947 6973 7003 7025 7049 7076 7102 7129 7154 7179 7205 7228 7258 7283 7311 7334 7361 7387 7414 7437 7462 7489 7514 7541 7565 7594 7616 7646 7672 7695 7721 7747 7775 7798 7825 7851 7873 7903 7927 7955 7976 8006 8032 8060 8083 8108 8134 8162 8186 8212 8237 8259 8291 8317 8342 8367 8391 8421 8445 8471 8494 8518 8549 8571 8597 8623 8648 8679 8704 8731 8752 8777 8805 8834 8855 8882 8907 8939 8960 8984 9013 9034 9064 9089 9116 9140 9165 9193 9217 9243 9269 9295 9321 9349 9374 9395 9424 9451 9478 9501 9529 9553 9581 9604 9629 9656 9677 9710 9735 9761 9784 9811 9839 9863 9889 9914 9940 9968 9992 21 49 79 113 147 177 207 235 272 301 328 359 389 429 453 488 518 543 580 609 644 669 701 733 767 793 821 855 885 920 950 982 1009 1043 1076 1102 1133 1165 1199 1227 1258 1288 1317 1353 1382 1415 1443 1475 1508 1539 1568 1598 1630 1663 1691 1724 1755 1779 1819 1849 1879 1909 1940 1973 2002 2035 2063 2091 2129 2152 2189 2221 2251 2282 2314 2345 2372 2402 2437 2469 2495 2527 2557 2596 2624 2650 2685 2711 2747 2775 2809 2835 2866 2900 2929 2960 2991 3023 3056 3086 3117 3145 3178 3209 3241 3269 3302 3332 3369 3394 3423 3457 3483 3520 3550 3583 3610 3641 3676 3705 3734 3765 3797 3831 3862 3892 3921 3952 3982 4016 4045 4076 4105 4139 4169 4198 4231 4261 4298 4325 4355 4388 4413 4449 4479 4511 4537 4571 4604 4637 4663 4691 4727 4759 4791 4821 4852 4879 4915 4946 4972 5002 5033 5072 5096 5132 5159 5185 5223 5252 5284 5312 5345 5375 5408 5435 5468 5499 5534 5563 5594 5624 5655 5686 5717 5746 5779 5807 5842 5872 5902 5932 5961 5997 6027 6058 6089 6118 6152 6183 6213 6242 6272 6305 6340 6365 6400 6429 6464 6493 6521 6555 6580 6616 6645 6679 6704 6736 6773 6797 6832 6865 6895 6926 6956 6988 7013 7047 7077 7112 7138 7171 7201 7239 7264 7297 7327 7354 7388 7420 7451 7479 7509 7544 7574 7603 7635 7669 7700 7731 7760 7790 7820 7852 7885 7913 7946 7975 8011 8042 8068 8101 8132 8165 8194 8225 8257 8284 8319 8348 8380 8408 8441 8474 8507 8535 8566 8596 8629 8659 8690 8722 8747 8783 8813 8840 8871 8903 8941 8968 9001 9029 9056 9093 9121 9155 9181 9214 9244 9280 9305 9337 9370 9404 9431 9461 9494 9523 9555 9587 9616 9647 9676 9716 9742 9773 9803 9833 9867 9897 9927 9958 9987 25 62 99 130 170 212 250 284 323 358 399 431 467 508 541 583 617 658 689 727 770 803 842 878 915 955 991 1028 1059 1101 1137 1179 1208 1251 1287 1329 1361 1400 1436 1467 1510 1547 1587 1617 1654 1700 1735 1772 1805 1847 1883 1922 1954 1991 2027 2065 2105 2139 2177 2211 2257 2295 2325 2365 2401 2444 2475 2512 2549 2583 2625 2660 2701 2732 2773 2812 2851 2884 2920 2959 2996 3032 3071 3107 3142 3185 3221 3253 3293 3331 3370 3404 3445 3478 3509 3553 3590 3628 3661 3701 3742 3779 3812 3850 3887 3927 3963 3999 4036 4069 4111 4148 4181 4220 4255 4299 4335 4371 4406 4442 4484 4517 4555 4593 4628 4666 4708 4744 4774 4816 4853 4895 4925 4966 5001 5044 5075 5111 5149 5183 5227 5263 5302 5335 5372 5414 5447 5485 5521 5559 5595 5633 5672 5703 5744 5781 5822 5854 5894 5931 5972 6004 6040 6080 6110 6153 6191 6231 6260 6297 6341 6377 6415 6451 6490 6527 6565 6599 6632 6670 6709 6752 6788 6824 6857 6901 6938 6969 7005 7042 7085 7118 7155 7192 7227 7271 7305 7345 7377 7417 7455 7496 7527 7564 7601 7637 7676 7714 7751 7783 7827 7863 7897 7937 7973 8014 8048 8086 8121 8155 8197 8233 8273 8305 8345 8385 8422 8456 8493 8529 8569 8605 8641 8680 8715 8758 8794 8828 8866 8900 8942 8978 9015 9051 9087 9128 9163 9200 9237 9271 9314 9352 9388 9418 9460 9500 9538 9569 9611 9644 9689 9718 9753 9797 9825 9872 9908 9946 9977 17 69 107 151 197 242 285 337 379 416 466 509 557 596 645 687 735 777 820 865 905 957 1001 1047 1090 1131 1181 1225 1268 1311 1358 1403 1448 1490 1531 1577 1628 1673 1717 1760 1801 1850 1898 1935 1979 2026 2078 2115 2164 2209 2242 2296 2338 2386 2423 2473 2519 2564 2602 2648 2692 2737 2786 2833 2876 2917 2967 3010 3049 3094 3136 3189 3229 3273 3317 3356 3409 3454 3497 3539 3584 3633 3677 3716 3764 3807 3853 3895 3941 3992 4028 4079 4123 4165 4211 4252 4303 4345 4389 4431 4475 4527 4565 4613 4658 4700 4749 4792 4837 4877 4924 4969 5015 5055 5103 5146 5198 5237 5283 5326 5363 5417 5461 5507 5543 5588 5642 5678 5723 5768 5821 5861 5909 5953 5989 6037 6081 6131 6169 6217 6256 6314 6347 6392 6441 6477 6529 6574 6617 6661 6703 6753 6795 6839 6881 6929 6977 7023 7064 7109 7150 7198 7241 7289 7330 7373 7423 7466 7508 7551 7595 7647 7688 7737 7777 7819 7869 7911 7957 7997 8045 8089 8139 8175 8222 8269 8312 8359 8403 8446 8492 8536 8581 8619 8669 8709 8765 8797 8852 8891 8929 8983 9027 9071 9107 9157 9207 9251 9289 9332 9379 9430 9476 9514 9565 9603 9655 9694 9737 9781 9824 9874 9915 9961 1 57 121 169221 273 325 385 436 490 536 595 646 706 752 811 863 922 969 1027 1078 1124 1184 1239 1293 1340 1393 1457 1503 1562 1612 1669 17181777 1827 1871 1930 1985 2043 2087 2149 2194 2260 2308 2360 2416 2462 2523 2576 2631 2677 2729 2792 2837 2894 2944 3007 3059 31163161 3215 3267 3323 3376 3431 3481 3532 3598 3653 3693 3754 3806 3867 3913 3967 4017 4066 4126 4179 4234 4282 4339 4399 4450 44994553 4609 4661 4714 4766 4822 4873 4929 4983 5032 5087 5138 5199 5249 5305 5356 5401 5464 5519 5571 5615 5674 5734 5789 5831 58835945 6003 6056 6106 6164 6207 6269 6320 6369 6421 6476 6538 6593 6643 6692 6745 6807 6853 6908 6961 7012 7066 7124 7177 7222 72807335 7395 7438 7498 7550 7611 7657 7708 7762 7810 7870 7924 7983 8026 8079 8143 8192 8247 8299 8356 8405 8463 8511 8559 8618 86728732 8776 8835 8885 8943 8992 9046 9104 9151 9208 9262 9315 9365 9416 9479 9530 9586 9634 9691 9747 9799 9850 9903 9953 14 76 145199 259 343 404 458 529 586 661 717 790 845 903 971 1034 1109 1163 1234 1303 1369 1421 1487 1551 1613 1682 1743 1810 1868 1951 2005 2060 2132 2192 2264 2319 2389 2451 2510 2582 2643 2708 2763 2834 2907 2971 3031 3092 3159 3224 3287 3349 3418 3477 3548 3608 3670 3733 3790 3869 3931 3995 4057 4119 4191 4251 4316 4377 4433 4505 4577 4640 4690 4765 4827 4897 4951 5021 5077 5156 5210 5271 5339 5396 5475 5537 5605 5660 5720 5795 5849 5917 5983 6046 6109 6178 6238 6296 6363 6434 6501 6556 6627 6687 6757 6814 6879 6941 7004 7075 7136 7210 7262 7325 7400 7460 7523 7585 7653 7719 7781 7844 7906 7970 8035 8104 8170 8229 8295 8362 8423 8482 8553 8615 8684 8744 8810 8870 8926 9003 9068 9134 9188 9259 9327 9389 9445 9511 9573 9639 9701 9767 9841 9892 9970 39 105 183 256 345 411 493 566 637 721 795 881 946 1029 1114 1189 1265 1331 1417 1495 1573 1648 1726 1797 1887 1959 2038 2109 2185 2272 2347 2420 2494 2571 2657 2727 2800 2883 2955 3034 3121 3195 3266 3345 3421 3505 3569 3655 3728 3819 3884 3957 4040 4102 4195 4274 4349 4424 4492 4585 4647 4733 4802 4887 4959 5050 5122 5181 5269 5355 5433 5497 5572 5648 5737 5806 5882 5957 6034 6127 6195 6279 6346 6419 6506 6579 6657 6729 6812 6886 6968 7037 7117 7186 7273 7351 7435 7503 7582 7659 7738 7809 7887 7959 8050 8120 8206 8276 8336 8431 8509 8585 8657 8733 8818 8896 8963 9044 9119 9197 9284 9356 9439 9503 9590 9665 9730 9819 9885 9976 44 148 233 313 430 519 615 697 791 896 985 1071 1155 1253 1345 1438 1526 1639 1703 1825 1905 1997 2086 2170 2273 2368 2452 2545 2636 2749 2822 2926 3013 3100 3196 3297 3383 3466 3567 3656 3758 3841 3939 4018 4130 4215 4304 4403 4490 4586 4683 4773 4863 4947 5051 5133 5231 5319 5419 5509 5612 5698 5775 5879 5974 6065 6145 6253 6332 6445 6519 6608 6721 6790 6902 6989 7091 7167 7253 7365 7445 7539 7628 7724 7833 7918 7999 8097 8183 8281 8373 8465 8554 8644 8745 8839 8921 9020 9106 9224 9302 9393 9482 9566 9674 9763 9854 9934 43 159 280 373 481 605 716 831 929 1054 1153 1275 1379 1483 1594 1702 1829 1925 2048 2151 2239 2377 2489 2599 2705 2816 2937 3045 3153 3248 3374 3496 3603 3713 3820 3914 4049 4153 4268 4361 4465 4597 4713 4810 4916 5025 5163 5259 5381 5482 5585 5699 5823 5926 6020 6141 6255 6383 6470 6596 6701 6826 6917 7031 7147 7247 7371 7478 7586 7689 7802 7933 8021 8149 8249 8371 8477 8589 8698 8795 8918 9033 9141 9242 9357 9466 9595 9699 9805 9926 26 179 303 446 561 683 839 968 1094 1217 1371 1519 1640 1763 1899 2014 2167 2297 2427 2553 2686 2855 2980 3081 3239 3353 3507 3626 3766 3893 4015 4154 4285 4429 4541 4687 4838 4982 5095 5216 5361 5487 5630 5758 5896 6017 6166 6290 6409 6549 6682 6836 6952 7093 7221 7348 7486 7624 7759 7883 8018 8151 8300 8410 8543 8691 8819 8957 9079 9227 9344 9487 9625 9752 9881 10000 194 346 502 667 817 994 1145 1309 1461 1603 1778 1952 2101 2236 2409 2597 2757 2885 3065 3205 3392 3529 3691 3842 4001 4174 4327 4514 4641 4796 4989 5123 5289 5444 5613 5767 5936 6091 6235 6401 6571 6731 6877 7055 7215 7378 7529 7685 7849 7993 8171 8329 8497 8639 8788 8972 9137 9286 9440 9613 9778 9928 93 295 473 670 877 1058 1241 1432 1652 1835 2013 2222 2390 2607 2780 2981 3167 3340 3563 3745 3945 4101 4318 4534 4721 4899 5073 5288 5456 5667 5847 6061 6220 6452 6628 6778 6991 7185 7402 7570 7766 7953 8122 8333 8528 8723 8913 9097 9303 9519 9675 9860 87 308 554 759 1006 1207 1466 1690 1913 2135 2348 2618 2857 3073 3304 3526 3781 3975 4226 4460 4672 4907 5175 5389 5570 5829 6077 6315 6513 6764 6985 7240 7436 7673 7894 8111 8387 8602 8854 9053 9266 9539 9725 9985 230 533 773 1079 1330 1591 1863 2210 2477 2721 2987 3281 3572 3833 4090 4378 4623 4940 5206 5522 5753 6010 6326 6601 6866 7135 7408 7703 7989 8242 8516 8768 9076 9375 9626 9911 220 572 897 1205 1541 1853 2229 2533 2864 3175 3460 3871 4205 4535 4843 5176 5542 5867 61846494 6850 7163 7522 7838 8207 8453 8857 9177 9457 9821 129 623 940 1389 1747 2121 2540 2942 3403 3715 4144 4558 4997 5331 5716 6133 6542 6939 7313 7745 8077 8579 8948 9331 9717 125 629 1120 1565 2057 2498 3016 3446 3974 4411 4864 5392 5911 6358 6775 7300 77978258 8705 9179 9659 255 748 1313 1961 2446 3123 3639 4241 4750 5311 5954 6466 7060 7613 8213 8767 9407 9949 449 1280 1976 2671 3315 4065 4735 5434 6101 6723 7474 8062 8878 9544 363 1018 1790 2761 3615 4360 5108 5984 6916 7633 8434 9229 73 1174 2285 3135 4088 5060 6205 7097 8061 9007 9998 1414 2333 3682 4786 5803 7291 8399 9551 853 2315 3788 5240 6650 7939 9410 928 2797 4463 6285 7862 9789 1675 3435 5645 7559 9842 2079 4618 7030 9171 2669 5551 8632 1525 5008 8661 2908 6668 742 6389 1742 8320 4277 3245 407 3909 73155693 386--- THE LAST OF NODE ---8991请按任意键继续. . . 程序有很多地方可以优化哟,去尝试一下吧亲（づ￣3￣）づ╭❤～ More interesting algorithms : [go my repository ~](https://github.com/YUbuntu0109/Data-Structures-and-Algorithm-Analysis-in-C 摘自我的CSDN博客,这篇博客是：2018/101/03 写的,博客地址 : https://blog.csdn.net/qq_43313515","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Data Structures and Algorithms","slug":"Data-Structures-and-Algorithms","permalink":"http://yoursite.com/tags/Data-Structures-and-Algorithms/"}]},{"title":"电子邮箱应用程序","slug":"电子邮箱应用程序","date":"2019-03-11T15:19:47.000Z","updated":"2019-08-25T06:31:01.196Z","comments":true,"path":"2019/03/11/电子邮箱应用程序/","link":"","permalink":"http://yoursite.com/2019/03/11/电子邮箱应用程序/","excerpt":"","text":"电子邮箱应用程序2.0. 每个版本的功能详情见我的该项目仓库. 如下示例,代码注释写的超贴心哟 （づ￣3￣）づ╭❤～ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /** * Title MimeMessage * @Description Create a email. * @param session,sendMail and receiveMail. * @return MimeMessage * @throws MessagingException * @throws IOException * @date Feb 21, 2019-11:02:10 AM * */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws MessagingException, IOException &#123; // 1: Create a email. MimeMessage message = new MimeMessage(session); // 2: From : addresser. message.setFrom(new InternetAddress(sendMail, \"Java Program\", \"UTF-8\")); // 3: To : recipients. message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(receiveMail, \"Program\", \"UTF-8\")); // 4: Subject : The email theme. message.setSubject(MY_EMAIL_SUBJECT, \"UTF-8\"); /* * Create the content of the email as followed . */ // 5: Create the node of image. MimeBodyPart image = new MimeBodyPart(); DataHandler dataHandler = new DataHandler(new FileDataSource(\"resource/Cute_pig.jpg\"));// read the local file. image.setDataHandler(dataHandler);// Add the data of image to the node. image.setContentID(\"image_Cut_pig_id\");// Set a unique number for the node and his ID is referenced in the text \"node\". // 6: Create the node of text. MimeBodyPart text = new MimeBodyPart(); // You can actually add web images by HTTP links as well. text.setContent(MY_EMAIL_CONTENT, \"text/html;charset=UTF-8\"); // 7: Combine text and image \"nodes\" into a hybrid \"node\". MimeMultipart mm_text_image = new MimeMultipart(); mm_text_image.addBodyPart(text); mm_text_image.addBodyPart(image); mm_text_image.setSubType(\"related\");// incidence relation. // 8: Encapsulate the text + image hybrid \"node\" as a normal \"node\". Attention: // The \"Content\" that is eventually added to the emailis a Multipart composed of \"bodyparts\". MimeBodyPart text_image = new MimeBodyPart(); text_image.setContent(mm_text_image); // 9: Create the node of attachment. MimeBodyPart attachment = new MimeBodyPart(); DataHandler dataHandler2 = new DataHandler(new FileDataSource(\"resource/Love_Yourself.mp3\")); attachment.setDataHandler(dataHandler2); // Set the file name of the attachment (encoding required). attachment.setFileName(MimeUtility.encodeText(dataHandler2.getName())); // 10: Set the relationship between ('text' + 'image') and the // 'attachment'.(compositing a large mixed \"node\"/Multipart). MimeMultipart mm_text_image_att = new MimeMultipart(); mm_text_image_att.addBodyPart(text_image);// reference: 8. mm_text_image_att.addBodyPart(attachment); mm_text_image_att.setSubType(\"mixed\");// mixed relations. // 11: Set the relationship for the entire email. (add the final mixed \"node\" as // the content of the email to the message object). message.setContent(mm_text_image_att); // 12: Set the date. message.setSentDate(new Date()); // 13: Save the setting. message.saveChanges(); return message;&#125; 程序运行效果截图 后期小哥哥我有时间会在版本2.0.上推出3.0.0 ：通过GUI设计简化用户操作,期待哟 ~ Download the source code : Try it now ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"水果贪吃蛇游戏","slug":"水果贪吃蛇游戏","date":"2019-03-10T14:34:41.000Z","updated":"2019-08-25T06:31:01.193Z","comments":true,"path":"2019/03/10/水果贪吃蛇游戏/","link":"","permalink":"http://yoursite.com/2019/03/10/水果贪吃蛇游戏/","excerpt":"","text":"Games-Gluttonous snack 2.1.0闲时写了一个贪吃蛇游戏,目前的版本是：2.1.0. 每个版本的功能详情见我的该游戏仓库 (源码注释写的很详细哟) 游戏截图 Download the source code , Have a good time to you ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"桌面应用程序：学生管理系统","slug":"学生管理系统-Java-swing","date":"2019-03-09T12:04:26.000Z","updated":"2019-08-25T06:31:01.161Z","comments":true,"path":"2019/03/09/学生管理系统-Java-swing/","link":"","permalink":"http://yoursite.com/2019/03/09/学生管理系统-Java-swing/","excerpt":"","text":"学生管理系统2.1.0. 每个版本的功能详情见我的该项目仓库. (文档注释写的非常详细哟) 登录界面 系统主界面 Download the source code , Look forward to your contribution ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-08T16:00:00.000Z","updated":"2019-08-25T06:31:01.108Z","comments":true,"path":"2019/03/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hi Hexo","slug":"Hi-Hexo","permalink":"http://yoursite.com/tags/Hi-Hexo/"}]}]}